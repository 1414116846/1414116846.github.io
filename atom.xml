<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇犽不爱健身</title>
  
  
  <link href="http://1414116846.github.io/atom.xml" rel="self"/>
  
  <link href="http://1414116846.github.io/"/>
  <updated>2023-10-30T11:19:34.175Z</updated>
  <id>http://1414116846.github.io/</id>
  
  <author>
    <name>爱摆烂的奇犽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试</title>
    <link href="http://1414116846.github.io/2023/10/26/%E6%B5%8B%E8%AF%95/"/>
    <id>http://1414116846.github.io/2023/10/26/%E6%B5%8B%E8%AF%95/</id>
    <published>2023-10-26T08:08:03.000Z</published>
    <updated>2023-10-30T11:19:34.175Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/1414116846/bloglmages@main/C:%5Chexo%5Csource%5CpicOIP.jpg"><img src="https://cdn.jsdelivr.net/gh/1414116846/bloglmages@main/C:%5Chexo%5Csource%5CpicR.jpg"/></p><p><img src="https://cdn.jsdelivr.net/gh/1414116846/bloglmages@main/C:%5Chexo%5Csource%5Cpic61B873E5E4E1560BF176671412B9C1C5.jpg" alt="61B873E5E4E1560BF176671412B9C1C5"></p>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
    <category term="测试" scheme="http://1414116846.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>yum源本地搭建及创建盘挂载加扩容</title>
    <link href="http://1414116846.github.io/2023/10/25/yum%E6%BA%90%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%89%A9%E5%AE%B9/"/>
    <id>http://1414116846.github.io/2023/10/25/yum%E6%BA%90%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%89%A9%E5%AE%B9/</id>
    <published>2023-10-25T12:48:51.000Z</published>
    <updated>2023-10-30T10:50:08.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redhat系统配置本地yum源"><a href="#redhat系统配置本地yum源" class="headerlink" title="redhat系统配置本地yum源"></a>redhat系统配置本地yum源</h1><p>前置名字可以换成自己的，在这里是ls</p><p>在&#x2F;home&#x2F;oracle下进行的命令</p><p>1.确保安装<code>createrepo</code>和<code>yum-utils</code>软件包。如果尚未安装，您可以使用以下命令安装它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install createrepo yum-utils</span><br></pre></td></tr></table></figure><p>2.创建一个目录来存放您的本地Yum源文件。例如，您可以使用以下命令创建一个名为<code>ls-yum</code>的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir ls-yum</span><br></pre></td></tr></table></figure><p>3.将您要提供的RPM软件包复制到<code>ls-yum</code>目录中。</p><p>4.运行以下命令生成本地Yum仓库的元数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo createrepo ls-yum</span><br></pre></td></tr></table></figure><p>5.创建一个Yum源配置文件，以告知系统如何访问本地Yum源。您可以使用任何文本编辑器创建一个新的 <code>.repo</code> 文件，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/yum.repos.d/ls-yum.repo</span><br></pre></td></tr></table></figure><p>6.在该文件中，添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ls-yum]</span><br><span class="line">name=Local Yum Repository</span><br><span class="line">baseurl=file:///home/oracle/ls-yum</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure><p>确保将<code>home/oracle/ls-yum</code>替换为您实际的本地Yum源目录路径。</p><p>1.保存并关闭文件。</p><p>2.现在，您可以使用Yum命令来安装、更新或删除软件包。例如，要列出可用的软件包，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yun install vim</span><br></pre></td></tr></table></figure><p>试试使用本地源进行软件包管理吧！</p><h2 id="在自己的虚拟机上创建一个-backup-虚拟机新添加一块5G的盘-创建lv挂载-backup目录，并再次扩容到10G"><a href="#在自己的虚拟机上创建一个-backup-虚拟机新添加一块5G的盘-创建lv挂载-backup目录，并再次扩容到10G" class="headerlink" title="在自己的虚拟机上创建一个&#x2F;backup 虚拟机新添加一块5G的盘,创建lv挂载&#x2F;backup目录，并再次扩容到10G"></a>在自己的虚拟机上创建一个&#x2F;backup 虚拟机新添加一块5G的盘,创建lv挂载&#x2F;backup目录，并再次扩容到10G</h2><p>前置名字可以换成自己的，在这里是ls</p><p>1.首先，确认你的虚拟机已经添加了一块5GB的新盘。可以使用命令 <code>lsblk</code> 或者 <code>fdisk -l</code> 来查看已有的磁盘列表。</p><p>2.使用命令 <code>sudo fdisk /dev/sdb</code> 打开新添加的磁盘进行分区。按照提示，创建一个新的主分区（Primary Partition）并将其设置为 Linux 文件系统类型（例如使用选项 <code>n</code> 和 <code>p</code>）。保存并退出。</p><p>3.使用命令 <code>sudo pvcreate /dev/sdb1</code> 来创建物理卷。</p><p>4.使用命令 <code>sudo vgcreate ls-vg /dev/sdb1</code> 来创建卷组。</p><p>5.使用命令 <code>sudo lvcreate -L 5G -n ls-lv ls-vg</code> 来创建5GB大小的逻辑卷。</p><p>6.使用命令 <code>sudo mkfs.ext4 /dev/ls-vg/ls-lv</code> 格式化逻辑卷。</p><p>7.创建挂载点 <code>/ls</code> 目录，使用命令 <code>sudo mkdir /ls</code>。</p><p>8.使用命令 <code>sudo mount /dev/ls-vg/ls-lv /ls</code> 将逻辑卷挂载到 <code>/ls</code> 目录。</p><p>9.在 <code>/etc/fstab</code> 文件中添加以下行，以使系统在启动时自动挂载逻辑卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/ls-vg/ls-lv  /ls  ext4  defaults  0  0</span><br></pre></td></tr></table></figure><p>10.确保挂载成功后，使用命令 <code>df -h</code> 检查挂载情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ！！！这里因为创建磁盘时只床建了一个导致内存不够，加盘后反而不能开机，在网上搜索后发现是新添加的磁盘空间没有分配，系统识别不出来，导致不能开机。</span><br><span class="line">//所以空间没分配完尽量不要重启</span><br><span class="line">解决办法：直接添加新硬盘，添加后扫描分区：</span><br><span class="line">ls  /sys/class/scsi_host/</span><br><span class="line">for i in $(ls /sys/class/scsi_host/); do echo &quot;- - -&quot; &gt; /sys/class/scsi_host/$i/scan; done</span><br><span class="line">sudo pvcreate /dev/sdc</span><br><span class="line">sudo vgextend ls-vg /dev/sdc</span><br></pre></td></tr></table></figure><p>1.要将逻辑卷扩展到10GB，使用以下命令：</p><ul><li>首先，确认逻辑卷和文件系统的当前大小，使用命令 <code>sudo df -h /ls</code>。</li><li>然后，使用命令 <code>sudo lvextend -L +5G /dev/ls-vg/ls-lv</code> 将逻辑卷扩展为10GB。</li><li>最后，使用命令 <code>sudo resize2fs /dev/ls-vg/ls-lv</code> 来扩展文件系统以使用新的逻辑卷大小。</li></ul><ol><li>使用命令 <code>sudo df -h /ls</code> 再次检查挂载点的大小，确认扩容成功。</li></ol><h4 id="ok-你已经完成搭载及扩容啦"><a href="#ok-你已经完成搭载及扩容啦" class="headerlink" title="ok 你已经完成搭载及扩容啦!!"></a>ok 你已经完成搭载及扩容啦!!</h4>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>宏峰</title>
    <link href="http://1414116846.github.io/2023/10/25/%E5%AE%8F%E5%B3%B0/"/>
    <id>http://1414116846.github.io/2023/10/25/%E5%AE%8F%E5%B3%B0/</id>
    <published>2023-10-25T12:39:30.000Z</published>
    <updated>2023-11-01T10:43:32.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yum与rpm命令的使用以及参数含义"><a href="#yum与rpm命令的使用以及参数含义" class="headerlink" title="yum与rpm命令的使用以及参数含义"></a>yum与rpm命令的使用以及参数含义</h2><p><img src="file:///C:\Users\Dt\AppData\Roaming\Tencent\QQTempSys%W@GJ$ACOF(TYDYECOKVDYB.png" alt="img"><a href="https://blog.csdn.net/qq_62690755/article/details/134040987?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_62690755/article/details/134040987?spm=1001.2014.3001.5502</a></p><h2 id="chown-、chmod命令每一个参数的含义。"><a href="#chown-、chmod命令每一个参数的含义。" class="headerlink" title="chown 、chmod命令每一个参数的含义。"></a>chown 、chmod命令每一个参数的含义。</h2><p><img src="file:///C:\Users\Dt\AppData\Roaming\Tencent\QQTempSys%W@GJ$ACOF(TYDYECOKVDYB.png" alt="img"><a href="https://blog.csdn.net/qq_62690755/article/details/134041622?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_62690755/article/details/134041622?spm=1001.2014.3001.5502</a></p><h2 id="fdisk-partd硬盘分区命令-用法？"><a href="#fdisk-partd硬盘分区命令-用法？" class="headerlink" title="fdisk partd硬盘分区命令 用法？"></a>fdisk partd硬盘分区命令 用法？</h2><p><img src="file:///C:\Users\Dt\AppData\Roaming\Tencent\QQTempSys%W@GJ$ACOF(TYDYECOKVDYB.png" alt="img"><a href="https://blog.csdn.net/qq_62690755/article/details/134041622?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_62690755/article/details/134041622?spm=1001.2014.3001.5502</a></p>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
    <category term="优秀博客" scheme="http://1414116846.github.io/tags/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Redhat</title>
    <link href="http://1414116846.github.io/2023/10/25/redhat/"/>
    <id>http://1414116846.github.io/2023/10/25/redhat/</id>
    <published>2023-10-25T00:29:09.000Z</published>
    <updated>2023-10-30T10:49:23.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建redhat虚拟机"><a href="#创建redhat虚拟机" class="headerlink" title="创建redhat虚拟机"></a>创建redhat虚拟机</h2><h2 id="更换yum源"><a href="#更换yum源" class="headerlink" title="更换yum源"></a>更换yum源</h2><p><a href="https://blog.csdn.net/x781437692/article/details/112768356?spm=1001.2014.3001.5506%E3%80%81">Redhat更换yum源_redhat9换源_Softnothings的博客-CSDN博客</a></p><h2 id="安装-oracle"><a href="#安装-oracle" class="headerlink" title="安装 oracle"></a>安装 oracle</h2><p><a href="https://blog.csdn.net/qq_37382077/article/details/108461330">redhat7安装Oracle11g数据库全过程_redhat安装oracle11g-CSDN博客</a></p><h2 id="安装-hammerdb"><a href="#安装-hammerdb" class="headerlink" title="安装 hammerdb"></a>安装 hammerdb</h2><h2 id="安装swingbench"><a href="#安装swingbench" class="headerlink" title="安装swingbench"></a>安装swingbench</h2>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
    <category term="测试" scheme="http://1414116846.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>linux错误总结</title>
    <link href="http://1414116846.github.io/2023/10/14/linux%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://1414116846.github.io/2023/10/14/linux%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-14T01:49:07.000Z</published>
    <updated>2023-10-30T10:57:20.681Z</updated>
    
    <content type="html"><![CDATA[<p>Linux下安装Oracle11g，安装界面乱码问题解决方法：</p><p>解决安装时中文是”囗囗囗囗囗囗囗囗”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LANG=en-US</span><br></pre></td></tr></table></figure><h6 id="防火墙："><a href="#防火墙：" class="headerlink" title="防火墙："></a>防火墙：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:查看防火状态</span><br><span class="line"></span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line">service  iptables status</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:暂时关闭防火墙</span><br><span class="line"></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">service  iptables stop</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:永久关闭防火墙</span><br><span class="line"></span><br><span class="line">systemctl disable firewalld</span><br><span class="line"></span><br><span class="line">chkconfig iptables off</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>:重启防火墙</span><br><span class="line"></span><br><span class="line">systemctl enable firewalld</span><br><span class="line"></span><br><span class="line">service iptables restart  </span><br><span class="line"></span><br><span class="line"><span class="number">5</span>:永久关闭后重启</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂时还没有试过</span></span><br><span class="line"></span><br><span class="line">chkconfig iptables on　</span><br></pre></td></tr></table></figure><h2 id="Linux永久关闭防火墙-firewalld和sellinux设置"><a href="#Linux永久关闭防火墙-firewalld和sellinux设置" class="headerlink" title="Linux永久关闭防火墙 firewalld和sellinux设置"></a>Linux永久关闭防火墙 firewalld和sellinux设置</h2><p>必须设置 最好设置永久性若是暂时关闭 下次开启还要设置 所以建议永久性关闭<br>关闭 firewalld：<br>systemctl disable firewalld #永久关闭,即设置开机的时候不自动启动<br>关闭 selinux：<br>修改配置文件（永久关闭selinux可以使用vi命令打开&#x2F;etc&#x2F;sysconfig&#x2F;selinux 文件将SELINUX&#x3D;disable）</p>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
    <category term="测试" scheme="http://1414116846.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>英语</title>
    <link href="http://1414116846.github.io/2023/10/13/%E8%8B%B1%E8%AF%AD/"/>
    <id>http://1414116846.github.io/2023/10/13/%E8%8B%B1%E8%AF%AD/</id>
    <published>2023-10-13T01:49:07.000Z</published>
    <updated>2023-10-30T11:01:14.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bios-牵连"><a href="#bios-牵连" class="headerlink" title="bios 牵连"></a>bios 牵连</h1><h2 id="main-重要设置"><a href="#main-重要设置" class="headerlink" title="main 重要设置"></a>main 重要设置</h2><p>小结：在Main界面中，会展示一些硬件方面的详细信息，比如biso版本、主板的名称或者是处理器的信息，还有一级缓存等等。</p><p>另外，一些重要的设置，比如系统时间以及日期设置。</p><p>processor 处理器</p><p>settings 设置</p><p>system 系统</p><p>time 时间</p><p>date 日期</p><p>version 版本</p><p>product 产品</p><p>service 服务</p><p>tag 标签</p><p>type 类型</p><p>speed 速度</p><p>cpu id用户计算机信息</p><p>cache  缓存</p><p>L1 一级</p><p>fixed 固定</p><p>hdd 硬盘</p><p>sata 串口</p><p>odd 光盘</p><p>device 模式</p><p>esata device 设置串口模式</p><p>ac adapter type ac适配器类型</p><p>memory 内存</p><p>extended 扩展</p><h2 id="advanced-高级设置"><a href="#advanced-高级设置" class="headerlink" title="advanced 高级设置"></a>advanced 高级设置</h2><p>小结：主要针对主板硬件上的功能，比如虚拟化激活、集成网卡、USB相关的设置等等。都可以在这个页面直接设置。</p><p>如果要进行sata的设置，也是在这个页面进行的。</p><p>enabled 激活的</p><p>disabled 无效的</p><p>intelspeedstep 因特尔速度步长</p><p>Virtual Izat 1on虚拟化</p><p>Integrated NIC集成网卡</p><p>USB Emulat ion usb仿真</p><p>USB Powershare USB电源共享</p><p>USB Hake Support USB映醒支持</p><p>SATA Operat lon SATA操作</p><p>Adapter Harnings 造配器警告</p><p>Function Key Behav lor功能健行为</p><p>charger Behavior 充电器行为</p><p>Miscellaneous Devices 杂项设备设置</p><h2 id="security-安全设置"><a href="#security-安全设置" class="headerlink" title="security  安全设置"></a>security  安全设置</h2><p>小结：这个页面是和安全有关的，主要就是设置相关的密码，其中包括管理员密码、系统密码以及启动密码。</p><p>另外，你也可以看到密码的状态。</p><p>unkocked 解锁</p><p>not set未设置</p><p>enabied 启动</p><p>Unlock Setup status解锁设置状态</p><p>Admin Passuord Status管理员密码状态</p><p>System Password Status 系统密码状态</p><p>HDD Password Status硬盘密码状态</p><p>Set Admin Passuord 设置管理员密码</p><p>Set System Passuord设置系统密码</p><p>Password on Boot启动码</p><p>Computrace计算机想踪</p><h2 id="BOOT-启动引导设置"><a href="#BOOT-启动引导设置" class="headerlink" title="BOOT-启动引导设置"></a>BOOT-启动引导设置</h2><p>小结：这个启动引导的设置界面，可以说是我们在重装系统时，非常重要的一项设置。</p><p>我们在这个页面，设置U盘作为第一启动项，使得电脑在开机时能够读取U盘winpe系统，进入系统重装的页面。</p><p>以下这个显示界面就是已经将U盘设置第一启动项了，即1st Boot Priority。</p><p>Sot Boot Priority引导设置优先级<br>1st Boot Prlority 第一引导优先级<br>2nd Boot Prlority  第二引导优先级<br>3rd Boot Priority 第三引导优先级<br>4th Boot Prlority 第四引导优先级<br>Sth Boot Prlority 第五引导优先级<br>6th Boot Priority 第六引导优先级</p><p>fusB storage Deyice] USB储存设备<br>[Hard Drive]硬盘动<br>lolskette Dr Ive]软磁盘驱动器<br>[CD&#x2F;DVD&#x2F;CD-RH Drive] CD DVD光盘驱动器<br>LeSATAI扩展卡<br>[Netuork]网络</p><h2 id="Exit-退出设置"><a href="#Exit-退出设置" class="headerlink" title="Exit-退出设置"></a>Exit-退出设置</h2><p>小结：前面，所有的设置完成之后，可以在这个页面，你可以“保存更改或者重置”、或者“放弃更改或者重置”。</p><p>你也可以直接“恢复默认值”，此项设置会将你之前的其他相关设置全部清除，恢复最原始的状态。</p><p>Save Changes and Reset保存 改和重置<br>Discard Changes and Reset 放弃更改和重置<br>Restore Def aults天复 认值<br>DIscard Changes放弃更改<br>Save changes保存更改</p>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>linux常见命令</title>
    <link href="http://1414116846.github.io/2023/10/12/linux%20%E5%91%BD%E4%BB%A4/"/>
    <id>http://1414116846.github.io/2023/10/12/linux%20%E5%91%BD%E4%BB%A4/</id>
    <published>2023-10-12T12:45:25.154Z</published>
    <updated>2023-10-30T11:17:50.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-常用文件管理命令"><a href="#1-常用文件管理命令" class="headerlink" title="1.常用文件管理命令"></a>1.常用文件管理命令</h2><p>1.1 命令介绍<br>ㅤㅤ1. Ctrl c：取消命令，并且换行</p><p>ㅤㅤ2. Ctrl u：清空本行命令</p><p>ㅤㅤ3. tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p><p>ㅤㅤ4. ls：列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p><p>ㅤㅤㅤ●ㅤls -a：查看所有文件包括隐藏文件（以.开头的文件就是隐藏文件）</p><p>ㅤㅤㅤ●ㅤls -l：查看当前路径下文件的读、写、执行权限</p><p>ㅤㅤㅤ●ㅤls | wc -l：查看ls下有多少个文件</p><p>ㅤㅤ5. pwd：显示当前路径</p><p>ㅤㅤ6. cd XXX：进入XXX目录下，cd ..返回上层目录</p><p>ㅤㅤㅤ●ㅤ.：当前目录 ..：上级目录</p><p>ㅤㅤㅤ●ㅤ~：家目录，回回到路径&#x2F;home&#x2F;acs下</p><p>ㅤㅤㅤ●ㅤcd -：返回改变路径前的路径，比如当前在&#x2F;home&#x2F;acs&#x2F;homework然后cd** **&#x2F;这个时候就处于&#x2F;目录下，然后cd -就会回到改变路径前的路径也就是&#x2F;home&#x2F;acs&#x2F;homework</p><p>ㅤㅤ7. cp XXX YYY：将XXX文件复制成YYY，XXX和YYY可以是同一个路径，比如..&#x2F;dir_c&#x2F;a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p><p>ㅤㅤㅤ●ㅤcp XXX YYY -r将XXX目录（文件夹）复制到YYY下</p><p>ㅤㅤㅤ●ㅤ非当前路径重命名方法：cp a.txt ..&#x2F;b.txt</p><p>ㅤㅤ8. mkdir XXX：创建目录（文件夹）XXX</p><p>ㅤㅤㅤ●ㅤmkdir -p：-p：如果文件夹不存在，则创建</p><p>ㅤㅤ9. rm XXX：删除普通文件； rm XXX -r：删除文件夹</p><p>ㅤㅤㅤ●ㅤ支持正则表达式，删除所有.txt类型文件：rm *.txt</p><p>ㅤㅤㅤ●ㅤ删除所有文件（不包括文件夹）：rm *</p><p>ㅤㅤㅤ●ㅤ正则表达式删除所有文件夹：rm * -r即可</p><p>ㅤㅤ10. mv XXX YYY：将XXX文件移动到YYY下，和cp命令一样，XXX和YYY可以是同一个路径；重命名也是用这个命令</p><p>ㅤㅤㅤ●ㅤ非当前路径移动方法：mv a.txt ..&#x2F;b.txt</p><p>ㅤㅤ11. touch XXX：创建一个文件</p><p>ㅤㅤ12. cat XXX：展示文件XXX中的内容</p><p>ㅤㅤ13. 复制文本：windows&#x2F;Linux下：Ctrl + insert，Mac下：command + c</p><p>ㅤㅤ14. 粘贴文本：windows&#x2F;Linux下：Shift + insert，Mac下：command + v</p><p>ㅤㅤ15. history：查看历史输入指令</p><p>ㅤㅤ16. tree：以树形显示文件目录结构</p><h2 id="2-oracle命令"><a href="#2-oracle命令" class="headerlink" title="2.oracle命令"></a>2.oracle命令</h2><p><code>sqlplus / as sysdba</code>  使用管理员权限登录到操作系统中的Oracle安装用户。</p><p><code>conn / as sysdba;</code> 是Oracle数据库中的命令，用于使用sysdba权限连接到数据库。 <code>conn</code> 是connect的缩写，<code>/</code> 表示使用操作系统认证方式登录，<code>as sysdba</code> 表示以sysdba用户身份登录。这条命令通常在命令行或SQL*Plus工具中使用，以获得对数据库的管理员权限。</p><p><code>startup；</code> 启动数据库</p><p><code>shutdown immediate;</code> 关闭数据库</p><p><code>lsnrctl start</code> 启动监听</p><p><code>show user</code> 查看当前用户</p><p><code>conn scott/tiger</code> 连接用户名为scott密码为tiger的实例</p><p><code>shutdown transactional;</code>  事务完成后关闭数据库</p><p><code>select name from v$tempfile;</code> 获取临时表空间文件的名称。</p><p><code>select name from v$datafile;</code> 获取数据文件的名称。数据文件是用来存储表、索引和其他数据库对象的物理文件。</p><p><code>show parameter ***</code>查看参数</p>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>优秀博客推荐</title>
    <link href="http://1414116846.github.io/2023/10/12/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90/"/>
    <id>http://1414116846.github.io/2023/10/12/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90/</id>
    <published>2023-10-12T12:42:28.634Z</published>
    <updated>2023-11-01T10:41:25.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p><a href="https://www.jianshu.com/p/a2d298e26dcd">Hexo 最常用的几个命令 - 简书 (jianshu.com)</a></p><h3 id="plsql"><a href="#plsql" class="headerlink" title="plsql"></a>plsql</h3><p><a href="https://blog.csdn.net/weixin_42107750/article/details/101207802">【Linux】Linux下解锁Oracle的Scott用户-CSDN博客</a></p><h2 id="Oracle-临时表空间操作总结-TEMP"><a href="#Oracle-临时表空间操作总结-TEMP" class="headerlink" title="Oracle-临时表空间操作总结 TEMP_"></a>Oracle-临时表空间操作总结 TEMP_</h2><p><a href="https://blog.51cto.com/baoyw/6650484">Oracle-临时表空间操作总结 TEMP_小宝大人的技术博客_51CTO博客</a></p><h2 id="Centos-7-X根分区磁盘扩容（非LVM）"><a href="#Centos-7-X根分区磁盘扩容（非LVM）" class="headerlink" title="Centos 7.X根分区磁盘扩容（非LVM）"></a>Centos 7.X根分区磁盘扩容（非LVM）</h2><p><a href="https://cloud.tencent.com/developer/article/1839925">Centos 7.X根分区磁盘扩容（非LVM）-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h2 id="Linux-虚拟机中不重启的情况下加新硬盘及扩展根分区容量"><a href="#Linux-虚拟机中不重启的情况下加新硬盘及扩展根分区容量" class="headerlink" title="Linux 虚拟机中不重启的情况下加新硬盘及扩展根分区容量"></a>Linux 虚拟机中不重启的情况下加新硬盘及扩展根分区容量</h2><p><a href="https://www.cnblogs.com/xiongzaiqiren/p/12627841.html">Linux 虚拟机中不重启的情况下加新硬盘及扩展根分区容量 </a></p>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
    <category term="优秀博客" scheme="http://1414116846.github.io/tags/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>pythoncincout.md</title>
    <link href="http://1414116846.github.io/2023/09/24/python%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://1414116846.github.io/2023/09/24/python%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2023-09-24T07:41:35.000Z</published>
    <updated>2023-10-30T10:59:32.429Z</updated>
    
    <content type="html"><![CDATA[<p>确保您已经安装了<code>pandas</code>和<code>openpyxl</code>库（如果您的Python版本是3.8以下），然后按照下面的步骤进行操作：</p><ol><li>创建并输入样本数据到TXT文件（sample.txt）：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="comment"># 打开文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># 写入数据</span></span><br><span class="line">    file.write(<span class="string">&quot;Hello, World!\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;This is a sample text file.\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;It contains multiple lines of text.&quot;</span>)</span><br></pre></td></tr></table></figure><ol><li>创建并输入样本数据到CSV文件（sample.csv）：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Gender&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;John&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;Male&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;Alice&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;Female&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;Male&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件并写入数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerows(data)</span><br></pre></td></tr></table></figure><ol><li>创建并输入样本数据到Excel文件（sample.xlsx）：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">28</span>],</span><br><span class="line">    <span class="string">&#x27;Gender&#x27;</span>: [<span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;Female&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将DataFrame写入Excel文件</span></span><br><span class="line">df.to_excel(<span class="string">&#x27;sample.xlsx&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ol><li>使用Python读取这三种文件：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取TXT文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    txt_data = file.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">csv_data = pd.read_csv(<span class="string">&#x27;sample.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取Excel文件</span></span><br><span class="line">excel_data = pd.read_excel(<span class="string">&#x27;sample.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;TXT 文件内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(txt_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nCSV 文件内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(csv_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nExcel 文件内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(excel_data)</span><br></pre></td></tr></table></figure><p>这样，您就可以创建并输入样本数据到TXT、CSV和Excel文件，并使用Python读取这三种文件了。请注意，这些示例代码假设您当前的工作目录中已经有了相应的文件。如果不是，请确保将文件路径调整为正确的位置。</p>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>图论模板</title>
    <link href="http://1414116846.github.io/2023/09/24/qsq%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/"/>
    <id>http://1414116846.github.io/2023/09/24/qsq%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/</id>
    <published>2023-09-24T07:41:35.000Z</published>
    <updated>2023-10-30T11:02:15.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="300-拓扑排序"><a href="#300-拓扑排序" class="headerlink" title="300 拓扑排序"></a><a href="https://www.cnblogs.com/dx123/p/16320427.html">300 拓扑排序</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////Kahn 算法  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N], tp;</span><br><span class="line"><span class="type">int</span> din[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span>(din[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> x=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    tp.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : e[x])&#123;</span><br><span class="line">      <span class="keyword">if</span>(--din[y]==<span class="number">0</span>) q.<span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tp.<span class="built_in">size</span>() == n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    din[b]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">toposort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">auto</span> x:tp)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////DFS 算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N], tp;</span><br><span class="line"><span class="type">int</span> c[N]; <span class="comment">//染色数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  c[x] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[y]&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//有环 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!c[y])</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">dfs</span>(y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  c[x] = <span class="number">1</span>;</span><br><span class="line">  tp.<span class="built_in">push_back</span>(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">    <span class="keyword">if</span>(!c[x])</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">dfs</span>(x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">reverse</span>(tp.<span class="built_in">begin</span>(),tp.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">toposort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x:tp)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓扑序"><a href="#拓扑序" class="headerlink" title="拓扑序"></a>拓扑序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=cnt;x;x--)&#123;</span><br><span class="line">   <span class="keyword">if</span>(dp[x]==<span class="number">0</span>) <span class="comment">//若x为路的起点</span></span><br><span class="line">     dp[x]=nw[x];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> y : ne[x])</span><br><span class="line">     dp[y]=<span class="built_in">max</span>(dp[y],dp[x]+nw[y]);</span><br><span class="line"> &#125; <span class="comment">//在拓扑图上逆序dp</span></span><br></pre></td></tr></table></figure><h1 id="301-最短路-Dijkstra-算法"><a href="#301-最短路-Dijkstra-算法" class="headerlink" title="301 最短路 Dijkstra 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320431.html">301 最短路 Dijkstra 算法</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define inf 2147483647</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">int n,m,s,a,b,c;</span><br><span class="line">struct edge&#123;int v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">int d[N], vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">  for(int i=0;i&lt;=n;i++) d[i]=inf;</span><br><span class="line">  d[s]=0; q.push(&#123;0,s&#125;);</span><br><span class="line">  while(q.size())&#123;</span><br><span class="line">    auto t=q.top(); q.pop();</span><br><span class="line">    int u=t.second;</span><br><span class="line">    if(vis[u])continue;//再出队跳过</span><br><span class="line">    vis[u]=1;//标记u已出队</span><br><span class="line">    for(auto ed : e[u])&#123;</span><br><span class="line">      int v=ed.v, w=ed.w;</span><br><span class="line">      if(d[v]&gt;d[u]+w)&#123;</span><br><span class="line">        d[v]=d[u]+w;</span><br><span class="line">        q.push(&#123;-d[v],v&#125;);//大根堆</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">  for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    e[a].push_back(&#123;b,c&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  dijkstra(s);</span><br><span class="line">  for(int i=1;i&lt;=n;i++)</span><br><span class="line">    printf(&quot;%d &quot;,d[i]); </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;LL v,c,ne;&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="comment">//e[i].b  出边</span></span><br><span class="line">    <span class="comment">//e[i].c  边权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大根堆重构"><a href="#大根堆重构" class="headerlink" title="大根堆重构"></a>大根堆重构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node&amp; a, <span class="type">const</span> Node&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value &lt; b.value; <span class="comment">//将value的值由大到小排列，形成Node的大根堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="302-最短路-Bellman-Ford-算法-spfa-算法-判负环"><a href="#302-最短路-Bellman-Ford-算法-spfa-算法-判负环" class="headerlink" title="302 最短路 Bellman-Ford 算法 spfa 算法 判负环"></a><a href="https://www.cnblogs.com/dx123/p/16320435.html">302 最短路 Bellman-Ford 算法 spfa 算法 判负环</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//Ford 判负环 740ms</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const int N=2010,M=6010;</span><br><span class="line">int n,m;</span><br><span class="line">int to[M],ne[M],w[M],h[N],tot;</span><br><span class="line">int d[N];</span><br><span class="line"></span><br><span class="line">void add(int a,int b,int c)&#123;</span><br><span class="line">  to[++tot]=b;w[tot]=c;</span><br><span class="line">  ne[tot]=h[a];h[a]=tot;</span><br><span class="line">&#125;</span><br><span class="line">bool ford()&#123;</span><br><span class="line">  memset(d,inf,sizeof d); d[1]=0;</span><br><span class="line">  bool flag; //是否松弛</span><br><span class="line">  for(int i=1;i&lt;=n;i++)&#123; //跑n轮</span><br><span class="line">    flag=false;</span><br><span class="line">    for(int u=1;u&lt;=n;u++)&#123; //n个点</span><br><span class="line">      if(d[u]==inf)continue;</span><br><span class="line">      for(int j=h[u];j;j=ne[j])&#123;</span><br><span class="line">        int v=to[j];</span><br><span class="line">        if(d[v]&gt;d[u]+w[j])&#123;</span><br><span class="line">          d[v]=d[u]+w[j];</span><br><span class="line">          flag=true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)break;</span><br><span class="line">  &#125;</span><br><span class="line">  return flag; //第n轮=true,有负环</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  int T;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">  while(T--)&#123;</span><br><span class="line">    tot=0; memset(h,0,sizeof(h));</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">      int u,v,w;</span><br><span class="line">      scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      add(u,v,w);</span><br><span class="line">      if(w&gt;=0)add(v,u,w);;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(ford()?&quot;YES&quot;:&quot;NO&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="303-最短路-Floyd-算法"><a href="#303-最短路-Floyd-算法" class="headerlink" title="303 最短路 Floyd 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320442.html">303 最短路 Floyd 算法</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=210,M=20010;</span><br><span class="line">int n,m,a,b,c;</span><br><span class="line">int d[N][N];</span><br><span class="line"></span><br><span class="line">void floyd()&#123;</span><br><span class="line">  for(int k=1; k&lt;=n; k++)</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">      for(int j=1; j&lt;=n; j++)</span><br><span class="line">        d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  memset(d,0x3f,sizeof d);</span><br><span class="line">  for(int i=1; i&lt;=n; i++)d[i][i]=0;</span><br><span class="line">  for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    d[a][b]=min(d[a][b],c); //重边</span><br><span class="line">  &#125;</span><br><span class="line">  floyd();</span><br><span class="line">  for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    for(int j=1;j&lt;=n;j++) </span><br><span class="line">      printf(&quot;%d &quot;,d[i][j]);</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="304-最短路-Johnson-算法"><a href="#304-最短路-Johnson-算法" class="headerlink" title="304 最短路 Johnson 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320444.html">304 最短路 Johnson 算法</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5905 【模板】Johnson 全源最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 30010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a,b,c;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> vis[N],cnt[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> h[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">63</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    h[<span class="number">0</span>]=<span class="number">0</span>,vis[<span class="number">0</span>]=<span class="number">1</span>;q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed : e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v=ed.v,w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(h[v]&gt;h[u]+w)&#123;</span><br><span class="line">                h[v]=h[u]+w;</span><br><span class="line">        cnt[v]=cnt[u]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[v]&gt;n)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)d[i]=INF;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    d[s]=<span class="number">0</span>; q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">top</span>().second;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed : e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v=ed.v,w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+w)&#123;</span><br><span class="line">                d[v]=d[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(&#123;-d[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c, e[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      e[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;i,<span class="number">0</span>&#125;);<span class="comment">//加虚拟边</span></span><br><span class="line">      </span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ed:e[u])</span><br><span class="line">        ed.w+=h[u]-h[ed.v];<span class="comment">//构造新边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">dijkstra</span>(i);<span class="comment">//i次循环</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j]==INF) ans+=(<span class="type">long</span> <span class="type">long</span>)j*INF;</span><br><span class="line">            <span class="keyword">else</span> ans+=(<span class="type">long</span> <span class="type">long</span>)j*(d[j]+h[j]-h[i]);<span class="comment">//(d[j]+h[j]-h[i])为i到j的边权</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="305-最小环"><a href="#305-最小环" class="headerlink" title="305 最小环"></a><a href="https://www.cnblogs.com/dx123/p/16320450.html">305 最小环</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=110;</span><br><span class="line">int n,m,a,b,c,ans=1e8;</span><br><span class="line">int w[N][N],d[N][N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  for(int i=1;i&lt;=n;i++)</span><br><span class="line">    for(int j=1;j&lt;=n;j++)</span><br><span class="line">      if(i!=j) w[i][j]=1e8;</span><br><span class="line">  for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    w[a][b]=w[b][a]=c;</span><br><span class="line">  &#125;</span><br><span class="line">  memcpy(d,w,sizeof d);</span><br><span class="line">  </span><br><span class="line">  for(int k=1; k&lt;=n; k++)&#123;</span><br><span class="line">    for(int i=1; i&lt;k; i++)</span><br><span class="line">      for(int j=i+1; j&lt;k; j++)</span><br><span class="line">        ans=min(ans,d[i][j]+w[j][k]+w[k][i]);</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">      for(int j=1; j&lt;=n; j++)</span><br><span class="line">        d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  if(ans==1e8) puts(&quot;No solution.&quot;);</span><br><span class="line">  else printf(&quot;%d\n&quot;,ans);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="311-最小生成树-Prim-算法"><a href="#311-最小生成树-Prim-算法" class="headerlink" title="311 最小生成树 Prim 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320452.html">311 最小生成树 Prim 算法</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define inf 1e9</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=5010;</span><br><span class="line">int n,m,a,b,c,ans,cnt;</span><br><span class="line">struct edge&#123;int v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">int d[N], vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">bool prim(int s)&#123;</span><br><span class="line">  for(int i=0;i&lt;=n;i++) d[i]=inf;</span><br><span class="line">  d[s]=0; q.push(&#123;0,s&#125;);</span><br><span class="line">  while(q.size())&#123;</span><br><span class="line">    int u=q.top().second; q.pop();</span><br><span class="line">    if(vis[u])continue;//再出队跳过</span><br><span class="line">    vis[u]=1;//标记u已出队</span><br><span class="line">    ans+=d[u]; cnt++;</span><br><span class="line">    for(auto ed : e[u])&#123;</span><br><span class="line">      int v=ed.v, w=ed.w;</span><br><span class="line">      if(d[v]&gt;w)&#123;</span><br><span class="line">        d[v]=w;</span><br><span class="line">        q.push(&#123;-d[v],v&#125;);//大根堆</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cnt==n;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    e[a].push_back(&#123;b,c&#125;);</span><br><span class="line">    e[b].push_back(&#123;a,c&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  if(!prim(1))puts(&quot;orz&quot;);</span><br><span class="line">  else printf(&quot;%d\n&quot;,ans); </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="321-最近公共祖先-倍增算法"><a href="#321-最近公共祖先-倍增算法" class="headerlink" title="321 最近公共祖先 倍增算法"></a><a href="https://www.cnblogs.com/dx123/p/16320461.html">321 最近公共祖先 倍增算法</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>; </span><br><span class="line"><span class="type">int</span> n,m,s,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dep[N],fa[N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">  fa[u][<span class="number">0</span>]=f;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">19</span>; i++) </span><br><span class="line">    fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : e[u])</span><br><span class="line">    <span class="keyword">if</span>(v!=f) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u, v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>; ~i; i--)</span><br><span class="line">    <span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v])</span><br><span class="line">      u=fa[u][i];</span><br><span class="line">  <span class="keyword">if</span>(u==v) <span class="keyword">return</span> v;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>; ~i; i--)</span><br><span class="line">    <span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">      u=fa[u][i], v=fa[v][i];</span><br><span class="line">  <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n,&amp;m,&amp;s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lca</span>(a, b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用dfs建立深度，最大子树，节点总值，数组"><a href="#利用dfs建立深度，最大子树，节点总值，数组" class="headerlink" title="利用dfs建立深度，最大子树，节点总值，数组"></a>利用dfs建立深度，最大子树，节点总值，数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mina[x] = a[x];<span class="comment">//最小子树</span></span><br><span class="line">cnt[x] = <span class="number">1</span>;<span class="comment">//子节点个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> tx : e[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(tx == fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">dep[tx] = dep[x] + <span class="number">1</span>;<span class="comment">//深度</span></span><br><span class="line">f[tx][<span class="number">0</span>] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">f[tx][i] = f[f[tx][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(tx, x);</span><br><span class="line">mina[x] = <span class="built_in">min</span>(mina[x], mina[tx]);</span><br><span class="line">cnt[x] += cnt[tx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="322-最近公共祖先-Tarjan算法"><a href="#322-最近公共祖先-Tarjan算法" class="headerlink" title="322 最近公共祖先 Tarjan算法"></a><a href="https://www.cnblogs.com/dx123/p/16320465.html">322 最近公共祖先 Tarjan算法</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=500005,M=2*N;</span><br><span class="line">int n,m,s,a,b;</span><br><span class="line">vector&lt;int&gt; e[N];</span><br><span class="line">vector&lt;pair&lt;int,int&gt;&gt;query[N];</span><br><span class="line">int fa[N],vis[N],ans[M]; </span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">  if(x==fa[x]) return x;</span><br><span class="line">  return fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void tarjan(int x)&#123;</span><br><span class="line">  vis[x]=true;//标记x已访问</span><br><span class="line">  for(auto y : e[x])&#123;</span><br><span class="line">    if(!vis[y])&#123;</span><br><span class="line">      tarjan(y);</span><br><span class="line">      fa[y]=x;//回到x时指向x</span><br><span class="line">    &#125;        </span><br><span class="line">  &#125;</span><br><span class="line">  //离开x时找LCA</span><br><span class="line">  for(auto q : query[x])&#123;</span><br><span class="line">    int y=q.first,i=q.second;</span><br><span class="line">    if(vis[y])ans[i]=find(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  scanf(&quot;%d%d%d&quot;, &amp;n,&amp;m,&amp;s);</span><br><span class="line">  for(int i=1; i&lt;n; i++)&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    e[a].push_back(b);</span><br><span class="line">    e[b].push_back(a);</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    query[a].push_back(&#123;b,i&#125;);</span><br><span class="line">    query[b].push_back(&#123;a,i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for(int i=1;i&lt;=N;i++)fa[i]=i;</span><br><span class="line">  tarjan(s);</span><br><span class="line">  for(int i=1; i&lt;=m; i++)</span><br><span class="line">    printf(&quot;%d\n&quot;,ans[i]);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="323-最近公共祖先-树链剖分"><a href="#323-最近公共祖先-树链剖分" class="headerlink" title="323 最近公共祖先 树链剖分"></a><a href="https://www.cnblogs.com/dx123/p/16320467.html">323 最近公共祖先 树链剖分</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P3379 【模板】最近公共祖先（LCA）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N],son[N],dep[N],sz[N];</span><br><span class="line"><span class="type">int</span> top[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123; <span class="comment">//搞fa,dep,son</span></span><br><span class="line">  fa[u]=father,dep[u]=dep[father]+<span class="number">1</span>,sz[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==father) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">    sz[u]+=sz[v];</span><br><span class="line">    <span class="keyword">if</span>(sz[son[u]]&lt;sz[v])son[u]=v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123; <span class="comment">//搞top</span></span><br><span class="line">  top[u]=t; <span class="comment">//记录链头</span></span><br><span class="line">  <span class="comment">// printf(&quot;top[%d]=%d\n&quot;,u,t);</span></span><br><span class="line">  <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;<span class="comment">//无重儿子返回</span></span><br><span class="line">  <span class="built_in">dfs2</span>(son[u],t); <span class="comment">//搜重儿子</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==son[u])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(v,v); <span class="comment">//搜轻儿子</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    u=fa[top[u]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dep[u]&lt;dep[v]?u:v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(s,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(s,s);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lca</span>(a,b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="324-树上修改与查询-树链剖分"><a href="#324-树上修改与查询-树链剖分" class="headerlink" title="324 树上修改与查询 树链剖分"></a><a href="https://www.cnblogs.com/dx123/p/16320469.html">324 树上修改与查询 树链剖分</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Luogu P3384 【模板】轻重链剖分/树链剖分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc u&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,root,p;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N],dep[N],sz[N],son[N];</span><br><span class="line"><span class="type">int</span> top[N],id[N],nw[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;<span class="comment">//搞fa,dep,sz,son</span></span><br><span class="line">  fa[u]=father,dep[u]=dep[father]+<span class="number">1</span>,sz[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==father) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">    sz[u]+=sz[v];</span><br><span class="line">    <span class="keyword">if</span>(sz[son[u]]&lt;sz[v]) son[u]=v; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;<span class="comment">//搞top,id,nw</span></span><br><span class="line">  top[u]=t,id[u]=++cnt,nw[cnt]=w[u];</span><br><span class="line">  <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[u],t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==son[u])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">  <span class="type">int</span> l,r; </span><br><span class="line">  LL add,sum;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>]; <span class="comment">//线段树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  tr[u].sum=tr[lc].sum+tr[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tr[u].add)&#123;</span><br><span class="line">    tr[lc].sum+=tr[u].add*(tr[lc].r-tr[lc].l+<span class="number">1</span>);</span><br><span class="line">    tr[rc].sum+=tr[u].add*(tr[rc].r-tr[rc].l+<span class="number">1</span>);</span><br><span class="line">    tr[lc].add+=tr[u].add;</span><br><span class="line">    tr[rc].add+=tr[u].add;</span><br><span class="line">    tr[u].add=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  tr[u]=&#123;l,r,<span class="number">0</span>,nw[r]&#125;;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(lc,l,mid),<span class="built_in">build</span>(rc,mid+<span class="number">1</span>,r);</span><br><span class="line">  <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r)&#123;</span><br><span class="line">    tr[u].add+=k;</span><br><span class="line">    tr[u].sum+=k*(tr[u].r-tr[u].l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(u);</span><br><span class="line">  <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(lc,l,r,k);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(rc,l,r,k);</span><br><span class="line">  <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_path</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>,id[top[u]],id[u],k);</span><br><span class="line">    u=fa[top[u]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>,id[v],id[u],k);<span class="comment">//最后一段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tree</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>,id[u],id[u]+sz[u]<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r)<span class="keyword">return</span> tr[u].sum;</span><br><span class="line">  <span class="built_in">pushdown</span>(u);</span><br><span class="line">  <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  LL res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">query</span>(lc,l,r);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">query</span>(rc,l,r);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query_path</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  LL res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    res+=<span class="built_in">query</span>(<span class="number">1</span>,id[top[u]],id[u]);</span><br><span class="line">    u=fa[top[u]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">  res+=<span class="built_in">query</span>(<span class="number">1</span>,id[v],id[u]);<span class="comment">//最后一段</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query_tree</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,id[u],id[u]+sz[u]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root,&amp;p);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(root,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(root,root);<span class="comment">//把树拆成链</span></span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n); <span class="comment">//用链建线段树</span></span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> t,u,v,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t,&amp;u);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v,&amp;k);</span><br><span class="line">      <span class="built_in">update_path</span>(u,v,k);<span class="comment">//表示将树从 xx 到 yy 结点最短路径上所有节点的值都加上 zz。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">      <span class="built_in">update_tree</span>(u,k);<span class="comment">//表示求树从 xx 到 yy 结点最短路径上所有节点的值之和。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_path</span>(u,v)%p);<span class="comment">//表示求树从 xx 到 yy 结点最短路径上所有节点的值之和。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_tree</span>(u)%p);<span class="comment">//表示求以 xx 为根节点的子树内所有节点值之和</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="341-强连通分量-Tarjan-算法"><a href="#341-强连通分量-Tarjan-算法" class="headerlink" title="341 强连通分量 Tarjan 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320476.html">341 强连通分量 Tarjan 算法</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],instk[N],top;</span><br><span class="line"><span class="type">int</span> scc[N],siz[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="comment">//入x时，盖戳、入栈</span></span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  stk[++top]=x,instk[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]);<span class="comment">//回x时更新low</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(instk[y])<span class="comment">//若y已访问且在栈中</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);<span class="comment">//在x时更新low</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//离x时，收集SCC</span></span><br><span class="line">  <span class="keyword">if</span>(dfn[x]==low[x])&#123;<span class="comment">//若x是SCC的根</span></span><br><span class="line">    <span class="type">int</span> y; ++cnt;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      y=stk[top--];</span><br><span class="line">      instk[y]=<span class="number">0</span>;</span><br><span class="line">      scc[y]=cnt;<span class="comment">//SCC编号</span></span><br><span class="line">      ++siz[cnt];<span class="comment">//SCC大小</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b, e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//可能不连通</span></span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">   <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">     <span class="keyword">if</span>(siz[i]&gt;<span class="number">1</span>) ans++;</span><br><span class="line">   cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="342-Tarjan-缩点"><a href="#342-Tarjan-缩点" class="headerlink" title="342 Tarjan 缩点"></a><a href="https://www.cnblogs.com/dx123/p/16320478.html">342 Tarjan 缩点</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],instk[N],top;</span><br><span class="line"><span class="type">int</span> scc[N],cnt;</span><br><span class="line"><span class="type">int</span> din[N],dout[N];<span class="comment">//SCC的入度,出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot; </span><br><span class="line">  stk[++top]=x,instk[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);<span class="comment">////</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(instk[y])<span class="comment">//若y已访问且在栈中</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dfn[x]==low[x])&#123;<span class="comment">//若x是SCC的根</span></span><br><span class="line">    <span class="type">int</span> y;++cnt;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      y=stk[top--];</span><br><span class="line">      instk[y]=<span class="number">0</span>;</span><br><span class="line">      scc[y]=cnt; <span class="comment">//y属于哪个SCC</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, a; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a, a) </span><br><span class="line">      e[i].<span class="built_in">push_back</span>(a);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y : e[x])</span><br><span class="line">      <span class="keyword">if</span>(scc[x]!=scc[y])&#123;</span><br><span class="line">        din[scc[y]]++;</span><br><span class="line">        dout[scc[x]]++;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="type">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!din[i]) a++;</span><br><span class="line">    <span class="keyword">if</span>(!dout[i]) b++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">  <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(a,b));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="343-Tarjan-割点"><a href="#343-Tarjan-割点" class="headerlink" title="343 Tarjan 割点"></a><a href="https://www.cnblogs.com/dx123/p/16320481.html">343 Tarjan 割点</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3388 【模板】割点</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  <span class="type">int</span> child=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]); </span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">        child++;<span class="comment">//子树个数</span></span><br><span class="line">        <span class="keyword">if</span>(x!=root||child&gt;<span class="number">1</span>)</span><br><span class="line">          cut[x]=<span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//若y已经访问</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b),</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(root=<span class="number">1</span>; root&lt;=n; root++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[root])<span class="built_in">tarjan</span>(root);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(cut[i]) ans++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(cut[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="344-Tarjan-割边"><a href="#344-Tarjan-割边" class="headerlink" title="344 Tarjan 割边"></a><a href="https://www.cnblogs.com/dx123/p/16320483.html">344 Tarjan 割边</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v;&#125;;</span><br><span class="line">vector&lt;edge&gt;e;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;h[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bridge</span>&#123;</span><br><span class="line">  <span class="type">int</span> x,y;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> bridge &amp;t)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t.x)<span class="keyword">return</span> y&lt;t.y;</span><br><span class="line">    <span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;bri[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e.<span class="built_in">push_back</span>(&#123;a,b&#125;);</span><br><span class="line">  h[a].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> in_edge)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=h[x][i], y=e[j].v;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y,j);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;dfn[x])&#123;</span><br><span class="line">        bri[cnt++]=&#123;x,y&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j!=(in_edge^<span class="number">1</span>))<span class="comment">//不是反边</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(bri,bri+cnt);  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,bri[i].x,bri[i].y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="345-Tarjan-eDCC-缩点"><a href="#345-Tarjan-eDCC-缩点" class="headerlink" title="345 Tarjan eDCC 缩点"></a><a href="https://www.cnblogs.com/dx123/p/16320488.html">345 Tarjan eDCC 缩点</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ 3177 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>;<span class="comment">//2,3开始配对</span></span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">int</span> dcc[N],cnt;</span><br><span class="line"><span class="type">int</span> bri[M],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx].v=b; e[idx].ne=h[a];</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> in_edg)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  stk.<span class="built_in">push</span>(x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> y=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y,i);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;dfn[x])</span><br><span class="line">        bri[i]=bri[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i!=(in_edg^<span class="number">1</span>))<span class="comment">//不是反边</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">int</span> y=stk.<span class="built_in">top</span>();stk.<span class="built_in">pop</span>();</span><br><span class="line">      dcc[y]=cnt;<span class="comment">//记录eDCC</span></span><br><span class="line">      <span class="keyword">if</span>(y==x)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=idx;i++)</span><br><span class="line">    <span class="keyword">if</span>(bri[i])</span><br><span class="line">      d[dcc[e[i].v]]++;<span class="comment">//度数</span></span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    <span class="keyword">if</span>(d[i]==<span class="number">1</span>) sum++;<span class="comment">//叶节点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(sum+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="346-Tarjan-vDCC-缩点"><a href="#346-Tarjan-vDCC-缩点" class="headerlink" title="346 Tarjan vDCC 缩点"></a><a href="https://www.cnblogs.com/dx123/p/16320490.html">346 Tarjan vDCC 缩点</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N],ne[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],top;</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N];</span><br><span class="line"><span class="type">int</span> root,cnt,num,id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  stk[++top]=x;</span><br><span class="line">  <span class="keyword">if</span>(x==root&amp;&amp;!e[x].<span class="built_in">size</span>())&#123;<span class="comment">//孤立点</span></span><br><span class="line">    dcc[++cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> child=<span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);<span class="comment">////</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]); </span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">        child++;</span><br><span class="line">        <span class="keyword">if</span>(x!=root||child&gt;<span class="number">1</span>)</span><br><span class="line">          cut[x]=<span class="literal">true</span>; </span><br><span class="line">        <span class="type">int</span> z; cnt++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vDCC:&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123; <span class="comment">//记录vDCC</span></span><br><span class="line">          z=stk[top--];</span><br><span class="line">          dcc[cnt].<span class="built_in">push_back</span>(z);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,z);</span><br><span class="line">        &#125;<span class="keyword">while</span>(z!=y);</span><br><span class="line">        dcc[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//若y已经访问</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b),</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(root=<span class="number">1</span>;root&lt;=n;root++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[root])</span><br><span class="line">      <span class="built_in">tarjan</span>(root);</span><br><span class="line">      </span><br><span class="line">  <span class="comment">//给每个割点一个新编号（cnt+1开始）</span></span><br><span class="line">  num=cnt;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(cut[i])id[i]=++num;</span><br><span class="line">  <span class="comment">//建新图，从每个vDCC向对应割点连边</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dcc[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">      <span class="type">int</span> x=dcc[i][j];</span><br><span class="line">      <span class="keyword">if</span>(cut[x])&#123;</span><br><span class="line">        ne[i].<span class="built_in">push_back</span>(id[x]),</span><br><span class="line">        ne[id[x]].<span class="built_in">push_back</span>(i);        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="361-网络流-最大流-EK-算法"><a href="#361-网络流-最大流-EK-算法" class="headerlink" title="361 网络流 最大流 EK 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320492.html">361 网络流 最大流 EK 算法</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3376 【模板】网络最大流</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;LL v,c,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>;<span class="comment">//从2,3开始配对</span></span><br><span class="line">LL mf[N],pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//找增广路</span></span><br><span class="line">  <span class="built_in">memset</span>(mf,<span class="number">0</span>,<span class="keyword">sizeof</span> mf);</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(S); mf[S]=<span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">      LL v=e[i].v;</span><br><span class="line">      <span class="keyword">if</span>(mf[v]==<span class="number">0</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">        mf[v]=<span class="built_in">min</span>(mf[u],e[i].c);</span><br><span class="line">        pre[v]=i;<span class="comment">//存前驱边</span></span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(v==T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">EK</span><span class="params">()</span></span>&#123;<span class="comment">//累加可行流</span></span><br><span class="line">  LL flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">    <span class="type">int</span> v=T;</span><br><span class="line">    <span class="keyword">while</span>(v!=S)&#123;<span class="comment">//更新残留网</span></span><br><span class="line">      <span class="type">int</span> i=pre[v];</span><br><span class="line">      e[i].c-=mf[T];</span><br><span class="line">      e[i^<span class="number">1</span>].c+=mf[T];</span><br><span class="line">      v=e[i^<span class="number">1</span>].v;</span><br><span class="line">    &#125;</span><br><span class="line">    flow+=mf[T];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">add</span>(a,b,c); </span><br><span class="line">    <span class="built_in">add</span>(b,a,<span class="number">0</span>);<span class="comment">//反向边</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">EK</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="362-网络流-最大流-Dinic-算法"><a href="#362-网络流-最大流-Dinic-算法" class="headerlink" title="362 网络流 最大流 Dinic 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320495.html">362 网络流 最大流 Dinic 算法</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;LL v,c,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>; <span class="comment">//从2,3开始配对</span></span><br><span class="line"><span class="type">int</span> d[N],cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123; <span class="comment">//对点分层，找增广路</span></span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt;q; </span><br><span class="line">  q.<span class="built_in">push</span>(S); d[S]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">      <span class="type">int</span> v=e[i].v;</span><br><span class="line">      <span class="keyword">if</span>(d[v]==<span class="number">0</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">        d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(v==T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, LL mf)</span></span>&#123; <span class="comment">//多路增广</span></span><br><span class="line">  <span class="keyword">if</span>(u==T) <span class="keyword">return</span> mf;</span><br><span class="line">  LL sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].ne)&#123;</span><br><span class="line">    cur[u]=i; <span class="comment">//当前弧优化</span></span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(d[v]==d[u]+<span class="number">1</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">      LL f=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(mf,e[i].c));</span><br><span class="line">      e[i].c-=f; </span><br><span class="line">      e[i^<span class="number">1</span>].c+=f; <span class="comment">//更新残留网</span></span><br><span class="line">      sum+=f; <span class="comment">//累加u的流出流量</span></span><br><span class="line">      mf-=f;  <span class="comment">//减少u的剩余流量</span></span><br><span class="line">      <span class="keyword">if</span>(mf==<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//余量优化</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(sum==<span class="number">0</span>) d[u]=<span class="number">0</span>; <span class="comment">//残枝优化</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dinic</span><span class="params">()</span></span>&#123; <span class="comment">//累加可行流</span></span><br><span class="line">  LL flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, h, <span class="keyword">sizeof</span> h);</span><br><span class="line">    flow+=<span class="built_in">dfs</span>(S,<span class="number">1e9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">  <span class="keyword">while</span>(m -- )&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">add</span>(a,b,c); <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">dinic</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="381-二分图判定-染色法"><a href="#381-二分图判定-染色法" class="headerlink" title="381 二分图判定 染色法"></a><a href="https://www.cnblogs.com/dx123/p/16418198.html">381 二分图判定 染色法</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  color[u]=c;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(!color[v])&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">dfs</span>(v,<span class="number">3</span>-c))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(color[v]==c)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//有奇环</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">add</span>(a,b); </span><br><span class="line">    <span class="built_in">add</span>(b,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!color[i])</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">dfs</span>(i,<span class="number">1</span>))&#123;</span><br><span class="line">        flag=<span class="number">1</span>;<span class="comment">//有奇环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="382-二分图最大匹配-匈牙利算法"><a href="#382-二分图最大匹配-匈牙利算法" class="headerlink" title="382 二分图最大匹配 匈牙利算法"></a><a href="https://www.cnblogs.com/dx123/p/16418297.html">382 二分图最大匹配 匈牙利算法</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Luogu P3386 【模板】二分图最大匹配</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,a,b,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> vis[N],match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v; <span class="comment">//妹子</span></span><br><span class="line">    <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[v]=<span class="number">1</span>; <span class="comment">//先标记这个妹子</span></span><br><span class="line">    <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">      match[v]=u; <span class="comment">//配成对</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b, <span class="built_in">add</span>(a,b);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="383-二分图最大匹配-Dinic算法"><a href="#383-二分图最大匹配-Dinic算法" class="headerlink" title="383 二分图最大匹配 Dinic算法"></a><a href="https://www.cnblogs.com/dx123/p/16419587.html">383 二分图最大匹配 Dinic算法</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 2000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k,S,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,c,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>; <span class="comment">//从2,3开始配对</span></span><br><span class="line"><span class="type">int</span> d[N],cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123; <span class="comment">//对点分层，找增广路</span></span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt;q; </span><br><span class="line">  q.<span class="built_in">push</span>(S); d[S]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">      <span class="type">int</span> v=e[i].v;</span><br><span class="line">      <span class="keyword">if</span>(d[v]==<span class="number">0</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">        d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(v==T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> mf)</span></span>&#123; <span class="comment">//多路增广</span></span><br><span class="line">  <span class="keyword">if</span>(u==T) <span class="keyword">return</span> mf;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].ne)&#123;</span><br><span class="line">    cur[u]=i; <span class="comment">//当前弧优化</span></span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(d[v]==d[u]+<span class="number">1</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">      <span class="type">int</span> f=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(mf,e[i].c));</span><br><span class="line">      e[i].c-=f; </span><br><span class="line">      e[i^<span class="number">1</span>].c+=f; <span class="comment">//更新残留网</span></span><br><span class="line">      sum+=f; <span class="comment">//累加u的流出流量</span></span><br><span class="line">      mf-=f;  <span class="comment">//减少u的剩余流量</span></span><br><span class="line">      <span class="keyword">if</span>(mf==<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//余量优化</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(sum==<span class="number">0</span>) d[u]=<span class="number">0</span>; <span class="comment">//残枝优化</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123; <span class="comment">//累加可行流</span></span><br><span class="line">  <span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, h, <span class="keyword">sizeof</span> h);</span><br><span class="line">    flow+=<span class="built_in">dfs</span>(S,<span class="number">1e9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">  <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">add</span>(a,b+n,<span class="number">1</span>);<span class="built_in">add</span>(b+n,a,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  S=<span class="number">0</span>;T=n+m+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">add</span>(S,i,<span class="number">1</span>),<span class="built_in">add</span>(i,S,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+n,T,<span class="number">1</span>),<span class="built_in">add</span>(T,i+n,<span class="number">0</span>); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">dinic</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="384-二分图最大权完美匹配-KM算法"><a href="#384-二分图最大权完美匹配-KM算法" class="headerlink" title="384 二分图最大权完美匹配 KM算法"></a><a href="https://www.cnblogs.com/dx123/p/16436807.html">384 二分图最大权完美匹配 KM算法</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e12</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> match[N];<span class="comment">//右点匹配了哪个左点</span></span><br><span class="line"><span class="type">int</span> va[N],vb[N];<span class="comment">//标记是否在交替路中</span></span><br><span class="line">LL la[N],lb[N];<span class="comment">//左顶标,右顶标</span></span><br><span class="line">LL w[N][N],d[N];<span class="comment">//维护更新的delta值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    va[x]=<span class="number">1</span>; <span class="comment">//x在交替路中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=n;y++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!vb[y])&#123;</span><br><span class="line">          <span class="keyword">if</span>(la[x]+lb[y]-w[x][y]==<span class="number">0</span>)&#123;<span class="comment">//相等子图</span></span><br><span class="line">              vb[y]=<span class="number">1</span>; <span class="comment">//y在交替路中</span></span><br><span class="line">              <span class="keyword">if</span>(!match[y]||<span class="built_in">dfs</span>(match[y]))&#123;</span><br><span class="line">                match[y]=x; <span class="comment">//配对</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//不是相等子图则记录最小的d[y]</span></span><br><span class="line">            d[y]=<span class="built_in">min</span>(d[y],la[x]+lb[y]-w[x][y]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">KM</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//左顶标取i的出边的最大边权</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) la[i]=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">          la[i]=<span class="built_in">max</span>(la[i],w[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lb[i]=<span class="number">0</span>;      </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;<span class="comment">//直到左点i找到匹配</span></span><br><span class="line">            <span class="built_in">fill</span>(va+<span class="number">1</span>,va+n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">fill</span>(vb+<span class="number">1</span>,vb+n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">fill</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>,INF);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i))<span class="keyword">break</span>;</span><br><span class="line">          LL delta=INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">              <span class="keyword">if</span>(!vb[j])delta=<span class="built_in">min</span>(delta,d[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//修改顶标</span></span><br><span class="line">              <span class="keyword">if</span>(va[j])la[j]-=delta;</span><br><span class="line">              <span class="keyword">if</span>(vb[j])lb[j]+=delta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)res+=w[match[i]][i];    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">          w[i][j]=-INF; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        w[x][y]=z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">KM</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,match[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="391-基环树-P2607-ZJOI2008-骑士"><a href="#391-基环树-P2607-ZJOI2008-骑士" class="headerlink" title="391 基环树 P2607 ZJOI2008] 骑士"></a>391 基环树 P2607 <a href="https://www.cnblogs.com/dx123/p/16464427.html">ZJOI2008] 骑士</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题意:每个骑士有一个不可以同时上场的骑士，和一个战斗力。求最大战斗力</span></span><br><span class="line"><span class="comment">//转化: n个点n条边，每个点有权值，有边相连的两个点只能选其一，求可选方案的最大的点权之和。</span></span><br><span class="line"><span class="comment">// Luogu P2607 [ZJOI2008] 骑士</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[N];</span><br><span class="line"><span class="type">int</span> h[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> r1,r2,vis[N];</span><br><span class="line">LL f[N][<span class="number">2</span>],sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//找两个根</span></span><br><span class="line">  vis[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==rt)&#123;r1=u,r2=v;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">find</span>(v,rt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//树上DP</span></span><br><span class="line">  f[u][<span class="number">0</span>]=<span class="number">0</span>; f[u][<span class="number">1</span>]=w[u];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==rt)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v,rt);</span><br><span class="line">    f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">    f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>,u;v&lt;=n;v++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[v],&amp;u);</span><br><span class="line">    <span class="built_in">add</span>(u,v);<span class="comment">//单向边</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">      r1=r2=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">find</span>(i,i);</span><br><span class="line">      <span class="keyword">if</span>(r1)&#123;</span><br><span class="line">        LL res1=<span class="built_in">dfs</span>(r1,r1);</span><br><span class="line">        LL res2=<span class="built_in">dfs</span>(r2,r2);</span><br><span class="line">        sum+=<span class="built_in">max</span>(res1,res2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2607 [ZJOI2008] 骑士</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> h[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> fa[N]; <span class="comment">//并查集的根数组</span></span><br><span class="line">LL f[N][<span class="number">2</span>],sum;</span><br><span class="line">vector&lt;PII&gt; roots;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;<span class="comment">//树上DP</span></span><br><span class="line">  f[u][<span class="number">0</span>]=<span class="number">0</span>; f[u][<span class="number">1</span>]=w[u];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">    f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;x);</span><br><span class="line">    <span class="type">int</span> pa=<span class="built_in">find</span>(i),pb=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(pa!=pb)&#123;</span><br><span class="line">      fa[pa]=pb;<span class="comment">//合并</span></span><br><span class="line">      <span class="built_in">add</span>(i,x),<span class="built_in">add</span>(x,i);<span class="comment">//加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      roots.<span class="built_in">push_back</span>(&#123;x,i&#125;);<span class="comment">//存根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> t:roots)&#123;</span><br><span class="line">    <span class="type">int</span> a=t.first,b=t.second;</span><br><span class="line">    sum+=<span class="built_in">max</span>(<span class="built_in">dfs</span>(a,<span class="number">-1</span>),<span class="built_in">dfs</span>(b,<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="392-基环树-P1399-NOI2013-快餐店"><a href="#392-基环树-P1399-NOI2013-快餐店" class="headerlink" title="392 基环树 P1399 NOI2013] 快餐店"></a>392 基环树 P1399 <a href="https://www.cnblogs.com/dx123/p/16464432.html">NOI2013] 快餐店</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P1399 [NOI2013] 快餐店</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w,ne;&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> vis[N],fa[N],w[N];</span><br><span class="line"><span class="type">int</span> inc[N],cv[N],cw[N],cn;</span><br><span class="line"><span class="type">double</span> d[N],A[N],B[N],C[N],D[N];</span><br><span class="line"><span class="type">double</span> ans1,ans2=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++idx]=&#123;b,c,h[a]&#125;;h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa[u])&#123;</span><br><span class="line">            fa[v]=u; w[v]=e[i].w;      </span><br><span class="line">            <span class="keyword">if</span>(!vis[v])&#123;<span class="comment">//v尚未访问</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(v))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//v已访问</span></span><br><span class="line">                <span class="type">int</span> p=u;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    inc[p]=<span class="number">1</span>;cv[++cn]=p;</span><br><span class="line">                    cw[cn]=w[p];p=fa[p];</span><br><span class="line">                    <span class="keyword">if</span>(p==u)<span class="keyword">break</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v, w=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(!inc[v]&amp;&amp;v!=fa)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            ans1=<span class="built_in">max</span>(ans1,d[u]+d[v]+w);</span><br><span class="line">            d[u]=<span class="built_in">max</span>(d[u],d[v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    <span class="built_in">add</span>(x,y,z);<span class="built_in">add</span>(y,x,z);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">find</span>(<span class="number">1</span>);<span class="comment">//深搜找环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn;++i)</span><br><span class="line">      <span class="built_in">dfs</span>(cv[i],<span class="number">0</span>);<span class="comment">//深搜求直径ans1</span></span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn;++i)&#123;<span class="comment">//求前缀</span></span><br><span class="line">        sum+=cw[i<span class="number">-1</span>];</span><br><span class="line">        A[i]=<span class="built_in">max</span>(A[i<span class="number">-1</span>],sum+d[cv[i]]);</span><br><span class="line">        B[i]=<span class="built_in">max</span>(B[i<span class="number">-1</span>],mx+d[cv[i]]+sum);</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,d[cv[i]]-sum);</span><br><span class="line">    &#125;</span><br><span class="line">    sum=mx=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> cn_1=cw[cn];cw[cn]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cn;i&gt;=<span class="number">1</span>;--i)&#123;<span class="comment">//求后缀</span></span><br><span class="line">        sum+=cw[i];</span><br><span class="line">        C[i]=<span class="built_in">max</span>(C[i+<span class="number">1</span>],sum+d[cv[i]]);</span><br><span class="line">        D[i]=<span class="built_in">max</span>(D[i+<span class="number">1</span>],mx+d[cv[i]]+sum);</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,d[cv[i]]-sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;cn;++i)&#123;<span class="comment">//拼凑答案</span></span><br><span class="line">        res=<span class="built_in">max</span>(<span class="built_in">max</span>(B[i],D[i+<span class="number">1</span>]),</span><br><span class="line">                A[i]+C[i+<span class="number">1</span>]+cn_1);</span><br><span class="line">        ans2=<span class="built_in">min</span>(ans2,res);</span><br><span class="line">    &#125;</span><br><span class="line">　　 ans2=<span class="built_in">min</span>(ans2,B[cn]);<span class="comment">//断最后一条边</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,<span class="built_in">max</span>(ans1,ans2)/<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="393-基环树-P5022-NOIP2018-提高组-旅行"><a href="#393-基环树-P5022-NOIP2018-提高组-旅行" class="headerlink" title="393 基环树 P5022 NOIP2018 提高组] 旅行"></a>393 基环树 P5022 <a href="https://www.cnblogs.com/dx123/p/16468119.html">NOIP2018 提高组] 旅行</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5022 [NOIP2018 提高组] 旅行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; edge[N];</span><br><span class="line"><span class="type">int</span> du,dv,vis[N];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(N,N)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt,better;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!better)&#123;</span><br><span class="line">    <span class="comment">//若序号变大则回退，变小则走完</span></span><br><span class="line">    <span class="keyword">if</span>(u&gt;path[cnt])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;path[cnt])better=<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[u]=<span class="literal">true</span>;</span><br><span class="line">  path[cnt++]=u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[u][i];</span><br><span class="line">    <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(v==du&amp;&amp;u==dv)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(v==dv&amp;&amp;u==du)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs</span>(v))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    edge[i]=&#123;a,b&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">sort</span>(e[i].<span class="built_in">begin</span>(),e[i].<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(n==m+<span class="number">1</span>) <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//枚举断边</span></span><br><span class="line">      du=edge[i].first;</span><br><span class="line">      dv=edge[i].second;</span><br><span class="line">      <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">      cnt=better=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="394-圆方树-P5236【模板】静态仙人掌"><a href="#394-圆方树-P5236【模板】静态仙人掌" class="headerlink" title="394 圆方树 P5236【模板】静态仙人掌"></a><a href="https://www.cnblogs.com/dx123/p/16480198.html">394 圆方树 P5236【模板】静态仙人掌</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20000</span>,M=N*<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h1[N],h2[N],idx=<span class="number">1</span>;<span class="comment">//建图</span></span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tim;<span class="comment">//tarjan</span></span><br><span class="line"><span class="type">int</span> s[N],sc[N],fa[N],fw[N],fe[N],cn;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">14</span>],dep[N],d[N];<span class="comment">//lca</span></span><br><span class="line"><span class="type">int</span> A,B;<span class="comment">//存lca的两个儿子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[],<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> sum=w;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=v;k!=u;k=fa[k])&#123;</span><br><span class="line">    s[k]=sum; <span class="comment">//u...k的环长</span></span><br><span class="line">    sum+=fw[k]; <span class="comment">//前缀和</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// s[u]=sc[u]=sum;</span></span><br><span class="line">  <span class="built_in">add</span>(h2,u,++cn,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=v;k!=u;k=fa[k])&#123;</span><br><span class="line">    sc[k]=sum; <span class="comment">//总环长</span></span><br><span class="line">    <span class="built_in">add</span>(h2,cn,k,<span class="built_in">min</span>(s[k],sum-s[k]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ine)</span></span>&#123;</span><br><span class="line">  dfn[u]=low[u]=++tim;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h1[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])&#123; <span class="comment">//若没有访问</span></span><br><span class="line">      <span class="comment">//fw:存边权，fe:存入边</span></span><br><span class="line">      fa[v]=u,fw[v]=w,fe[v]=i;</span><br><span class="line">      <span class="built_in">tarjan</span>(v,i);</span><br><span class="line">      low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">      <span class="keyword">if</span>(dfn[u]&lt;low[v]) <span class="comment">//非环边</span></span><br><span class="line">        <span class="built_in">add</span>(h2,u,v,w);<span class="comment">//直接加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i!=(ine^<span class="number">1</span>)) <span class="comment">//构成环</span></span><br><span class="line">      low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h1[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]&lt;dfn[v]&amp;&amp;fe[v]!=i)</span><br><span class="line">      <span class="built_in">build_tree</span>(u,v,w); <span class="comment">//建树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;</span><br><span class="line">  dep[u]=dep[father]+<span class="number">1</span>;</span><br><span class="line">  f[u][<span class="number">0</span>]=father;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">13</span>;k++)</span><br><span class="line">    f[u][k]=f[f[u][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h2[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">    d[v]=d[u]+w;</span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">13</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    <span class="keyword">if</span>(dep[f[u][k]]&gt;=dep[v])</span><br><span class="line">      u=f[u][k];</span><br><span class="line">  <span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">13</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    <span class="keyword">if</span>(f[u][k]!=f[v][k])&#123;</span><br><span class="line">      u=f[u][k];</span><br><span class="line">      v=f[v][k];</span><br><span class="line">    &#125;</span><br><span class="line">  A=u,B=v;<span class="comment">//存lca的两个儿子</span></span><br><span class="line">  <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">  cn=n;</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">add</span>(h1,a,b,c),<span class="built_in">add</span>(h1,b,a,c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//找环建树</span></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//lca打表</span></span><br><span class="line">  <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">lca</span>(u,v);<span class="comment">//找lca</span></span><br><span class="line">    <span class="keyword">if</span>(p&lt;=n) <span class="comment">//若是圆点</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d[u]+d[v]-d[p]*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//若是方点</span></span><br><span class="line">      <span class="type">int</span> len=<span class="built_in">abs</span>(s[A]-s[B]);</span><br><span class="line">      <span class="type">int</span> dAB=<span class="built_in">min</span>(len,sc[A]-len);</span><br><span class="line">      <span class="type">int</span> dis=dAB+d[u]-d[A]+d[v]-d[B];</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>算法模板</title>
    <link href="http://1414116846.github.io/2023/02/14/ypy%E6%A8%A1%E6%9D%BF/"/>
    <id>http://1414116846.github.io/2023/02/14/ypy%E6%A8%A1%E6%9D%BF/</id>
    <published>2023-02-14T12:13:33.413Z</published>
    <updated>2023-09-22T07:10:02.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合律</th><th align="center">助记</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><code>::</code></td><td align="center">从左至右</td><td align="center">作用域</td></tr><tr><td align="center">2</td><td align="center"><code>a++</code>、<code>a--</code>、 <code>type()</code>、<code>type&#123;&#125;</code>、 <code>a()</code>、<code>a[]</code>、 <code>.</code>、<code>-&gt;</code></td><td align="center">从左至右</td><td align="center">后缀自增减、 函数风格转型、 函数调用、下标、 成员访问</td></tr><tr><td align="center">3</td><td align="center"><code>!</code>、<code>~</code>、 <code>++a</code>、<code>--a</code>、<code>+a</code>、<code>-a</code>、 <code>(type)</code>、<code>sizeof</code>、<code>&amp;a</code>、 <code>*a</code>、 <code>new</code>、 <code>new[]</code>、<code>delete</code>、 <code>delete[]</code></td><td align="center"><strong>从右至左</strong></td><td align="center">逻辑非、按位非、 前缀自增减、正负、 C 风格转型、取大小、取址、 指针访问、 动态内存分配</td></tr><tr><td align="center">4</td><td align="center"><code>.*</code>、<code>-&gt;*</code></td><td align="center">从左至右</td><td align="center">指向成员指针</td></tr><tr><td align="center">5</td><td align="center"><code>a*b</code>、<code>a/b</code>、<code>a%b</code></td><td align="center">从左至右</td><td align="center">乘除、取模</td></tr><tr><td align="center">6</td><td align="center"><code>a+b</code>、<code>a-b</code></td><td align="center">从左至右</td><td align="center">加减</td></tr><tr><td align="center">7</td><td align="center"><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td><td align="center">从左至右</td><td align="center">按位左右移</td></tr><tr><td align="center">8</td><td align="center"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td><td align="center">从左至右</td><td align="center">大小比较</td></tr><tr><td align="center">9</td><td align="center"><code>==</code>、<code>!=</code></td><td align="center">从左至右</td><td align="center">等价比较</td></tr><tr><td align="center">10</td><td align="center"><code>a&amp;b</code></td><td align="center">从左至右</td><td align="center">按位与</td></tr><tr><td align="center">11</td><td align="center"><code>^</code></td><td align="center">从左至右</td><td align="center">按位异或</td></tr><tr><td align="center">12</td><td align="center">&#96;</td><td align="center">&#96;</td><td align="center">从左至右</td></tr><tr><td align="center">13</td><td align="center"><code>&amp;&amp;</code></td><td align="center">从左至右</td><td align="center">逻辑与</td></tr><tr><td align="center">14</td><td align="center">&#96;</td><td align="center"></td><td align="center">&#96;</td></tr><tr><td align="center">15</td><td align="center"><code>a?b:c</code>、 <code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&amp;=</code>、<code>^=</code>、&#96;</td><td align="center">&#x3D;<code>、</code>&lt;&lt;&#x3D;<code>、</code>&gt;&gt;&#x3D;&#96;</td><td align="center"><strong>从右至左</strong></td></tr><tr><td align="center">16</td><td align="center"><code>,</code></td><td align="center">从左至右</td><td align="center">逗号</td></tr></tbody></table><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>以二分答案的check函数为例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; check = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=cnt&amp;&amp;a[i]&gt;=x-cnt<span class="number">-1</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="读入优化"><a href="#读入优化" class="headerlink" title="读入优化"></a>读入优化</h2><p>如果输入输出规模超过1e6就不建议使用cin&#x2F;cout</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭同步流</span></span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="int128"><a href="#int128" class="headerlink" title="__int128"></a>__int128</h2><p><code>__int128</code> 就是占用128字节的整数存储类型。由于是二进制，范围就是$-2^{127}$ ~ $2^{127} - 1$ </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">81</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">不能关流!!!!!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">__int128 a=read();</span></span><br><span class="line"><span class="comment">__int128 b=read();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">print(a+b);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> __int128 <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __int128 x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">9</span>)</span><br><span class="line">        <span class="built_in">print</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">__int128 game[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">__int128 f[MAXN][MAXN];</span><br><span class="line"><span class="function">__int128 <span class="title">solve</span><span class="params">(__int128 a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">0</span>;len&lt;=m;++len)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len&lt;=m;++i)</span><br><span class="line">            f[i][i+len]=<span class="built_in">max</span>(<span class="number">2</span>*f[i+<span class="number">1</span>][i+len]+<span class="number">2</span>*a[i],<span class="number">2</span>*f[i][i+len<span class="number">-1</span>]+<span class="number">2</span>*a[i+len]);</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int128 ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            game[i][j] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans+=<span class="built_in">solve</span>(game[i]);</span><br><span class="line">    <span class="built_in">print</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p><a href="https://blog.csdn.net/lanchunhui/article/details/49644373">(10条消息) C++基础——简单而强大的bitset_五道口纳什的博客-CSDN博客</a></p><p>里面存的是一个01串，可以用来当做标记数组</p><p>&lt;&lt;,&gt;&gt;运算符在这里是把<strong>值的位置</strong>往左或往右移动几位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">bitset&lt;maxn&gt; dp[<span class="number">102</span>];<span class="comment">//dp[i][j]-&gt;第i轮，值为j的数是否存在</span></span><br><span class="line"><span class="type">int</span> n, l ,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    dp[<span class="number">0</span>].<span class="built_in">set</span>(<span class="number">0</span>);             <span class="comment">//第0位要置1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = l; j &lt;= r; j++)</span><br><span class="line">            dp[i] |= dp[i<span class="number">-1</span>]&lt;&lt;(j * j);</span><br><span class="line">          <span class="comment">/* dp[i-1]&lt;&lt;(j * j) -&gt; 上一轮的所有数加上这一轮的数*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n].<span class="built_in">count</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双端队列（STL）"><a href="#双端队列（STL）" class="headerlink" title="双端队列（STL）"></a>双端队列（STL）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    deque&lt;<span class="type">int</span> &gt; dq;</span><br><span class="line">    dq.<span class="built_in">push_front</span>(a); <span class="comment">//添加元素到头</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(a); <span class="comment">//添加元素到尾</span></span><br><span class="line">    </span><br><span class="line">    a = dq.<span class="built_in">front</span>(); <span class="comment">//取出头元素</span></span><br><span class="line">    a = dq.<span class="built_in">back</span>(); <span class="comment">//取出尾元素</span></span><br><span class="line"></span><br><span class="line">    dq.<span class="built_in">pop_front</span>(); <span class="comment">//删除头元素</span></span><br><span class="line">    dq.<span class="built_in">pop_back</span>(); <span class="comment">//删除尾元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速计算a*b % mod的结果（主要目的是换乘法为加法，防止爆数据），或者快速计算a^b % mod 的结果，时间复杂度大大降低。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">q_pow</span><span class="params">(ll a, ll b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b) &#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans = (ans*a)%mod;</span><br><span class="line">b /= <span class="number">2</span>;</span><br><span class="line">a = (a*a)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列(priority_queue)"></a>优先队列(priority_queue)</h2><p>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><p>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</p><p>一般是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型</span></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span> <span class="comment">//运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="type">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp2</span> <span class="comment">//重写仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r,len;</span><br><span class="line"><span class="built_in">tmp1</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)&#123;l = a;r = b;len = c;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(len==a.len) <span class="keyword">return</span> l &gt; a.l;</span><br><span class="line"><span class="keyword">return</span> len &lt; a.len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>insert(x) 可将 x 插入 set 容器中</p><p>find(value) 返回 set 中对应值为 value 的迭代器</p><p>erase(value) ，value 为所需要删除元素的值。</p><p>每次操作都是logn</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>c++中map与unordered_map的区别</p><ul><li><strong>运行效率方面</strong>：unordered_map最高，而map效率较低但 提供了稳定效率和有序的序列。</li><li><strong>占用内存方面</strong>：map内存占用略低，unordered_map内存占用略高,而且是线性成比例的。</li></ul><h2 id="sqrt精度调整"><a href="#sqrt精度调整" class="headerlink" title="sqrt精度调整"></a>sqrt精度调整</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll x=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">while</span> (x*x&gt;n) x--;</span><br><span class="line"><span class="keyword">while</span> ((x+<span class="number">1</span>)*(x+<span class="number">1</span>)&lt;=n) x++;</span><br></pre></td></tr></table></figure><h2 id="预处理小规模组合数"><a href="#预处理小规模组合数" class="headerlink" title="预处理小规模组合数"></a>预处理小规模组合数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">60</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> C[i][j] = (C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>]) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">2</span>&lt;&lt;<span class="number">14</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="type">int</span> temp = n;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">14</span>;j++) <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>) temp -= b[j], cnt++;</span><br><span class="line">res = <span class="built_in">min</span>(res, cnt + __builtin_popcountll(temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__builtin_popcountll()函数可求一个数的二进制表示有多少个1</p><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><h2 id="简单模板"><a href="#简单模板" class="headerlink" title="简单模板"></a>简单模板</h2><p> <a href="https://vjudge.csgrandeur.cn/problem/HDU-2222/origin">HDU - 2222 </a></p><p>给定 <code>n</code> 个长度不超过 50 的由小写英文字母组成的单词准备查询，以及一篇长为 <code>m</code> 的文章，问：文中出现了多少种待查询的单词。多组数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ms(a,b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> * <span class="number">55</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>],fail[N];<span class="comment">//tire树 和 失匹指针</span></span><br><span class="line"><span class="type">int</span> idx,cnt[N];</span><br><span class="line"><span class="type">char</span> s[M];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span> <span class="comment">//tire插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>,l = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(!tr[p][u]) tr[p][u] = ++idx;</span><br><span class="line">p = tr[p][u];</span><br><span class="line">&#125;</span><br><span class="line">cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getfail</span><span class="params">()</span> <span class="comment">//获取fail</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//BFS遍历每一层</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="comment">//遍历第一层，初始化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[p][i]) tr[p][i] = tr[fail[p]][i]; <span class="comment">//如果当前节点i不存在</span></span><br><span class="line">                                         <span class="comment">//则让这个【节点】指向它的父亲节点的fail指针                                                      //所指向的节点i</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">//否则就让当前【节点i的fail】指向它的父亲节点的fail指针所指向的节点i</span></span><br><span class="line">&#123;</span><br><span class="line">fail[tr[p][i]] = tr[fail[p]][i];</span><br><span class="line">q.<span class="built_in">push</span>(tr[p][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>,ans = <span class="number">0</span>,l = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">p = tr[p][u];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = p;</span><br><span class="line"><span class="keyword">while</span>(j) <span class="comment">//一直向上找</span></span><br><span class="line">&#123;</span><br><span class="line">ans += cnt[j];</span><br><span class="line">cnt[j] = <span class="number">0</span>;</span><br><span class="line">j = fail[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ms</span>(tr,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">ms</span>(fail,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">ms</span>(cnt,<span class="number">0</span>);</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="built_in">insert</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getfail</span>();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h2><p>1、如果两个元素已经在一个集合中，不需要合并操作（尤其是有边权的时候，会导致边权翻倍）</p><h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h2><p><a href="https://www.acwing.com/problem/content/description/838/">836. 合并集合 - AcWing题库</a></p><p>一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p><p>现在要进行 mm 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 a 和 b 的两个数是否在同一个集合中；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N],a,b;</span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">//路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p><a href="https://www.acwing.com/problem/content/242/">240. 食物链 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,op;</span><br><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="built_in">find</span>(p[x]); <span class="comment">//先压缩路径</span></span><br><span class="line">d[x] += d[p[x]]; <span class="comment">//再更新权值</span></span><br><span class="line">p[x] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i] = i;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(a&gt;n||b&gt;n) res ++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pa = <span class="built_in">find</span>(a);</span><br><span class="line"><span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pa==pb&amp;&amp;(d[a]-d[b])%<span class="number">3</span>) res++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">&#123;</span><br><span class="line">p[pa] = pb;</span><br><span class="line">d[pa] = d[b] - d[a]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pa==pb&amp;&amp;(d[a]-d[b]<span class="number">-1</span>)%<span class="number">3</span>) res++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">&#123;</span><br><span class="line">p[pa] = pb;</span><br><span class="line">d[pa] = d[b]+<span class="number">1</span>-d[a];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/description/241/">239. 奇偶游戏 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!mp[x]) mp[x] = ++cnt;</span><br><span class="line"><span class="keyword">return</span> mp[x]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p[x] != x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="built_in">find</span>(p[x]);</span><br><span class="line">d[x] ^= d[p[x]];</span><br><span class="line">p[x] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s&quot;</span>,&amp;a,&amp;b,op);</span><br><span class="line">a = <span class="built_in">get</span>(a<span class="number">-1</span>);</span><br><span class="line">b = <span class="built_in">get</span>(b);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;o&#x27;</span>) t = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> pa = <span class="built_in">find</span>(a) , pb = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pa==pb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(d[a]^d[b]!=t)</span><br><span class="line">&#123;</span><br><span class="line">ans = i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p[pa] = pb;</span><br><span class="line">d[pa] = d[a]^d[b]^t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h2><p><img src="https://s2.loli.net/2022/06/28/T9N2gpiSZXf54Yk.jpg" alt="2675_e50e111055-4"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>, Base = N / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.<span class="built_in">count</span>(x) == <span class="number">0</span>) &#123;</span><br><span class="line">        S[x] = ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = m;  <span class="comment">//如果无矛盾, 输出问题数量, 初始的时候为m</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        string type;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; type;</span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);  <span class="comment">// s[a-1], s[b]</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;even&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a + Base) == <span class="built_in">find</span>(b)||<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b+Base)) &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a + Base)] = <span class="built_in">find</span>(b + Base);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)||<span class="built_in">find</span>(a+Base)==<span class="built_in">find</span>(b+Base)) &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a + Base)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b + Base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>树状数组作用：<br>1.快速求前缀和<code>O(log n)</code><br>2.修改某一个数<code>O(log n)</code></p><p>3.求数组逆序对</p><p><img src="https://s2.loli.net/2022/06/29/9iEmkKQPYqts4M3.png" alt="树状数组.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lowbit:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line">查询：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) sum+=tr[i];</span><br><span class="line">更改：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=c;</span><br></pre></td></tr></table></figure><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>最坏情况下时间复杂度有$O(4×nlogn)$，全局longlong，输入输出都会影响复杂度</p><h2 id="懒标记线段树"><a href="#懒标记线段树" class="headerlink" title="懒标记线段树"></a>懒标记线段树</h2><p>可以使用懒标记的操作有：区间加减，区间乘除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N =  <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">ll l,r,lazy,sum;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line">ll temp_num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[i].sum = tree[i*<span class="number">2</span>].sum + tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[i].lazy)</span><br><span class="line">&#123;</span><br><span class="line">tree[i*<span class="number">2</span>].lazy += tree[i].lazy;</span><br><span class="line">tree[i*<span class="number">2</span>+<span class="number">1</span>].lazy += tree[i].lazy;</span><br><span class="line">tree[i*<span class="number">2</span>].sum += (tree[i*<span class="number">2</span>].r - tree[i*<span class="number">2</span>].l + <span class="number">1</span>) * tree[i].lazy;</span><br><span class="line">tree[i*<span class="number">2</span>+<span class="number">1</span>].sum += (tree[i*<span class="number">2</span>+<span class="number">1</span>].r - tree[i*<span class="number">2</span>+<span class="number">1</span>].l + <span class="number">1</span>) * tree[i].lazy;</span><br><span class="line">tree[i].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l ,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[i].l = l;</span><br><span class="line">tree[i].r = r;</span><br><span class="line">tree[i].lazy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">tree[i].sum = temp_num[l];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(i*<span class="number">2</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(i*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r,ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">tree[i].sum += (tree[i].r - tree[i].l + <span class="number">1</span>)*num;</span><br><span class="line">tree[i].lazy += num;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">pushdown</span>(i);</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">add</span>(i*<span class="number">2</span>,l,r,num);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">add</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r,num);</span><br><span class="line"><span class="built_in">pushup</span>(i);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tree[i].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pushdown</span>(i);</span><br><span class="line"><span class="type">int</span> mid = tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) s += <span class="built_in">query</span>(i*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) s += <span class="built_in">query</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="势能线段树"><a href="#势能线段树" class="headerlink" title="势能线段树"></a>势能线段树</h2><p>某些修改存在一些奇妙的性质，使得序列每个元素被修改的次数有一个<strong>上限</strong>(如开方)</p><p>可以在线段树每个节点上记录一个值，<strong>表示对应区间内是否每个元素都达到修改次数上限</strong></p><p>区间修改时暴力递归到叶子节点，如果途中遇到一个节点，这个节点的对应区间内每个元素都达到修改次数上限则在这个节点 return 掉</p><p>可以证明复杂度为 $O(nlogn ×修改次数上限)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum,cnt[<span class="number">25</span>];</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[i].sum = (tr[i&lt;&lt;<span class="number">1</span>].sum + tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">        tr[i].cnt[j] = tr[i&lt;&lt;<span class="number">1</span>].cnt[j] + tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[i].l = l,tr[i].r = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        tr[i].sum = (a[l]*a[l])%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">            tr[i].cnt[j] = a[l]&gt;&gt;j&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l==tr[i].r) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tr[i].cnt[j]&amp;&amp;(x&gt;&gt;j&amp;<span class="number">1</span>)) sum|=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">            <span class="keyword">else</span> tr[i].cnt[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tr[i].sum = (ll)sum*sum%mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r) &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[i].cnt[j]&amp;&amp;(x&gt;&gt;j&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=l) <span class="built_in">modify</span>(i&lt;&lt;<span class="number">1</span>,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) <span class="built_in">modify</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x);</span><br><span class="line">    <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r) <span class="keyword">return</span> tr[i].sum;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=l) s = <span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>,l,r)%mod;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) s = (s+<span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%mod;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="type">int</span> op,l,r,x;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l,r)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="杂选题"><a href="#杂选题" class="headerlink" title="杂选题"></a>杂选题</h2><h3 id="导弹拦截"><a href="#导弹拦截" class="headerlink" title="导弹拦截"></a>导弹拦截</h3><p>[P1020 <a href="https://www.luogu.com.cn/problem/P1020">NOIP1999 普及组] 导弹拦截 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>DP + 贪心 + 二分  <strong>O(nlogn)</strong></p><p><strong>Dilworth 定理</strong></p><p>将拦截的导弹的高度提出来成为原高度序列的一个子序列，根据题意这个子序列中的元素是单调不增的（即后一项总是不大于前一项），我们称为<strong>单调不升子序列</strong>。本问所求能拦截到的最多的导弹，即求<strong>最长的单调不升子序列</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> n,cnt;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[++n]));</span><br><span class="line">    n--;</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>; <span class="comment">//初始化一个最大值，防止边界溢出</span></span><br><span class="line">    <span class="type">int</span> l,r,len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l = <span class="number">0</span>,r = len;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(b[mid]&gt;=a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = r+<span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[i]); <span class="comment">//记录答案</span></span><br><span class="line">        b[r+<span class="number">1</span>] = a[i]; <span class="comment">//更新当前 长度+1 的序列中最大的最后一位数</span></span><br><span class="line">        len = <span class="built_in">max</span>(len,r+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    t[<span class="number">1</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>,r = res;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t[mid]&gt;=a[i]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t[r]&gt;=a[i]) t[r] = a[i];</span><br><span class="line">        <span class="keyword">else</span> t[++res] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从左到右依次枚举每个导弹。假设现在有若干个导弹拦截系统可以拦截它，那么我们肯定选择这些系统当中位置最低的那一个。如果不存在任何一个导弹拦截系统可以拦截它，那我们只能新加一个系统了</p><p>观察第二问的代码，与第一问进行比较，可以发现这段代码<strong>等价于</strong>计算最长上升子序列（严格上升，即后一项大于前一项）。这其实是 <strong>Dilworth 定理</strong>（将一个序列剖成若干个单调不升子序列的最小个数等于该序列最长上升子序列的个数），本处从代码角度证明了该结论。</p><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> w[N][N],v[N][N],f[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,V;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;V);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;v[i][j],&amp;w[i][j]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=s[i];k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=v[i][k]) f[j] = <span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[V]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line">ll f[N][N];</span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ms</span>(f,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++) &#123; <span class="comment">//枚举区间长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=len;j&lt;=n;i++,j++) &#123; <span class="comment">//枚举区间左右下标</span></span><br><span class="line">            <span class="keyword">if</span>(i==j) &#123; <span class="comment">//初始化区间长度为1的值</span></span><br><span class="line">                f[i][j] = a[i]*b[n];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j],f[i][j<span class="number">-1</span>]+b[n-(j-i)]*a[j]);</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j],f[i+<span class="number">1</span>][j]+b[n-(j-i)]*a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p><a href="https://www.acwing.com/problem/content/287/">285. 没有上司的舞会 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6050</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[N];<span class="comment">//储存每个上司的儿子</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][0] 不选i，子树的最大值 </span></span><br><span class="line"><span class="comment">f[i][1] 选i，子树的最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//边界</span></span><br><span class="line">    f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>] = a[u];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:son[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[i][<span class="number">0</span>];</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[i][<span class="number">1</span>],f[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> root = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        root -= u;</span><br><span class="line">        son[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(f[root][<span class="number">1</span>],f[root][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h3><p>换根DP 一般分为三个步骤：</p><p>指定任意一个根节点<br>一次dfs遍历，统计出当前子树内的节点对当前节点的贡献</p><p>一次dfs遍历，统计出当前节点的父节点对当前节点的贡献，然后合并统计答案</p><p>那么我们就要先 dfs 一遍，预处理出当前子树对于根的最大贡献（距离）和 次大贡献（距离）</p><p>处理 次大贡献（距离） 的原因是：</p><p>如果 当前节点 是其 父节点子树 的 最大路径 上的点，则 父节点子树 的 最大贡献 不能算作对该节点的贡献</p><p>因为我们的路径是 简单路径，不能 走回头路</p><p>然后我们再 dfs 一遍，求解出每个节点的父节点对他的贡献（即每个节点往上能到的最远路径</p><p>两者比较，取一个 max 即可</p><p><img src="https://s2.loli.net/2022/08/04/7sEvdAyQIuW5Fbr.png" alt="image-20220726183319977"></p><p><a href="https://www.acwing.com/problem/content/1075/">1073. 树的中心 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line">vector&lt;PII &gt; son[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> dow[N]; <span class="comment">//记录i结点的最长子节点,即i与dow[i]连接时获得的值最大;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> <span class="comment">//向下找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line"><span class="type">int</span> v = i.first, w = i.second;</span><br><span class="line"><span class="keyword">if</span>(fa==v) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line"><span class="type">int</span> dist = f[v][<span class="number">0</span>] + w;</span><br><span class="line"><span class="keyword">if</span>(dist&gt;f[u][<span class="number">0</span>]) <span class="built_in">swap</span>(f[u][<span class="number">0</span>],f[u][<span class="number">1</span>]), f[u][<span class="number">0</span>] = dist, dow[u] = v;</span><br><span class="line"><span class="keyword">else</span> f[u][<span class="number">1</span>] = <span class="built_in">max</span>(f[u][<span class="number">1</span>],dist);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> <span class="comment">//向上找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line"><span class="type">int</span> v = i.first, w = i.second;</span><br><span class="line"><span class="keyword">if</span>(fa==v) <span class="keyword">continue</span>;</span><br><span class="line">f[v][<span class="number">2</span>] = w;</span><br><span class="line"><span class="keyword">if</span>(v==dow[u]) f[v][<span class="number">2</span>] += <span class="built_in">max</span>(f[u][<span class="number">2</span>],f[u][<span class="number">1</span>]); </span><br><span class="line"><span class="keyword">else</span> f[v][<span class="number">2</span>] += <span class="built_in">max</span>(f[u][<span class="number">2</span>],f[u][<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">dfs2</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">son[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">son[b].<span class="built_in">push_back</span>(&#123;a,c&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> res = f[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">res = <span class="built_in">min</span>(res, <span class="built_in">max</span>(f[i][<span class="number">0</span>],f[i][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h3><p><a href="https://ac.nowcoder.com/acm/problem/50510">皇宫看守 (nowcoder.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1510</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[N];</span><br><span class="line"><span class="type">int</span> st[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    f[i][0] 对于i这个子树，i点由 其父 节点看守的最小花费</span></span><br><span class="line"><span class="comment">    f[i][1] 对于i这个子树，i点由 其子 节点看守的最小花费</span></span><br><span class="line"><span class="comment">    f[i][2] 对于i这个子树，i点由 本身 节点看守的最小花费</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>] = inf;</span><br><span class="line">    f[u][<span class="number">2</span>] = w[u];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i,u);</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]);</span><br><span class="line">        f[u][<span class="number">2</span>] += <span class="built_in">min</span>(f[i][<span class="number">0</span>],<span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]));</span><br><span class="line">        sum += <span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa) <span class="keyword">continue</span>;</span><br><span class="line">        f[u][<span class="number">1</span>] = <span class="built_in">min</span>(f[u][<span class="number">1</span>], sum - <span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]) + f[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        w[a] = b;</span><br><span class="line">        cin&gt;&gt;b;</span><br><span class="line">        <span class="keyword">while</span>(b--) &#123;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            son[a].<span class="built_in">push_back</span>(c);</span><br><span class="line">            son[c].<span class="built_in">push_back</span>(a);</span><br><span class="line">            st[c] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(st[root]) root++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(f[root][<span class="number">1</span>],f[root][<span class="number">2</span>])&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">10</span>) + <span class="number">10</span>;</span><br><span class="line">ll f[<span class="number">12</span>][<span class="number">110</span>][N]; <span class="comment">//f[i][j][k] 第i行放置了j个将军，状态为k的所有方案</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line">vector&lt;<span class="type">int</span> &gt; a,b[N]; <span class="comment">//a放置合法状态,b放置a的合法转移状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//检查x有没有两个相邻的1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(x&amp;x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//获得x中有几个1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) c += (x&gt;&gt;i &amp; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(i)) a.<span class="built_in">push_back</span>(i), cnt[i] = <span class="built_in">count</span>(i); <span class="comment">//储存所有的合法状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j : a) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(i|j)&amp;&amp;((i&amp;j)==<span class="number">0</span>)) b[i].<span class="built_in">push_back</span>(j); <span class="comment">//储存所有的合法转移状态,i状态的上下行可以是j</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) <span class="comment">//n行转移，n+1行是为了好统计答案</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++) <span class="comment">//目前使用的国王棋子数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> k : a)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> u : b[k]) &#123;</span><br><span class="line"><span class="type">int</span> c = cnt[k]; <span class="comment">//查看a中有几个已经放置的国王</span></span><br><span class="line"><span class="keyword">if</span>(j&gt;=c) <span class="comment">//目前一共放j个国王，从b转移到a，要满足国王数不超标</span></span><br><span class="line">                        f[i][j][k] += f[i<span class="number">-1</span>][j-c][u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;f[n+<span class="number">1</span>][k][<span class="number">0</span>]&lt;&lt;endl; <span class="comment">//第n+1行什么都不放，相当于只在1~n行放国王，目前一共放了k个国王的总方案数，其实就是答案要求的方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> temp[N], s[<span class="number">2</span> * N];<span class="comment">//temps是原字符串,s是处理后的字符串</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span> * N]; <span class="comment">// p[i]-1 是对于s串，以i个字符为中心的最长回文串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    s[cnt++] = <span class="string">&#x27;@&#x27;</span>; <span class="comment">//左边界字符</span></span><br><span class="line">    s[cnt++] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">//填充字符</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(temp + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[cnt++] = temp[i];</span><br><span class="line">        s[cnt++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[cnt] = <span class="string">&#x27;!&#x27;</span>; <span class="comment">//右边界字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">            p[i] = <span class="built_in">min</span>(mx - i, p[<span class="number">2</span> * id - i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[i - p[i]] == s[i + p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = p[i] + i;</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">初始化：一般不需要</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="数Math"><a href="#数Math" class="headerlink" title="数Math"></a>数Math</h1><h2 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">去掉最后一位  x &gt;&gt; 1</span></span><br><span class="line"><span class="comment">在最后加一个0 x &lt;&lt; 1</span></span><br><span class="line"><span class="comment">在最后加一个1(x &lt;&lt; 1) - 1</span></span><br><span class="line"><span class="comment">把最后一位变成1x | 1</span></span><br><span class="line"><span class="comment">把最后一位变成0(x | 1) - 1</span></span><br><span class="line"><span class="comment">最后一位取反 x ^ 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">把右数第k位变成0x &amp; (~(1 &lt;&lt; (k-1)))</span></span><br><span class="line"><span class="comment">把右数第k位取反x ^ ((1 &lt;&lt; (k-1)))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">取末k位  x &amp; ((1 &lt;&lt; k) - 1)</span></span><br><span class="line"><span class="comment">取右数第k位 (x &gt;&gt; (k-1)) &amp; 1</span></span><br><span class="line"><span class="comment">把末k位变成1 x | ((1 &lt;&lt; k) - 1)</span></span><br><span class="line"><span class="comment">末k位取反  x ^ ((1 &lt;&lt; k) - 1)</span></span><br><span class="line"><span class="comment">把右边连续的1变成0 (x &amp; (x + 1))</span></span><br><span class="line"><span class="comment">把右边第一个0变成1  x | (x + 1) </span></span><br><span class="line"><span class="comment">把右边连续的0变成1x | (x - 1)</span></span><br><span class="line"><span class="comment">取右边连续的1  (x ^ (x + 1)) &gt;&gt; 1</span></span><br><span class="line"><span class="comment">去掉右起第一个1的左边(lowbit)  x &amp; ( -x )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="gcd-lcm"><a href="#gcd-lcm" class="headerlink" title="gcd &amp; lcm"></a>gcd &amp; lcm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辗转相除，它们的最大公约数等于a除以b的余数c和b之间的最大公约数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> b&gt;<span class="number">0</span> ? <span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lcm代码如下：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;<span class="comment">//防溢出 ， 很妙啊 ，大家可以记一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更相减损，两个正整数a和b（a&gt;b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数，避免了大整数取模，但是运算次数较多。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a-b,b);</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b-a,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><h3 id="算术基本定理（唯一分解"><a href="#算术基本定理（唯一分解" class="headerlink" title="算术基本定理（唯一分解"></a>算术基本定理（唯一分解</h3><p>就是因式分解的定理，所有的整数都可以唯一分解成若干个质因子乘积的形式：</p><p>$N &#x3D; P_1^{a1}\times P_2^{a2}\times … \times P_k^{ak}$ 其中 $P_i$ 是质数，每一个 $a_i \geq 0$</p><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//求出n的所有约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i != n / i) &#123;  <span class="comment">// 避免 i==n/i, 重复放入 （n是完全平方数）</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : res) &#123;</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><h3 id="筛法求素数——线性筛法（欧拉筛法）"><a href="#筛法求素数——线性筛法（欧拉筛法）" class="headerlink" title="筛法求素数——线性筛法（欧拉筛法）"></a>筛法求素数——线性筛法（欧拉筛法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st[N];</span><br><span class="line">vector&lt;<span class="type">int</span> &gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxnum = N<span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=maxnum;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]&lt;=maxnum/i;j++) &#123;</span><br><span class="line">            st[i*primes[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p><img src="https://s2.loli.net/2022/11/28/ZfrhuQjXKT4OGdB.jpg" alt="1.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,res;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        res = a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=a/i;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(a%i==<span class="number">0</span>)</span><br><span class="line">                    a/=i;</span><br><span class="line">                res = res / i*(i<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">1</span>) res = res /a*(a<span class="number">-1</span>);</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h2><p><img src="https://s2.loli.net/2022/11/29/5kSTrqy7gLsD1NX.jpg" alt="6B8715BC-6CB8-4C2F-99BC-8762C6959443.jpeg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[primes[j] * i] = phi[i] * primes[j]; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[primes[j] * i] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂求逆元（费马小定理）"><a href="#快速幂求逆元（费马小定理）" class="headerlink" title="快速幂求逆元（费马小定理）"></a>快速幂求逆元（费马小定理）</h2><p>$a &#x2F; b ≡ a * x (mod n)$<br>两边同乘b可得 $a ≡ a * b * x (mod n)$<br>即 $1 ≡ b * x (mod n)$<br>同 $b * x ≡ 1 (mod n)$<br>由费马小定理可知，当n为质数时<br>$b ^ {(n - 1)} ≡ 1 (mod n)$<br>拆一个b出来可得 $b * b ^ {(n - 2)} ≡ 1 (mod n)$<br>故当n为质数时，b的乘法逆元 $x &#x3D; b ^{ (n - 2)}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">q_pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = (res * a)%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a = (a * a)%p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,p;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;p;</span><br><span class="line">    <span class="keyword">if</span>(__gcd(a,p)==<span class="number">1</span>) cout&lt;&lt;<span class="built_in">q_pow</span>(a,p<span class="number">-2</span>,p)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得求逆元"><a href="#扩展欧几里得求逆元" class="headerlink" title="扩展欧几里得求逆元"></a>扩展欧几里得求逆元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> &amp;x, <span class="type">long</span> <span class="type">long</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (x % b + b) % b);<span class="comment">//这里防止出现负数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a , ll b , ll modd)</span></span>&#123;<span class="comment">//快速幂 </span></span><br><span class="line">ll ans = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>)ans = ans * a % modd ;</span><br><span class="line">a = a * a % modd ;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n , ll m)</span></span>&#123;<span class="comment">//组合数Cnm的值 </span></span><br><span class="line">ll ans1 = <span class="number">1</span> , ans2 = <span class="number">1</span> , ans3 = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">ans1 = ans1 * i % mod ;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= m ; i++)</span><br><span class="line">ans2 = ans2 * i % mod ;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= n - m ; i++)</span><br><span class="line">ans3 = ans3 * i % mod ;</span><br><span class="line"><span class="keyword">return</span> ans1 * <span class="built_in">qpow</span>(ans2 , mod - <span class="number">2</span> , mod) % mod * <span class="built_in">qpow</span>(ans3 , mod - <span class="number">2</span> , mod) % mod ;</span><br><span class="line"><span class="comment">//费马小定理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="临时"><a href="#临时" class="headerlink" title="临时"></a>临时</h1><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><p>给定长度为 N 的整数序列 AA，下标为 1∼N。</p><p>现在要执行 MM 次操作，其中第 ii 次操作为给出三个整数 li,ri,ki，求$A[li],A[li+1],…,A[ri](即 A 的下标区间 [li,ri][li,ri]) $中第 ki 小的数是多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="type">int</span> idx; <span class="comment">//用来搞下标</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r; <span class="comment">// 这里的l,r存的是左右儿子的下标,这里的区间需要自己推一下</span></span><br><span class="line">    <span class="type">int</span> cnt; <span class="comment">// 在这个点包含的区间里面有多少个数字</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span> + N* <span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> root[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回的是一个下标 这个下标从0开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),x) - nums.<span class="built_in">begin</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = ++idx;<span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> p; <span class="comment">// 代表到了叶子节点</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    tr[p].l = <span class="built_in">build</span>(l,mid); <span class="comment">// tr[]数组里面的l,r是自己左右儿子的下标 不是p这个点所代表的范围</span></span><br><span class="line">    tr[p].r = <span class="built_in">build</span>(mid + <span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = ++idx; <span class="comment">// 这是现在的节点</span></span><br><span class="line">    tr[now] = tr[pre]; <span class="comment">//这个节点会继承前一个版本的所有信息</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="comment">// 代表到了叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[now].cnt++; <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 下一个insert的前驱就是这个insert的前驱的左右儿子,因为x在的位置区间,都需要修改</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)<span class="comment">// 代表这个点在左边 ,</span></span><br><span class="line">    tr[now].l = <span class="built_in">insert</span>(tr[pre].l,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在右边</span></span><br><span class="line">    tr[now].r = <span class="built_in">insert</span>(tr[pre].r,mid + <span class="number">1</span>,r,x);</span><br><span class="line"></span><br><span class="line">    tr[now].cnt = tr[tr[now].l].cnt + tr[tr[now].r].cnt; <span class="comment">// 当前这个节点的cnt是左儿子的节点 + 右儿子的节点</span></span><br><span class="line">    <span class="comment">// 相当于pushup操作</span></span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> r;<span class="comment">// 代表到了叶子节点,也就是找到了这个点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = tr[tr[now].l].cnt - tr[tr[pre].l].cnt; <span class="comment">// 代表在询问区间L,R里面有几个数字</span></span><br><span class="line">    <span class="comment">// 前R个版本你在l,r里面有tr[tr[now].l].cnt 数字</span></span><br><span class="line">    <span class="comment">// 前L - 1个版本里面你在l,r里面有tr[tr[pre].l].cnt个数字</span></span><br><span class="line">    <span class="comment">// 那在[L,R]这个版本里面你在l,r里面就是有tr[tr[now].l].cnt - tr[tr[pre].l].cnt个数字</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= k) ans = <span class="built_in">query</span>(tr[pre].l,tr[now].l,l,mid,k); <span class="comment">// 代表你想要找的在区间左边 还是要找第k个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 右区间</span></span><br><span class="line">    ans = <span class="built_in">query</span>(tr[pre].r,tr[now].r,mid + <span class="number">1</span>,r,k - cnt);<span class="comment">//在右边就是找 第k - cnt个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 建立一下线段树的整体框架,因为框架是不变的,变的是里面的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++ ) <span class="comment">//接下来就是每一个版本了</span></span><br><span class="line">    &#123;</span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>],<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>,<span class="built_in">find</span>(a[i])); <span class="comment">// 可持久化数据结构都是联系自己前一个版本的信息</span></span><br><span class="line">        <span class="comment">//find(a[i]) 就是加入数字离散化下的下标 这里当成这个数字在用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; nums[<span class="built_in">query</span>(root[l - <span class="number">1</span>],root[r],<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>,k)] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="tire"><a href="#tire" class="headerlink" title="tire"></a>tire</h2><p>在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？</p><blockquote><p>字典树的初始化：只需要将0~idx之间的节点初始化即可，时间复杂度为线性</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N=<span class="number">100010</span>,M=<span class="number">31</span>*N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>],idx;</span><br><span class="line"><span class="comment">//M代表一个数字串二进制可以到多长</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;  <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;   <span class="comment">/////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx; <span class="comment">///如果插入中发现没有该子节点,开出这条路</span></span><br><span class="line">        p=son[p][u]; <span class="comment">//指针指向下一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;                               <span class="comment">///从最大位开始找</span></span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u]) <span class="comment">////如果当前层有对应的不相同的数</span></span><br><span class="line">        &#123;   <span class="comment">///p指针就指到不同数的地址</span></span><br><span class="line"></span><br><span class="line">          p=son[p][!u];</span><br><span class="line">          res=res*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">             <span class="comment">///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001</span></span><br><span class="line">        &#125;                                                       <span class="comment">///       010 </span></span><br><span class="line">        <span class="keyword">else</span>                                            <span class="comment">////          ---&gt;011                                                                           //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=son[p][u];</span><br><span class="line">            res=res*<span class="number">2</span>+<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        res=<span class="built_in">max</span>(res,<span class="built_in">search</span>(a[i]));  <span class="comment">///search(a[i])查找的是a[i]值的最大与或值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[N],p[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d%s&quot;</span>,&amp;n,p+<span class="number">1</span>,&amp;m,s+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求ne</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;杂&quot;&gt;&lt;a href=&quot;#杂&quot; class=&quot;headerlink&quot; title=&quot;杂&quot;&gt;&lt;/a&gt;杂&lt;/h1&gt;&lt;h2 id=&quot;运算符优先级&quot;&gt;&lt;a href=&quot;#运算符优先级&quot; class=&quot;headerlink&quot; title=&quot;运算符优先级&quot;&gt;&lt;/a&gt;运算符优先</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习笔记</title>
    <link href="http://1414116846.github.io/1970/01/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://1414116846.github.io/1970/01/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</id>
    <published>1970-01-01T00:00:02.023Z</published>
    <updated>2023-11-02T12:45:59.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="oracle体系架构总览图，必须掌握该图，了如指掌"><a href="#oracle体系架构总览图，必须掌握该图，了如指掌" class="headerlink" title="oracle体系架构总览图，必须掌握该图，了如指掌"></a><a href="https://so.csdn.net/so/search?q=oracle&spm=1001.2101.3001.7020">oracle</a>体系架构总览图，必须掌握该图，了如指掌</h3><p><img src="https://cdn.jsdelivr.net/gh/1414116846/bloglmages@main/C:%5Chexo%5Csource%5Cpicc2b9f6ccd6e549b1b6eac1d4e08dd05a.png"></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="1-Oracle-server"><a href="#1-Oracle-server" class="headerlink" title="1.Oracle server"></a>1.Oracle server</h4><p>一整套软件，是一个<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">数据库</a>管理系统，它为信息管理提供了一种开放、全面、集成的方法;</p><p>包含Instance和<a href="https://so.csdn.net/so/search?q=Database&spm=1001.2101.3001.7020">Database</a>。</p><h4 id="2-Oracle-Instance"><a href="#2-Oracle-Instance" class="headerlink" title="2.Oracle Instance"></a>2.Oracle Instance</h4><ul><li>是访问Oracle数据库的一种方法;</li><li>Instancce由内存和后台进程组成；</li><li>Instance和Database是多对一的关系。</li></ul><h5 id="关键组成："><a href="#关键组成：" class="headerlink" title="关键组成："></a>关键组成：</h5><ol><li><p>后台进程（Background Processes）：这些进程在数据库实例运行期间负责各种后台任务，如数据库恢复、故障监控、日志写入等。其中一些重要的进程包括 SMON、PMON、DBWn、LGWR、CKPT 等。</p></li><li><p>System Global Area (SGA)：SGA 是 Oracle 数据库在共享内存中的部分，用于存储和管理重要的数据结构和缓冲区。SGA 包括数据库缓冲区、共享池、重做日志缓冲区等。SGA 的大小和配置可以通过参数进行管理和调整，以满足系统的需求。</p></li><li><p>数据字典（Data Dictionary）：数据字典是 Oracle 数据库的元数据存储，包含了关于数据库对象（如表、索引、视图等）和用户的描述信息。它提供了对数据库结构的访问和查询。</p></li><li><p>用户进程（User Processes）：用户进程是指连接到数据库的客户端应用程序进程，它们通过网络与数据库实例进行通信，发送 SQL 语句并接收结果。</p></li><li><p>PGA（Program Global Area）：PGA 是每个用户进程或服务器进程的私有内存区域，用于存储并管理特定会话的数据和资源。</p></li></ol><h5 id="进程结构："><a href="#进程结构：" class="headerlink" title="进程结构："></a>进程结构：</h5><ol><li><p>用户进程（User Processes）：简单说就是用户客户端为了连接数据库而存在的进程<img src="https://cdn.jsdelivr.net/gh/1414116846/bloglmages@main/C:%5Chexo%5Csource%5Cpic7975408281e749e489194eb45d269110.png"></p></li><li><p>服务器进程（Server Processes）：服务器进程是 Oracle 数据库中用于处理用户请求的主要执行者。当用户进程发送 SQL 请求时，服务器进程负责解析和执行该请求，访问存储在数据库中的数据，并返回结果给用户进程。服务器进程还负责协调并管理与其他进程之间的通信，如与后台进程的交互和数据传输。<br>IPC&amp;TCP&#x2F;IPIPC是一种在同一主机上的进程之间进行通信的机制TCP&#x2F;IP是一组通信协议，用于在网络上实现进程间通信。</p></li><li><p>后台进程（Background Processes）：后台进程是在数据库实例运行期间负责各种后台任务的特殊进程。这些进程在后台运行，并在数据库管理和维护方面发挥重要作用。</p></li></ol><ul><li><p><img src="https://img-blog.csdnimg.cn/c45063dc6919428eb0b40aa5920c0eb9.png"></p></li><li><p>DBWn：将Database Buffer Cache数据写入Data files</p></li><li><p>LGWR：将<a href="https://so.csdn.net/so/search?q=Redo&spm=1001.2101.3001.7020">Redo</a> Log Buffer数据写入Redo Log files</p></li><li><p>SMON： 清理垃圾</p></li><li><p>PMON：监控各个进程</p></li><li><p>CKPT：检查点进程</p></li><li><p>ARCn：归档进程</p></li></ul><p>比较形象的拿三者打比方，Background Processes是生产线上的工人，User Processes是客户，Server Processes是销售；</p><h4 id="3-Oracle-Database"><a href="#3-Oracle-Database" class="headerlink" title="3.Oracle Database"></a>3.Oracle Database</h4><p>是作为一个单元处理的数据集合；</p><p>由三种文件类型组成（Data files 数据文件，Control files 控制文件，RedoLog files 重做日志文件）</p><ul><li><h5 id="Data-files"><a href="#Data-files" class="headerlink" title="Data files"></a>Data files</h5></li></ul><p>存储数据的文件</p><ul><li><h5 id="Control-files"><a href="#Control-files" class="headerlink" title="Control files"></a>Control files</h5></li></ul><p>为了操作数据文件的文件，主要提供控制信息</p><ul><li><h5 id="RedoLog-files"><a href="#RedoLog-files" class="headerlink" title="RedoLog files"></a>RedoLog files</h5></li></ul><p>记录数据库的改变，用于恢复数据文件</p><ul><li><h5 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h5></li></ul><p>Parameter file 参数文件</p><p>Password file 存储口令的文件</p><p>Archived <a href="https://so.csdn.net/so/search?q=Log&spm=1001.2101.3001.7020">Log</a> files 归档日志文件</p><h5 id="Oracle-database的特点"><a href="#Oracle-database的特点" class="headerlink" title="Oracle database的特点"></a>Oracle database的特点</h5><ol><li><p>可靠性和稳定性：Oracle Database 采用了许多高可用和容错机制，例如故障恢复、数据冗余和备份恢复等，以确保数据的安全性和可靠性。</p></li><li><p>可扩展性：Oracle Database 支持横向和纵向的扩展，可以根据需要增加处理能力和存储容量，以适应不断增长的数据和用户需求。</p></li><li><p>数据安全性：Oracle Database 提供了强大的安全功能，包括用户认证、授权、数据加密和审计等，以保护敏感数据免受未经授权的访问和操作。</p></li><li><p>多模型数据库：除了传统的关系数据库模型，Oracle Database 还支持多种其他数据模型，如空间数据、XML 数据、图形数据和对象数据等，以满足不同类型的数据存储和处理需求。</p></li><li><p>高性能：Oracle Database 优化了查询引擎和数据存储结构，采用了先进的查询优化器和并行处理技术，以实现高效的数据查询和处理性能。</p></li><li><p>数据管理和分析功能：Oracle Database 提供了丰富的数据管理和分析工具，包括数据备份和恢复、数据复制和同步、报表生成和数据挖掘等，使用户能够更好地管理和利用数据。</p></li><li><p>可定制性：Oracle Database 支持存储过程、触发器和自定义函数等可编程对象，并提供了灵活的扩展机制和开发工具，以便用户根据自己的需求进行定制和扩展。</p></li></ol><h4 id="4-Connection-Session-（连接与会话）"><a href="#4-Connection-Session-（连接与会话）" class="headerlink" title="4.Connection &amp; Session （连接与会话）"></a>4.Connection &amp; Session （连接与会话）</h4><p>两者相辅相成</p><p><img src="https://img-blog.csdnimg.cn/ff7a60ff207f40d48a3178461a917391.png"></p><ul><li><h5 id="connection"><a href="#connection" class="headerlink" title="connection"></a>connection</h5></li></ul><p>oracle客户端和后台服务器进程建立的TCP连接。连接表示应用程序或用户与数据库服务器之间的物理连接。通过连接，应用程序可以与数据库建立通信渠道，并发送和接收数据。连接是一种底层的网络通信机制，通常由连接字符串、用户名、密码和数据库服务器地址等信息组成。</p><ul><li><h5 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h5></li></ul><p>会话是一个逻辑概念，表示在数据库中的一段活动期间。在一个连接上，可以创建一个或多个会话，每个会话都对应于一个用户或应用程序与数据库之间的特定工作环境。会话跟踪了特定用户或应用程序的活动和状态，包括变量、临时表和已打开的游标等。一旦会话建立，用户可以通过会话执行 SQL 语句、修改数据和查询数据库等操作。</p><h4 id="5-Memory-Structure"><a href="#5-Memory-Structure" class="headerlink" title="5.Memory Structure"></a>5.Memory Structure</h4><p>主要分为两个结构：SGA,PGA</p><ul><li><h5 id="SGA（System-Global-Area）："><a href="#SGA（System-Global-Area）：" class="headerlink" title="SGA（System Global Area）："></a>SGA（System Global Area）：</h5></li></ul><p>是 Oracle 数据库的内存区域，用于存储数据库实例运行时的重要数据结构和数据缓存。</p><ol><li><p>数据库缓冲区（Database Buffer Cache）：用于存储从磁盘读取的数据块的副本，以提高访问速度。数据库缓冲区主要用于减少磁盘 I&#x2F;O 操作，优化数据访问性能。</p></li><li><p>共享池（Shared Pool）：包括共享 SQL Area 和共享数据字典缓存。共享 SQL Area 存储 SQL 语句的解析树和执行计划等信息，以便共享和重用相同的 SQL 语句。共享数据字典缓存存储数据库对象的元数据（如表、索引、视图等）信息，以提高数据字典访问的效率。</p></li><li><p>重做日志缓冲区（Redo Log Buffer）：用于存储数据库的重做日志，记录数据库操作的详细信息。通过重做日志，Oracle 可以保证数据库的持久性和恢复能力。</p></li><li><p>Java 池（Java Pool）：用于存储 Oracle 数据库中使用 Java 编程语言编写的应用程序的数据和执行环境。</p></li><li><p>大池（Large Pool）：用于存储辅助性数据结构和更大的内存块，如备份和恢复操作期间的临时数据缓存。</p></li></ol><p>查看每个组成部分和大小<br>    select component, granule_size from v$sga_dynamic_components;</p><p><img src="https://img-blog.csdnimg.cn/33234739a875498eb959f18bea4344a6.png"></p><ul><li><h5 id="PGA（Program-Global-Area）："><a href="#PGA（Program-Global-Area）：" class="headerlink" title="PGA（Program Global Area）："></a>PGA（Program Global Area）：</h5></li></ul><p>是 Oracle 数据库的内存区域，用于存储每个用户进程或服务器进程的私有数据和管理相关资源。</p><ol><li><p>排序区域（Sort Area）：用于存储排序操作（如 <code>ORDER BY</code> 或连接操作）生成的临时数据。</p></li><li><p>连接高速缓存（Cursor Cache）：用于存储 SQL 语句的执行计划、解析树和相关元数据信息。这样可以避免对重复 SQL 语句进行解析和优化，提高性能。</p></li><li><p>栈区域（Stack Area）：用于存储每个用户进程或服务器进程的变量、参数和函数调用信息。栈区域是用来管理进程间的通信和执行函数的关键内存区域之一。</p></li><li><p>PL&#x2F;SQL 区域（PL&#x2F;SQL Area）：用于存储 PL&#x2F;SQL 存储过程和函数的字节码和运行时数据。</p></li></ol><h4 id="6-Oracle逻辑结构"><a href="#6-Oracle逻辑结构" class="headerlink" title="6.Oracle逻辑结构"></a>6.Oracle逻辑结构</h4><p><img src="https://img-blog.csdnimg.cn/7e340b687bd24137a1c51b1ce72a4ea0.png"></p><p>一个Oracle server上只有一个database，一个database可以有多个tablespace——一个extent是一些连续的blocks</p><h2 id="DBA工具"><a href="#DBA工具" class="headerlink" title="DBA工具"></a>DBA工具</h2><h3 id="1-Oracle-Universal-Installer（OUI）"><a href="#1-Oracle-Universal-Installer（OUI）" class="headerlink" title="1.Oracle Universal Installer（OUI）"></a>1.<a href="https://so.csdn.net/so/search?q=Oracle&spm=1001.2101.3001.7020">Oracle</a> Universal Installer（OUI）</h3><ul><li><p>用于安装、升级或移除软件组件</p></li><li><p>基于Java引擎</p></li><li><p>功能包括：</p></li></ul><ol><li><p>自动依赖解析</p></li><li><p>网络安装跟踪</p></li><li><p>库存管理</p></li><li><p>卸载已安装组件</p></li><li><p>多个Oracle Home 支持</p></li><li><p>全球化技术支持</p></li></ol><ul><li>交互式启动OUI</li></ul><p>UNIX：<br>    .&#x2F;runInstaller</p><p>NT：</p><p>Start &gt; Programs &gt; Oracle Installation &gt; Products &gt; Universal Installer</p><ul><li>非交互式安装</li></ul><p> </p><p>事先准备响应文件myrespfile<br>    .&#x2F;runInstaller -responsefile myrespfile -silent</p><h3 id="2-Oracle-Database-Configuration（DBCA）"><a href="#2-Oracle-Database-Configuration（DBCA）" class="headerlink" title="2.Oracle Database Configuration（DBCA）"></a>2.Oracle Database Configuration（DBCA）</h3><p>与OUI交互的<a href="https://so.csdn.net/so/search?q=%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2&spm=1001.2101.3001.7020">图形用户界面</a>工具，或者可以独立使用，以创建、删除或修改数据库</p><h4 id="数据库管理员用户"><a href="#数据库管理员用户" class="headerlink" title="数据库管理员用户"></a>数据库管理员用户</h4><ul><li><h5 id="系统会自动创建“SYS”和“SYSTEM”用户"><a href="#系统会自动创建“SYS”和“SYSTEM”用户" class="headerlink" title="系统会自动创建“SYS”和“SYSTEM”用户"></a>系统会自动创建“SYS”和“SYSTEM”用户</h5></li></ul><p>在<a href="https://so.csdn.net/so/search?q=%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">创建数据库</a>期间,授予DBA角色</p><ul><li><h5 id="User-SYS"><a href="#User-SYS" class="headerlink" title="User SYS"></a>User SYS</h5></li></ul><p>数据库数据字典的所有者</p><ul><li><h5 id="User-SYSTEM"><a href="#User-SYSTEM" class="headerlink" title="User SYSTEM"></a>User SYSTEM</h5></li></ul><p>Oracle工具使用的其他内部表和视图的所有者</p><h3 id="3-SQL-Plus"><a href="#3-SQL-Plus" class="headerlink" title="3.SQL*Plus"></a><u>3.SQL*Plus</u></h3><ul><li>Oracle工具提供:</li></ul><p>与数据库交互和操作的能力</p><p>能够启动和关闭数据库、创建和运行查询、添加行、修改数据和编写自定义报告</p><ul><li><p>具有特定附加组件的标准SQL语言的子集</p></li><li><p>连接到SQL*Plus:<br>sqlplus &#x2F;nologconnect &#x2F; as sysdbastartup</p></li></ul><h3 id="4-Oracle-Enterprise-Manager（了解）"><a href="#4-Oracle-Enterprise-Manager（了解）" class="headerlink" title="4.Oracle Enterprise Manager（了解）"></a>4.Oracle Enterprise Manager（了解）</h3><ul><li>作为dba的集中式系统管理工具</li><li>用于管理、诊断和调优多个数据库的工具</li><li>用于管理来自多个位置的多个网络节点和服务的工具</li><li>用于与其他管理员共享任务</li><li>提供用于管理并行服务器和复制数据库的工具</li></ul><h2 id="初始化参数文件"><a href="#初始化参数文件" class="headerlink" title="初始化参数文件"></a><a href="https://so.csdn.net/so/search?q=%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0&spm=1001.2101.3001.7020">初始化参数</a>文件</h2><p>初始化参数文件是<a href="https://so.csdn.net/so/search?q=Oracle&spm=1001.2101.3001.7020">Oracle</a>数据库启动时使用的配置文件，分显式和隐式两种，它包含了数据库实例的各种参数设置。初始化参数文件可以是PFILE（文本文件）或SPFILE（二进制文件），它们定义了数据库实例的行为、内存分配、并发处理、日志记录等方面的设置。</p><p><img src="https://img-blog.csdnimg.cn/18d0987cf579475d91a4462fa207bab1.png"></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="PFILE"><a href="#PFILE" class="headerlink" title="PFILE"></a>PFILE</h3><p>文本文件，使用操作系统编辑器修改，手动修改</p><p>更改将在下次启动时生效，只在实例启动时打开</p><p>默认位置为“$ORACLE_HOME&#x2F;dbs”</p><h4 id="创建一个PFILE"><a href="#创建一个PFILE" class="headerlink" title="创建一个PFILE"></a>创建一个PFILE</h4><p>从示例init.ora文件创建</p><blockquote><p>由Oracle Universal Installer安装的示例</p><p>使用操作系统复制命令复制示例</p><p>由<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">数据库</a>SID唯一标识</p></blockquote><pre><code>cp init.ora $ORACLE_HOME/dbs/initdba01.ora</code></pre><h4 id="修改initSID-ora"><a href="#修改initSID-ora" class="headerlink" title="修改initSID.ora"></a>修改initSID.ora</h4><p>修改 “initsid.ora” 文件是更改 Oracle 数据库实例的初始化参数的方法之一。以下是修改过程的一般步骤：</p><ol><li><p>找到 “initsid.ora” 文件：该文件通常位于 $ORACLE_HOME&#x2F;dbs 目录中，其中 “sid” 是数据库实例的标识符。例如，如果实例名为 “ORCL”，则文件路径为 $ORACLE_HOME&#x2F;dbs&#x2F;initorcl.ora。</p></li><li><p>备份原始文件：在进行任何修改之前，强烈建议先备份原始的 “initsid.ora” 文件，以便在需要时进行恢复。</p></li><li><p>使用文本编辑器打开 “initsid.ora” 文件：可以使用任何文本编辑器（如记事本、Vi、Nano等）打开文件。</p></li><li><p>修改参数值：在打开的文件中，找到相应的参数行，并更改其值。参数行通常采用 “参数名&#x3D;值” 的形式。</p></li><li><p>保存文件：在完成参数修改后，保存 “initsid.ora” 文件。</p></li><li><p>重启数据库实例：要使参数修改生效，需要重启对应的数据库实例。可以使用 SQL*Plus 或 Oracle Enterprise Manager 等工具，或者使用命令行执行 “shutdown” 和 “startup” 命令来重启实例。</p></li></ol><blockquote><p>注意，修改 “initsid.ora” 文件是一项敏感任务，错误的参数设置可能会导致数据库实例无法启动或运行异常。因此，在修改之前，请确保对各个参数的含义和取值范围有一定的了解，并仔细验证和测试修改的效果。</p></blockquote><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="SPFILE"><a href="#SPFILE" class="headerlink" title="SPFILE"></a>SPFILE</h3><p>SPFILE是Oracle数据库系统中的一个服务器参数文件，</p><p>它类似于PFILE，但与PFILE不同的是SPFILE是一个二进制文件而非纯文本文件。</p><p>SPFILE中包含了数据库实例的配置和初始化参数。</p><h4 id="创建一个SPFILE"><a href="#创建一个SPFILE" class="headerlink" title="创建一个SPFILE"></a>创建一个SPFILE</h4><ul><li>从PFILE文件创建<br>CREATE SPFILE &#x3D; ‘$ORACLE_HOME&#x2F;dbs&#x2F;spfileDBA01.ora’FROM PFILE &#x3D; ‘$ORACLE_HOME&#x2F;dbs&#x2F;initDBA01.ora’;</li></ul><blockquote><p>位置</p><p>SPFILE- NAME：要创建的SPFILE</p><p>PFILE- NAME：创建SPFILE的PFILE</p></blockquote><ul><li>可以在实例启动之前或之后执行</li></ul><h4 id="修改spfileSID-ora"><a href="#修改spfileSID-ora" class="headerlink" title="修改spfileSID.ora"></a>修改spfileSID.ora</h4><p> spfileSID.ora 文件无法直接编译，因为它是一个二进制文件。如果需要修改其中的参数值，应使用 ALTER SYSTEM 命令。</p><h5 id="以下是修改-spfileSID-ora-的一般步骤："><a href="#以下是修改-spfileSID-ora-的一般步骤：" class="headerlink" title="以下是修改 spfileSID.ora 的一般步骤："></a>以下是修改 spfileSID.ora 的一般步骤：</h5><ol><li><p>备份原始文件：在修改之前，请务必备份原始的 spfileSID.ora 文件，以便在需要时进行恢复。</p></li><li><p>使用 SQL*Plus 连接到数据库实例：打开命令行窗口，使用适当的凭据连接到目标数据库实例。</p></li><li><p>检查当前的 SPFILE 设置：使用以下命令检查当前正在使用的 SPFILE 设置：<br>SHOW PARAMETER spfile;</p></li><li><p>修改参数值：使用 ALTER SYSTEM 命令修改参数值。例如，要将 my_parameter 参数的值更改为 new_value，可以执行以下命令：<br>ALTER SYSTEM SET my_parameter&#x3D;’new_value’ SCOPE&#x3D;SPFILE;</p></li><li><p>保存修改：重新<a href="https://so.csdn.net/so/search?q=%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">启动数据库</a>实例，以便新的参数设置生效。<br>SHUTDOWN IMMEDIATE;STARTUP;</p></li></ol><h6 id="更加详细的说明修改PFILE"><a href="#更加详细的说明修改PFILE" class="headerlink" title="更加详细的说明修改PFILE"></a>更加详细的说明修改PFILE</h6><pre><code>Alter system set parameter=value &lt;comment=&#39;text&#39;&gt; &lt;deferred&gt; &lt;scope=memory|spfile|both&gt; &lt;sid=&#39;sid|*&#39;&gt;</code></pre><ul><li>parameter: 要修改的参数名称。</li><li>value: 新的参数值。</li><li>COMMENT&#x3D;‘text’ (可选): 可以添加对参数修改的注释。</li><li>DEFERRED (可选): 如果使用 DEFERRED 关键字，参数修改将被延迟到下一次数据库实例启动时才生效。</li><li>SCOPE&#x3D;MEMORY|SPFILE|BOTH (可选): 指定参数的生命周期范围。可选的值有：MEMORY（仅在内存中修改，需要重新启动实例才生效）、SPFILE（修改并保存到服务器参数文件，需要重启实例才生效）和 BOTH（修改并保存到服务器参数文件和内存，需要重启实例才生效）。</li><li>SID&#x3D;‘sid|_’ (可选): 指定要修改的数据库实例的 SID。默认情况下，参数修改将应用于当前实例。使用 ‘_’ 表示对所有实例生效。</li></ul><blockquote><p>注意，SPFILE 是一个二进制文件，直接编辑会导致文件损坏。因此，如果需要修改其中的参数值，请使用 ALTER SYSTEM 命令，并按照上述步骤进行操作。</p></blockquote><h3 id="SPFILE-vs-PFILE"><a href="#SPFILE-vs-PFILE" class="headerlink" title="SPFILE vs PFILE"></a>SPFILE vs PFILE</h3><p>1.SPFILE可以被RMAN备份(RMAN不能备份PFILEs)；</p><ol start="2"><li>减少人为错误，SPFILE由服务器维护，在接受更改之前检查参数；</li></ol><p>3.消除配置问题(如果您想从数据库启动Oracle，则无需使用本地PFILE远程机械）；</p><ol start="4"><li>容易找到位置存储在一个集中位置。</li></ol><blockquote><p>SPFILE比PFILE好!</p><p>尽量用SPFILE</p></blockquote><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h2 id="Oracle数据库启动"><a href="#Oracle数据库启动" class="headerlink" title="Oracle数据库启动"></a>Oracle数据库启动</h2><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="启动命令行为"><a href="#启动命令行为" class="headerlink" title="启动命令行为"></a>启动命令行为</h3><h4 id="优先顺序"><a href="#优先顺序" class="headerlink" title="优先顺序"></a>优先顺序</h4><ul><li>spfileSID.ora</li><li>Default SPFILE &gt; spfile.ora</li><li>initSID.ora</li><li>Default PFILE &gt; ???</li></ul><h4 id="指定的PFILE可以覆盖优先级"><a href="#指定的PFILE可以覆盖优先级" class="headerlink" title="指定的PFILE可以覆盖优先级"></a>指定的PFILE可以覆盖优先级</h4><pre><code>STARTUP PFILE = $ORACLE_HOME/dbs/initDBA1.ora</code></pre><h4 id="PFILE可以指示使用SPFILE"><a href="#PFILE可以指示使用SPFILE" class="headerlink" title="PFILE可以指示使用SPFILE"></a>PFILE可以指示使用SPFILE</h4><pre><code>SPFILE = /database/stsrtup/spfileDBA.ora</code></pre><h3 id="谁可以启动DB"><a href="#谁可以启动DB" class="headerlink" title="谁可以启动DB?"></a>谁可以启动DB?</h3><p>数据库启动和关闭是功能强大的管理选项，仅限于具有管理员权限连接到Oracle数据库的用户。根据操作系统的不同，以下条件之一可以为用户建立管理员权限：</p><ul><li>用户的操作系统权限允许他或她使用管理员权限进行连接。</li><li>该用户被授予SYSDBA或SYSOPER权限，数据库使用密码文件对数据库管理员进行身份验证。</li></ul><p>当您使用SYSDBA权限进行连接时，您处于SYS所拥有的模式中。当您以SYSOPER身份连接时，您处于公共模式中。SYSOPER权限区域是SYSDBA权限的子集（SYSDBA比SYSOPER牛*）。</p><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="数据库启动的过程："><a href="#数据库启动的过程：" class="headerlink" title="数据库启动的过程："></a>数据库启动的过程：</h3><p>startup</p><p>———————————-&gt;</p><p>Control file opened for this instance</p><p>          |</p><p>shutdown———————&gt;nomount————–&gt;mount————————-&gt;open</p><p>|                                                                         |</p><p>instance started                                    All files opened as described by</p><p>                                                          the control file for this instance</p><p>&lt;————————————</p><p>shutdown</p><h4 id="Instance如何started"><a href="#Instance如何started" class="headerlink" title="Instance如何started"></a>Instance如何started</h4><pre><code>startup nomount</code></pre><p>当Oracle数据库启动一个实例时，它会读取服务器参数文件(SPFILE)或初始化参数文件，以确定初始化参数的值。然后，它分配一个SGA，这是一个用于数据库信息的共享内存区域，并创建后台进程。此时，没有数据库与这些内存结构和进程相关联。</p><p>当实例启动时，数据库以有效的参数语法将所有显式参数设置写入日志日志。如果需要，您可以将日志文件调出来恢复，然后重新启动实例。</p><h4 id="DB怎么被Mounted"><a href="#DB怎么被Mounted" class="headerlink" title="DB怎么被Mounted"></a>DB怎么被Mounted</h4><pre><code>alter database mount;</code></pre><p>实例挂载数据库以将数据库与该实例关联。要挂载数据库，实例找到数据库控制文件并打开它们。控制文件在用于启动实例的参数文件中的CONTROL_FILES初始化参数中指定。然后，Oracle数据库读取控制文件，以获得数据库的数据文件和重做日志文件的名称。</p><p>此时，数据库仍处于关闭状态，只有数据库管理员可以访问。数据库管理员可以在完成特定维护操作时保持数据库关闭状态。但是，该数据库还不能用于正常操作。</p><h4 id="DB怎样Opened"><a href="#DB怎样Opened" class="headerlink" title="DB怎样Opened"></a>DB怎样Opened</h4><pre><code>alter database open;</code></pre><p>打开挂载的数据库使其可用于正常的数据库操作。任何有效的用户都可以连接到开放的数据库并访问其信息。通常，数据库管理员打开数据库以使其可供一般使用。</p><p>当您打开数据库时，Oracle数据库会打开在线数据文件（datafiles）和重做日志文件（redo log files）。如果在数据库之前关闭时表空间处于离线状态，那么在重新打开数据库时，表空间及其对应的数据文件仍将处于离线状态。</p><p>当您试图打开数据库时，如果其中任何一个数据文件或重做日志文件不存在，那么Oracle数据库将报错。在打开数据库之前，必须对任何损坏或丢失的文件的备份执行恢复。</p><h3 id="START-命令"><a href="#START-命令" class="headerlink" title="START 命令"></a>START 命令</h3><p>启动实例并打开数据库<br>    STARTUP</p><pre><code>STARTUP PFILE=$ORACLE_HOME/dbs/initdb01.oraSTARTUP [FORCE] [RESTRICT] [NOMOUNT] [MIGRATE] [QUIET] [PFILE=&lt;file_name&gt;] [MOUNT [EXCLUSIVE] &lt;database_name&gt;x | OPEN &lt;READ &#123;ONLY | WRITE [RECOVER]&#125; | RECOVER&gt; &lt;database_name&gt;]</code></pre><blockquote><p>Oracle 数据库中 STARTUP 命令的各个选项进行解释：</p><ul><li><p>STARTUP：启动数据库实例，默认情况下会尝试进行自动恢复和打开数据库。</p></li><li><p>FORCE（可选）：强制启动数据库实例，忽略任何潜在的冲突或锁定。请谨慎使用该选项。</p></li><li><p>RESTRICT（可选）：以受限模式启动数据库实例，只有具有 RESTRICTED SESSION 特权的用户可连接。这可以限制普通用户的访问权限，通常用于执行数据库维护任务。</p></li><li><p>NOMOUNT（可选）：在不加载数据库实例的情况下启动实例。使用 NOMOUNT 选项，数据库实例只加载 SGA，并不打开或挂载数据库。</p></li><li><p>MIGRATE（可选）：启动一个旧版本数据库实例，并自动将其升级到当前版本。该选项通常在升级数据库时使用。</p></li><li><p>QUIET（可选）：以安静模式启动数据库实例，只输出最重要的消息。</p></li><li><p>PFILE&#x3D;<file_name>（可选）：指定使用指定的 pfile 参数文件来启动数据库实例。</p></li><li><p>MOUNT（可选）：将数据库实例挂载到内存中，但不打开数据库。实例处于 “mounted” 状态，可以执行与数据文件和控制文件相关的操作。</p></li><li><p>EXCLUSIVE（可选）：要求以独占模式挂载数据库实例。只有一个实例能够以独占模式挂载数据库。</p></li><li><p><database_name>：要启动的数据库名称。</p></li><li><p>OPEN &lt;READ {ONLY | WRITE [RECOVER]}&gt;：打开数据库实例并指定访问权限。READ ONLY 以只读模式打开数据库，WRITE 以读写模式打开数据库，RECOVER 允许进行数据库恢复操作。</p></li></ul></blockquote><h4 id="ALTER-DATABASE-命令"><a href="#ALTER-DATABASE-命令" class="headerlink" title="ALTER DATABASE 命令"></a>ALTER DATABASE 命令</h4><ul><li><p>将数据库的状态从NOMOUNT修改为MOUNT(不可逆):<br>ALTER DATABASE db01 MOUNT;</p></li><li><p>以只读数据库的方式打开数据库:<br>ALTER DATABASE db01 OPEN READ OMLY;</p></li></ul><h4 id="受限模式"><a href="#受限模式" class="headerlink" title="受限模式"></a>受限模式</h4><p>使用STARTUP命令限制对数据库的访问（DB未启动）:<br>    STARTUP RESTRUCT</p><p>使用ALTER SYSTEM命令将实例置于受限模式（DB启动后）:<br>    ALTER SYSTEM ENABLE RESTRICTED SESSION</p><h4 id="只读模式"><a href="#只读模式" class="headerlink" title="只读模式"></a>只读模式</h4><p>以只读的模式打开数据库<br>    STARTUP MOUNTALTER DATABASE OPEN READ ONLY;</p><blockquote><p>可用于:</p><p>执行查询</p><p>使用本地管理的表空间执行磁盘排序</p><p>将数据文件离线和在线，但不包括表空间</p><p>执行离线数据文件和表空间的恢复</p></blockquote><h2 id="数据库关闭"><a href="#数据库关闭" class="headerlink" title="数据库关闭"></a>数据库关闭</h2><ul><li>Close a Database</li></ul><p>关闭数据库时，Oracle将SGA中的所有数据库数据和恢复数据分别写入数据文件和重做日志文件中。接下来，Oracle数据库关闭所有在线数据文件和重做日志文件。(任何离线表空间的任何离线数据文件都已关闭。如果随后重新打开数据库，则脱机的表空间及其数据文件将分别保持脱机和关闭状态。)此时，数据库处于关闭状态，无法进行正常操作。关闭数据库后，控制文件保持打开状态，但仍然挂载。</p><ul><li>Unmount a Database</li></ul><p>关闭数据库后，Oracle数据库卸载数据库以解除与实例的关联。此时，实例保留在计算机的内存中。</p><p>卸载数据库后，Oracle数据库将关闭该数据库的控制文件。</p><ul><li>Shut Down an Instance</li></ul><p>数据库关闭的最后一步是关闭实例。当您关闭一个实例时，SGA将从内存中删除，后台进程将终止。</p><h3 id="Shutdown-mode："><a href="#Shutdown-mode：" class="headerlink" title="Shutdown mode："></a>Shutdown mode：</h3><ul><li>A&#x3D;ABORT：立即中止数据库的运行，当前正在进行的事务将被回滚，没有事务提交的机会。在数据库被中止之后，需要进行恢复操作才能重新打开数据库。</li><li>I&#x3D;IMMEDIATE：立即中止数据库的运行，当前正在进行的事务将被回滚，没有事务提交的机会。在数据库被中止之后，需要进行恢复操作才能重新打开数据库。</li><li>T&#x3D;TRANSACTIONAL：等待所有事务提交后关闭数据库。这种模式会等待当前正在执行的事务提交后，再关闭数据库。对于具有长时间运行事务的数据库，可能需要花费较长时间。</li><li>N&#x3D;NORMAL：类似于 TRANSACTIONAL 模式，等待所有事务提交后关闭数据库。不同之处在于，如果在一段时间内没有事务活动，则自动触发关闭操作。</li></ul><p><img src="https://img-blog.csdnimg.cn/3a2bbf1030c84408a929277852545b24.png"></p><blockquote><p>干净的关闭：</p><p>SHUTDOWN NORMAL</p><p>or</p><p>SHUTDOWN TRANSACTIONAL</p><p>or</p><p>SHUTDOWN IMMEDIATE(常用)</p></blockquote><blockquote><p>不干净的关闭：</p><p>SHUTDOWN ABORT(迫不得已)</p><p>or</p><p>Instance Failure</p><p>or</p><p>STARTUP FORCE</p></blockquote><h2 id="诊断文件（日志文件）"><a href="#诊断文件（日志文件）" class="headerlink" title="诊断文件（日志文件）"></a>诊断文件（日志文件）</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>包含遇到的重要事件信息</p><p>用来解决问题</p><p>用于更好地管理数据库的日常基础</p><h3 id="有几种类型"><a href="#有几种类型" class="headerlink" title="有几种类型:"></a>有几种类型:</h3><h4 id="Alert-Log-File（日志警告文件）"><a href="#Alert-Log-File（日志警告文件）" class="headerlink" title="Alert Log File（日志警告文件）"></a>Alert Log File（日志警告文件）</h4><ul><li>alertSID.log文件:</li></ul><blockquote><p>记录命令</p><p>记录重要事件的结果</p><p>用于日常操作信息</p><p>用于诊断数据库错误</p></blockquote><ul><li>每个条目都有一个与之关联的时间戳</li><li>必须由DBA管理</li><li>由BACKGROUND_DUMP_DEST定义的位置</li></ul><h4 id="Background-Trace-Files（后台跟踪文件）"><a href="#Background-Trace-Files（后台跟踪文件）" class="headerlink" title="Background Trace Files（后台跟踪文件）"></a>Background Trace Files（后台跟踪文件）</h4><ul><li>后台跟踪文件</li></ul><blockquote><p>记录任何后台进程检测到的错误</p><p>用于诊断和排除错误</p></blockquote><ul><li>当后台进程遇到错误时创建</li><li>由BACKGROUND_DUMP_DEST定义的位置</li></ul><h4 id="User-Trace-Files（用户跟踪文件）"><a href="#User-Trace-Files（用户跟踪文件）" class="headerlink" title="User Trace Files（用户跟踪文件）"></a>User Trace Files（用户跟踪文件）</h4><ul><li>用户跟踪文件</li></ul><blockquote><p>由用户进程生成</p><p>可以由服务器进程生成吗</p><p>包含跟踪SQL语句的统计信息</p><p>包含用户错误消息</p></blockquote><ul><li>当用户遇到用户会话错误时创建</li><li>位置由USER_DUMP_DEST定义</li><li>由MAX_DUMP_FILE_SIZE定义的大小</li></ul><h5 id="启用-禁用-User-Tracing"><a href="#启用-禁用-User-Tracing" class="headerlink" title="启用&#x2F;禁用 User Tracing"></a>启用&#x2F;禁用 User Tracing</h5><h6 id="会话层"><a href="#会话层" class="headerlink" title="会话层:"></a>会话层:</h6><p>使用ALTER SESSION命令（建议）:<br>    ALTER SESSION SET SQL_TRACE &#x3D; TRUE</p><p>执行DBMS程序:<br>    dbms_system.SET_SQL_TRACE_IN_SESSION</p><h6 id="实例级"><a href="#实例级" class="headerlink" title="实例级"></a>实例级</h6><p>设置初始化参数（不建议）:<br>    SQL_TRACE &#x3D; TRUE</p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>Background trace files————-&gt;SID_processname_PID.trc</p><p>User trace files———————–&gt;SID_ora_PID.trc</p><h2 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h2><p>列出<a href="https://so.csdn.net/so/search?q=%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">创建数据库</a>所需的先决条件。</p><p>使用Oracle <a href="https://so.csdn.net/so/search?q=database&spm=1001.2101.3001.7020">database</a> Configuration Assistant创建数据库</p><p>手动创建数据库</p><p>使用Oracle Managed Files创建数据库</p><h3 id="规划和组织数据库"><a href="#规划和组织数据库" class="headerlink" title="规划和组织数据库"></a>规划和组织数据库</h3><p>1.规划数据库是管理数据库系统的第一步。</p><ul><li>定义数据库的用途。</li><li>定义数据库的类型。</li><li>概述数据库体系结构设计。</li><li>选择数据库名称。</li></ul><p>2.创建数据库。</p><p>3.使用Oracle数据迁移助手从较早版本的数据库迁移。</p><h3 id="OFA规范（Optimal-Flexible-Arch）"><a href="#OFA规范（Optimal-Flexible-Arch）" class="headerlink" title="OFA规范（Optimal Flexible Arch）"></a>OFA规范（Optimal Flexible Arch）</h3><p>Oracle推荐的标准数据库架构布局</p><p>OFA包括三个主要规则:</p><p>建立一个目录结构，其中任何数据库文件都可以存储在任何磁盘资源上。</p><p>将具有不同行为的对象分离到不同的表空间中。</p><p>通过跨不同磁盘资源分离数据库组件来最大化数据库可靠性和性能。</p><h3 id="软件和文件位置"><a href="#软件和文件位置" class="headerlink" title="软件和文件位置"></a>软件和文件位置</h3><p>Software</p><blockquote><p>oracle_base</p><p>        &#x2F;product</p><p>                &#x2F;release_number</p><p>                        &#x2F;bin</p><p>                        &#x2F;dbs</p><p>                        &#x2F;rdbms</p><p>                        &#x2F;sqlplus</p><p>&#x2F;admin</p><p>        &#x2F;inst_name</p><p>&#x2F;pfile</p></blockquote><p>Files</p><blockquote><p>oradata&#x2F;</p><p>        db01&#x2F;</p><p>                system01.dbf</p><p>                control01.ctl</p><p>                redo0101.log</p><p>                ……</p><p>        db02&#x2F;</p><p>                system01.dbf</p><p>                control01.ctl</p><p>                redo0101.log</p><p>                ……</p></blockquote><h3 id="创造先决条件"><a href="#创造先决条件" class="headerlink" title="创造先决条件"></a>创造先决条件</h3><p>要创建一个新数据库，必须具备以下条件</p><p>1.通过以下认证的特权帐户:</p><blockquote><p>操作系统</p><p>密码文件</p></blockquote><p>2.启动实例所需的足够内存</p><p>3.为规划的数据库提供足够的磁盘空间</p><p>身份验证方式</p><p><img src="https://img-blog.csdnimg.cn/4e6047bc1c2a4c9eacbf853960b21513.png"></p><p>密码文件认证</p><p>使用password utility创建password file。<br>    $ orapwd file&#x3D;$ORACLE_HOME&#x2F;dbs&#x2F;orapwU15 password&#x3D;admin entries&#x3D;5</p><p>设置REMOTE LOGIN PASSWORDFILE&#x3D;EXCLUSIVE in</p><p>初始化参数文件。</p><p>在密码文件中添加用户。</p><p>为每个用户分配适当的权限。<br>    GRANT SYSDBA TO HR;</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p><a href="https://so.csdn.net/so/search?q=Oracle%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">Oracle数据库</a>可以通过以下方式创建:</p><ul><li>Oracle Universal Installer</li><li>Oracle Database Configuration Assistant（DBCA）</li></ul><blockquote><p>图形用户界面</p><p>基于java的</p><p>由Oracle通用安装程序启动</p><p>可以作为独立应用程序使用 </p></blockquote><ul><li>CREATE DATABASE命令</li></ul><h4 id="DBCA创建数据库"><a href="#DBCA创建数据库" class="headerlink" title="DBCA创建数据库"></a>DBCA创建数据库</h4><h5 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h5><ol><li><p>打开终端或命令提示符，并使用 <code>dbca</code> 命令启动 DBCA。</p></li><li><p>在 DBCA 的界面中，选择 “创建数据库” 选项并点击 “下一步”。</p></li><li><p>选择 “自定义数据库创建” 选项，并点击 “下一步”。</p></li><li><p>在 “数据库标识” 页面上，输入数据库的全局数据库名称和 SID (System Identifier)。选择合适的字符集和语种，并点击 “下一步”。</p></li><li><p>在 “系统类” 页面上，选择适合你的数据库类型和版本，并点击 “下一步”。</p></li><li><p>在 “数据库存储” 页面上，选择数据库的存储类型（例如文件系统或 ASM），并填写相关的存储选项。点击 “下一步”。</p></li><li><p>在 “管理选项” 页面上，选择是否启用自动管理，以及是否配置备份和恢复选项。点击 “下一步”。</p></li><li><p>在 “数据库信息” 页面上，输入管理员用户 (例如SYS) 的密码，并选择是否配置其他数据库的创建选项。点击 “下一步”。</p></li><li><p>在 “网络配置” 页面上，选择监听器的配置选项，并输入监听器的端口号。点击 “下一步”。</p></li><li><p>在 “创建选项” 页面上，确认你的数据库创建选项，并点击 “完成”。</p></li><li><p>DBCA 将开始创建数据库，并在完成后显示 “数据库创建完成” 的消息。</p></li></ol><h5 id="操作系统环境："><a href="#操作系统环境：" class="headerlink" title="操作系统环境："></a>操作系统环境：</h5><ul><li>ORACLE_BASE</li><li>ORACLE_HOME</li><li>ORACLE_SID</li><li>ORA_NLS33</li><li>PATH</li><li>LD_LIBRARY_PATH</li></ul><h5 id="使用DBCA可以"><a href="#使用DBCA可以" class="headerlink" title="使用DBCA可以:"></a>使用DBCA可以:</h5><ul><li>创建数据库</li><li>配置数据库选项</li><li>删除数据库</li><li>管理模板</li></ul><blockquote><p>使用预定义的模板设置创建新模板</p><p>从现有数据库创建新模板删除数据库模板</p></blockquote><h4 id="手动创建DB"><a href="#手动创建DB" class="headerlink" title="手动创建DB"></a><strong>手动创建DB</strong></h4><ul><li>选择唯一的实例和数据库名称</li><li>选择数据库字符集</li><li>设置操作系统变量</li><li>创建初始化参数文件</li><li>在NOMOUNT阶段启动实例并执行</li><li>Create DATABASE命令</li><li>运行脚本生成数据字典并完成创建后的步骤</li><li>根据需要创建额外的表空间</li></ul><h5 id="步骤1-指定实例标识符-SID"><a href="#步骤1-指定实例标识符-SID" class="headerlink" title="步骤1:指定实例标识符(SID)"></a>步骤1:指定实例标识符(SID)</h5><p>为您的实例确定一个唯一的Oracle系统标识符(SID)，打开命令窗口，设置ORACLE_SID环境变量。使用此命令窗口执行后续步骤。</p><p>ORACLE_SID用于将此实例与其他可能在同一主机上并发运行的Oracle数据库实例区分开来。ORACLE_SID的最大字符数为12，只允许输入字母和数字。在某些平台上，SID是区分大小写的。</p><blockquote><p>注意:通常的做法是将SID设置为等于数据库名称。数据库名称的最大字符数为8个。要了解更多信息，请参见Oracle数据库参考中关于DB_NAME初始化参数的讨论。</p></blockquote><h5 id="步骤2-确保设置了所需的环境变量"><a href="#步骤2-确保设置了所需的环境变量" class="headerlink" title="步骤2:确保设置了所需的环境变量"></a>步骤2:确保设置了所需的环境变量</h5><p>例如，大多数平台必须设置“ORACLE_SID”和“ORACLE_HOME”。另外，建议将PATH变量设置为包含ORACLE_HOME&#x2F;bin目录。在UNIX和Linux平台上，必须手动设置这些环境变量。在Windows平台上，OUI会自动在Windows注册表中为ORACLE_HOME和ORACLE_SID赋值。如果您没有在安装时创建数据库，那么OUI不会在注册表中设置ORACLE_SID，并且您必须在以后创建数据库时设置ORACLE_SID环境变量。</p><h6 id="环境变量："><a href="#环境变量：" class="headerlink" title="环境变量："></a>环境变量：</h6><ul><li>ORACLE_BASE</li><li>ORACLE_HOME</li><li>ORACLE_SID</li><li>ORA_NLS33</li><li>PATH</li><li>LD_LIBRARY_PATH</li></ul><h5 id="步骤3-选择数据库管理员身份验证方法"><a href="#步骤3-选择数据库管理员身份验证方法" class="headerlink" title="步骤3:选择数据库管理员身份验证方法"></a>步骤3:选择数据库管理员身份验证方法</h5><p>您必须通过身份验证并被授予适当的系统特权才能创建数据库。您可以通过以下方式验证管理员的权限:</p><ul><li>使用密码文件</li><li>具有操作系统身份验证</li></ul><p>在此步骤中，您将决定一种身份验证方法。</p><blockquote><p>如果您选择使用密码文件进行认证，请参考“创建并维护密码文件”创建密码文件。如果您决定使用操作系统身份验证进行身份验证，请确保使用属于相应操作系统用户组的用户帐户登录到主机。例如，在UNIX和Linux平台上，这通常是dba用户组。在Windows操作系统下，安装Oracle软件的用户会被自动归入相应的用户组。</p></blockquote><h5 id="步骤4-创建初始化参数文件（pfile）"><a href="#步骤4-创建初始化参数文件（pfile）" class="headerlink" title="步骤4:创建初始化参数文件（pfile）"></a>步骤4:创建初始化参数文件（pfile）</h5><p>当Oracle实例启动时，它会读取一个初始化参数文件。该文件可以是一个文本文件(可以使用文本编辑器创建和修改)，也可以是一个二进制文件(由数据库创建和动态修改)。首选的二进制文件称为服务器参数文件（spfile）。在这一步中，您将创建一个文本初始化参数文件。在后面的步骤中，将从文本文件创建服务器参数文件。</p><p>为方便起见，请使用默认文件名将初始化参数文件存储在Oracle数据库的默认位置。这样，在启动数据库时，就不需要指定STARTUP命令的PFILE子句，因为Oracle数据库会自动在默认位置查找初始化参数文件。</p><h5 id="步骤5-连接到实例"><a href="#步骤5-连接到实例" class="headerlink" title="步骤5:连接到实例"></a>步骤5:连接到实例</h5><p>启动SQL*Plus并以SYSDBA系统权限连接到Oracle数据库实例。</p><p>使用密码文件进行认证，输入以下命令，并在提示时输入SYS密码:<br>    $ sqlplus &#x2F;nologSQL&gt; CONNECT SYS AS SYSDBA</p><p>使用操作系统身份验证，输入如下命令:<br>    $ sqlplus &#x2F;nologSQL&gt; CONNECT &#x2F; AS SYSDBA</p><p>SQL*Plus输出以下消息:<br>    Connected to an idle instance</p><h5 id="步骤6-创建SPFILE（可选）"><a href="#步骤6-创建SPFILE（可选）" class="headerlink" title="步骤6:创建SPFILE（可选）"></a>步骤6:创建SPFILE（可选）</h5><p>服务器参数文件使您能够使用ALTER SYSTEM命令更改初始化参数，并在数据库关闭和启动期间持久化更改。从编辑过的文本初始化文件创建服务器参数文件。</p><p>下面的SQL*Plus命令从默认位置读取具有默认名称的文本初始化参数文件(PFILE)，从文本初始化参数文件创建服务器参数文件(SPFILE)，并将SPFILE写入具有默认SPFILE名称的默认位置。<br>    CREATE SPFILE FROM PFILE;</p><p>如果不使用默认名称和位置，还可以为PFILE和SPFILE提供文件名和路径。</p><blockquote><p>提示:服务器参数文件生效前，必须重启数据库。</p></blockquote><blockquote><p>注意:虽然此时创建服务器参数文件是可选的，但建议这样做。如果不创建服务器参数文件，则实例在启动时继续读取文本初始化参数文件。</p><p>重要提示:如果你使用的是oracle管理的文件，并且你的初始化参数文件不包含CONTROL_FILES参数，你必须创建一个服务器参数文件，这样数据库就可以保存它在create database语句中创建的控制文件的名称和位置。</p></blockquote><h5 id="步骤7-启动实例"><a href="#步骤7-启动实例" class="headerlink" title="步骤7:启动实例"></a>步骤7:启动实例</h5><p>在不挂载数据库的情况下启动实例。通常，您只能在创建数据库期间或在对数据库执行维护时执行此操作。使用带有NOMOUNT子句的sTARTUP命令。在本例中，由于初始化参数文件或服务器参数文件存储在默认位置，因此不需要指定PFILE子句:<br>    STARTUP NOMOUNT</p><p>此时，分配实例内存并启动其进程。数据库本身还不存在。</p><h5 id="步骤8-使用CREATE-DATABASE语句"><a href="#步骤8-使用CREATE-DATABASE语句" class="headerlink" title="步骤8:使用CREATE DATABASE语句"></a>步骤8:使用CREATE DATABASE语句</h5><h5 id="步骤9-创建额外的表空间"><a href="#步骤9-创建额外的表空间" class="headerlink" title="步骤9:创建额外的表空间"></a>步骤9:创建额外的表空间</h5><p>要使数据库正常工作，需要为应用程序数据创建额外的表空间。下面的示例脚本创建了一些额外的表空间:<br>    CREATE TABLESPACE indx_dbs LOGGING    DATAFILE ‘&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;mynewdb&#x2F;apps01.dbf’    SIZE 500M REUSE AUTOEXTEND ON NEXT 1280K MAXSIZE UNLIMITED    EXTENT MANAGEMENT LOCAL;</p><p>为索引创建一个表空间，独立于用户表空间(可选)<br>    CREATE TABLESPACE indx_tbs LOGGIN    DATAFILE ‘&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;mynewdb&#x2F;indx01.dbf’    SIZE 100M REUSE AUTOEXTEND ON NEXT 1280K MAXSIZE UNLIMITED    EXTENT MANAGEMENT LOCAL;</p><p>程度管理本地;</p><h5 id="步骤10-运行脚本来构建数据字典视图"><a href="#步骤10-运行脚本来构建数据字典视图" class="headerlink" title="步骤10:运行脚本来构建数据字典视图"></a>步骤10:运行脚本来构建数据字典视图</h5><p>运行构建数据字典视图、同义词和PL&#x2F;SQL包所需的脚本，并支持SQL*Plus的正常功能:</p><p>@?&#x2F;rdbms&#x2F;admin&#x2F;catalog.sql</p><p>@?&#x2F;rdbms&#x2F;admin&#x2F;catproc.sql</p><p>@?&#x2F;sqlplus&#x2F;admin&#x2F;pupbld.sql</p><p>EXIT</p><p>@符号是运行SQL<em>Plus脚本的命令的简写。问号(?)是SQL</em>Plus变量，表示Oracle的主目录。下表包含脚本的描述:</p><p><img src="https://img-blog.csdnimg.cn/82d35745e64945248ffa0c842ca01375.png"></p><p>步骤12:运行脚本安装附加选项(可选)</p><p>您可能需要运行其他脚本。运行的脚本由您选择使用或安装的功能和选项决定。Oracle数据库参考中描述了许多可用的脚本。</p><p>如果您计划安装其他Oracle产品来使用该数据库，请参阅这些产品的安装说明。有些产品要求您创建额外的数据字典表。通常，提供命令文件来创建这些表并将其加载到数据库数据字典中。</p><p>有关计划安装的特定产品的安装和管理说明，请参阅Oracle文档。</p><h4 id="使用OMF创建数据库"><a href="#使用OMF创建数据库" class="headerlink" title="使用OMF创建数据库"></a>使用OMF创建数据库</h4><p>使用OMF简化了操作系统上的文件管理。</p><p>OMF是由Oracle服务器根据SQL命令创建和删除的。</p><p>OMF通过设置两个参数来建立:</p><ul><li>DB_CREATE_FILE_DEST:设置为数据文件的默认位置</li><li>DB_CREATE_ONLINE_LOG_DEST_n:设置为在线重做日志文件和控制文件的默认位置</li></ul><p>最多五个位置。</p><p>在初始化参数文件中定义OMF参数。例子:</p><ul><li>DB_CREATE_FILE_DEST&#x3D;&#x2F;$HOME&#x2F;ORADATA&#x2F;u05</li><li>DB_CREATE_ONLINE_LOG_DEST_1&#x3D;&#x2F;$HOME&#x2F;ORADATA&#x2F;u01</li><li>DB_CREATE_ONLINE_LOG_DEST_2&#x3D;&#x2F;$HOME&#x2F;ORADATA&#x2F;u02</li></ul><p>CREATEDATABASE 命令简化：  </p><pre><code>@cddba01.sql &gt; CREATE DATABASE dba01;</code></pre><h3 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h3><p>如果出现以下情况，创建数据库失败:</p><ul><li>SQL脚本中有语法错误</li><li>应该创建的文件已经存在</li><li>操作系统错误，如文件或目录权限错误或空间不足错误</li></ul><h3 id="数据库创建后"><a href="#数据库创建后" class="headerlink" title="数据库创建后"></a>数据库创建后</h3><p>数据库包含:</p><ul><li>Data files, control files, and online redo log files</li><li>用户SYS，密码change_on_install</li><li>用户SYSTEM，密码manager</li><li>内部表(没有数据字典视图)</li></ul><h2 id="内置数据库对象"><a href="#内置数据库对象" class="headerlink" title="内置数据库对象"></a>内置数据库对象</h2><p>使用<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA&spm=1001.2101.3001.7020">数据库创建</a>的其他对象:</p><p><a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8&spm=1001.2101.3001.7020">数据字典</a></p><p>性能表</p><p>PL&#x2F;<a href="https://so.csdn.net/so/search?q=SQL&spm=1001.2101.3001.7020">SQL</a>包</p><p>数据库事件触发器</p><h2 id="数据字典（Data-Dictionary）"><a href="#数据字典（Data-Dictionary）" class="headerlink" title="数据字典（Data Dictionary）"></a>数据字典（Data Dictionary）</h2><ul><li>每个Oracle数据库的中心</li><li>描述数据库及其对象</li><li>包含只读表和视图</li><li>存储在SYSTEM表空间中</li><li>属于用户SYS</li><li>由Oracle服务器维护</li><li>通过SELECT访问</li></ul><p><img src="https://img-blog.csdnimg.cn/5edd5c5b323d47aa9c13f2a05307279f.png"></p><h3 id="Base-Tables-DD-Views"><a href="#Base-Tables-DD-Views" class="headerlink" title="Base Tables &amp; DD Views"></a>Base Tables &amp; DD Views</h3><p>数据字典包含两个部分:</p><p>Base Tables（基表）</p><ul><li>存储数据库的描述</li><li>使用CREATE DATABASE创建</li></ul><p>Data dictionary views（数据字典视图）</p><ul><li>用于简化基表信息</li><li>通过公共同义词访问</li><li>用catalog.sql脚本创建</li></ul><h3 id="创建DD-Views"><a href="#创建DD-Views" class="headerlink" title="创建DD Views"></a>创建DD Views</h3><p><img src="https://img-blog.csdnimg.cn/9af4a035a3b64234bf56a9a76030e408.png"></p><p>catalog.sql：创建常用的数据字典视图和同义词</p><p>catproc.sql：运行服务器端PL&#x2F;SQL所需的脚本</p><h3 id="数据字典内容"><a href="#数据字典内容" class="headerlink" title="数据字典内容"></a>数据字典内容</h3><p>数据字典提供以下信息:</p><ul><li>逻辑和物理数据库结构</li><li>对象的定义和空间分配</li><li>完整性约束</li><li>用户</li><li>角色</li><li>特权</li><li>审计</li></ul><h3 id="如何使用DD"><a href="#如何使用DD" class="headerlink" title="如何使用DD"></a>如何使用DD</h3><p>主要用途:</p><p>Oracle服务器使用它来查找有关的信息</p><ul><li>用户</li><li>模式对象</li><li>存储结构</li></ul><p>Oracle服务器在执行DDL语句时修改它。</p><p>用户和DBA以只读的方式查询引用数据库信息。</p><h3 id="DD视图类别"><a href="#DD视图类别" class="headerlink" title="DD视图类别"></a>DD视图类别</h3><p>三组静态视图</p><p>以其范围著称的:</p><ul><li>DBA:所有模式中的内容</li><li>ALL:用户可以访问的内容</li><li>USER:用户模式中的内容</li></ul><p><img src="https://img-blog.csdnimg.cn/f595d2649af2468a9b93b4b8d147a1e0.png"></p><p>DD例子</p><p>总体概述：DICTIONARY，DICT_COLUMNS</p><p>模式对象：DBA_TABLES，DBA_INDEXES，DBA_TAB_COLUMNS，DBA_CONSTRAINTS</p><p>空间分配：DBA_SEGMENTS，DBA_EXTENTS</p><p>数据库结构：DBA_TABLESPACES，DBA_DATA_FILES</p><h3 id="动态性能表（Dynamic-Performance-Tables）"><a href="#动态性能表（Dynamic-Performance-Tables）" class="headerlink" title="动态性能表（Dynamic Performance Tables）"></a>动态性能表（Dynamic Performance Tables）</h3><ul><li>虚拟表</li><li>记录当前数据库活动</li><li>在数据库运行时不断更新</li><li>从内存和控制文件访问信息</li><li>用于监视和调优数据库</li><li>归属SYS用户</li><li>以V$开始的Synonyms</li><li>列在V$FIXED表中</li></ul><p>常见DP</p><ul><li>V$CONTROLFILE：提供了有关数据库控制文件的信息，包括控制文件的名称和位置。</li><li>V$DATABASE：提供了数据库的一般信息，例如数据库名称、状态以及创建时间。</li><li>V$DATAFILE：提供了数据库的一般信息，例如数据库名称、状态以及创建时间。</li><li>V$INSTANCE：提供了关于数据库实例的信息，例如实例名称、启动时间、数据库状态等。</li><li>V$PARAMETER：提供了数据库中的参数设置信息，包括参数名称、当前值、默认值等。</li><li>V$SESSION：提供了数据库会话的信息，包括会话ID、用户名、客户端IP地址、会话状态等。</li><li>V$SGA：提供了SGA（共享内存区）的信息，包括SGA大小、SGA命中率、缓冲池命中率等。</li><li>$SPPARAMETER：提供了SP文件（服务器参数文件）中的参数设置信息。</li><li>V$TABLESPACE：提供了表空间的信息，包括表空间名称、表空间大小、表空间使用情况等。</li><li>V$THREAD：提供了数据库中的线程信息，包括线程ID、线程名称等。</li><li>V$VERSION：提供了数据库软件版本信息，包括Oracle版本号、主版本号、次版本号等。</li></ul><h3 id="Admin脚本命名"><a href="#Admin脚本命名" class="headerlink" title="Admin脚本命名"></a>Admin脚本命名</h3><p>Convention：描述</p><p>cat*.sql：目录和数据字典信息</p><p>dbms*.sql：数据库包规格</p><p>prvt*.plb：封装的数据库包代码</p><p>utl*.sql：用于数据库实用程序的视图和表</p><h2 id="控制文件"><a href="#控制文件" class="headerlink" title="控制文件"></a>控制文件</h2><ul><li>一个小的二进制文件</li><li>定义物理数据库的当前状态</li><li>维护数据库的完整性</li><li>要求：1.在数据库启动期间处于MOUNT状态 ； 2.操作数据库。</li><li>链接到单个数据库</li><li>丢失可能需要恢复</li><li>初始大小由CREATE DATABASE决定</li></ul><h3 id="控制文件的大小"><a href="#控制文件的大小" class="headerlink" title="控制文件的大小"></a>控制文件的大小</h3><p>控件设置的值是控制文件大小的主要决定因素MAXDATAFILES, MAXLOGFILES, MAXLOGMEMBERS, MAXLOGHISTORY，和创建关联数据库的CRÉATEDATABASE语句中的MAXINSTANCES参数。增加这些参数的值会增加关联数据库的控制文件的大小。</p><h3 id="控制文件内容"><a href="#控制文件内容" class="headerlink" title="控制文件内容"></a>控制文件内容</h3><p>控制文件包含以下条目:</p><ul><li>数据库名称和标识符</li><li>数据库创建的时间戳</li><li>表空间名称</li><li>数据文件和在线重做日志文件的名称和位置</li><li>当前在线重做日志文件序号</li><li>检查点的信息</li><li>撤销段的开始和结束</li><li>重做日志存档信息</li><li>备份信息</li></ul><h3 id="多路复用控制文件"><a href="#多路复用控制文件" class="headerlink" title="多路复用控制文件"></a>多路复用控制文件</h3><p>每个<a href="https://so.csdn.net/so/search?q=Oracle%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">Oracle数据库</a>应该至少有两个控制文件，分别存储在不同的物理磁盘上。如果控制文件由于磁盘故障而损坏，则必须关闭关联的实例。一旦修复了磁盘驱动器，就可以使用从另一个磁盘上完整拷贝的控制文件来恢复损坏的控制文件，并且可以重新启动实例。在这种情况下，不需要进行介质恢复。</p><h4 id="多路控制文件的行为是这样的"><a href="#多路控制文件的行为是这样的" class="headerlink" title="多路控制文件的行为是这样的:"></a>多路控制文件的行为是这样的:</h4><ul><li>数据库写入数据库初始化参数文件中为初始化参数CONTROL_FILES列出的所有文件名。</li><li>在数据库操作期间，数据库只读取CONTROL_FILES参数中列出的第一个文件。</li><li>如果任何控制文件在数据库操作期间变得不可用，则实例变得不可操作并应中止。</li></ul><blockquote><p>注意:<a href="https://so.csdn.net/so/search?q=Oracle&spm=1001.2101.3001.7020">Oracle</a>强烈建议您的数据库具有至少有两个控制文件，并且它们位于不同的物理磁盘上。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/1af90ebfc4594c07a5c37291b3181a16.png"></p><h4 id="当使用SPFILE时"><a href="#当使用SPFILE时" class="headerlink" title="当使用SPFILE时"></a>当使用SPFILE时</h4><ol><li><p>修改SPFILE:<br>ALTER SYSTEM SET control_files &#x3D; ‘$HOME&#x2F;ORADATA&#x2F;u01&#x2F;ctrl01.ctl’,’$HOME&#x2F;ORADATA&#x2F;u02&#x2F;ctr102.ctl’SCOPE&#x3D;SPFILE;</p></li><li><p>关闭数据库:<br>shutdown immediate</p></li></ol><p>3.创建额外的控制文件:<br>    cp  $HOME&#x2F;ORADATA&#x2F;u01&#x2F;ctrl01.ctl    $HOME&#x2F;ORADATA&#x2F;u02&#x2F;ctrl02.ctl</p><ol start="4"><li>启动数据库:<br>startup</li></ol><h4 id="当使用PFILE时"><a href="#当使用PFILE时" class="headerlink" title="当使用PFILE时"></a>当使用PFILE时</h4><ol><li><p>关闭数据库:<br>shutdown immediate</p></li><li><p>创建额外的控制文件:<br>cp  $HOME&#x2F;ORADATA&#x2F;u01&#x2F;ctrl01.ctl    $HOME&#x2F;ORADATA&#x2F;u02&#x2F;ctrl02.ctl</p></li></ol><p>3.在PFILE中添加控制文件名:<br>    CONTROL_FILES &#x3D; $HOME&#x2F;ORADATA&#x2F;u01&#x2F;ctrl01.ctl,                $HOME&#x2F;ORADATA&#x2F;u02&#x2F;ctrl02.ctl)</p><ol start="4"><li>启动数据库:<br>startup</li></ol><h4 id="使用OMF"><a href="#使用OMF" class="headerlink" title="使用OMF"></a>使用OMF</h4><p>如果没有指定CONTROL_FILES参数，则创建OMF。</p><p>位置被定义为DB_CREATE_ONLINE_LOG_DEST_n。</p><p>名称是唯一生成并显示在alertSID.log。</p><h4 id="获取控制文件信息"><a href="#获取控制文件信息" class="headerlink" title="获取控制文件信息"></a>获取控制文件信息</h4><p>有关控制文件状态和位置的信息可以通过查询以下视图来检索。</p><ul><li>V$CONTROLFILE:列出与实例关联的所有控制文件的名称和状态</li><li>V$PARAMETER:列出所有参数的状态和位置</li><li>V$CONTROLFILE_RECORD_SECTION:提供有关控制文件记录节的信息</li><li>SHOW PARAMETER CONTROL_FILES:列出控制文件的名称、状态和位置</li></ul><h2 id="维护在线重做日志文件（Online-Redo-log-file）"><a href="#维护在线重做日志文件（Online-Redo-log-file）" class="headerlink" title="维护在线重做日志文件（Online Redo log file）"></a>维护在线重做日志文件（Online Redo log file）</h2><h4 id="在线重做日志文件具有以下特点"><a href="#在线重做日志文件具有以下特点" class="headerlink" title="在线重做日志文件具有以下特点:"></a>在线重做日志文件具有以下特点:</h4><ul><li>记录对数据所做的所有更改</li><li>提供恢复机制</li><li>一定被组织为组</li><li>至少需要两组</li></ul><h4 id="重做文件结构"><a href="#重做文件结构" class="headerlink" title="重做文件结构"></a>重做文件结构</h4><p><img src="https://img-blog.csdnimg.cn/cfac5470ed614be4990aecb07a1a7fa9.png"></p><h4 id="在线重做日志文件组"><a href="#在线重做日志文件组" class="headerlink" title="在线重做日志文件组"></a>在线重做日志文件组</h4><ul><li>在线重做日志文件的一组相同副本称为在线重做日志文件组。</li><li>LGWR后台进程并发地向一个组中的所有在线重做日志文件中写入相同的信息。</li><li>Oracle服务器至少需要两个在线重做日志文件组才能保证一个数据库的正常运行。</li></ul><h4 id="在线重做日志文件成员"><a href="#在线重做日志文件成员" class="headerlink" title="在线重做日志文件成员"></a>在线重做日志文件成员</h4><ul><li>组中的每个在线重做日志文件称为一个成员。</li><li>组中的每个成员具有相同的日志序列号，大小相同。</li><li>LSN(日志序列号)是Oracle服务器每次写日志组时分配的，用来唯一标识每个在线重做日志文件。</li></ul><h4 id="多路重做日志文件"><a href="#多路重做日志文件" class="headerlink" title="多路重做日志文件"></a>多路重做日志文件</h4><p>为了防止涉及重做日志本身的故障，<a href="https://so.csdn.net/so/search?q=Oracle%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">Oracle数据库</a>允许多路重做日志，这意味着可以在不同的位置自动维护两个或多个相同的重做日志副本。为了获得最大的好处，这些位置应该位于单独的磁盘上。然而，即使重做日志的所有副本都在同一个磁盘上，冗余也可以帮助防止I&#x2F;O错误、文件损坏等。当重做日志文件多路复用时，LGWR并发地将相同的重做日志信息写入多个相同的重做日志文件，从而消除了重做日志单点故障。</p><p>多路复用是通过创建多组重做日志文件实现的。一个组由一个重做日志文件和它的多路副本组成。每个相同的副本被称为组的一个成员。每个重做日志组都用一个数字来定义，比如组1、组2，等等。</p><blockquote><p>注意:Oracle建议您使用多重重做日志文件。如果需要恢复，日志文件数据的丢失可能是灾难性的。请注意，当您复用重做日志时，数据库必须增加它执行的I&#x2F;O量。根据您的配置，这可能会影响数据库的整体性能。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/41ef4eb44cd246a0b380a94729e9e08f.png"></p><h4 id="重做文件如何工作"><a href="#重做文件如何工作" class="headerlink" title="重做文件如何工作"></a>重做文件如何工作</h4><p>在线重做日志文件以循环的方式使用。</p><p>当一个在线重做日志文件已满时，LGWR会移动到下一个日志组。</p><ul><li>称为日志切换</li><li>检查点操作也会发生</li><li>写入控制文件的信息</li></ul><p>从一个日志文件组切换到另一个日志文件组的行为称为日志切换。检查点是将脏的(修改的)块从缓冲区缓存写到磁盘。</p><h4 id="LGWR什么时候写重做"><a href="#LGWR什么时候写重做" class="headerlink" title="LGWR什么时候写重做?"></a>LGWR什么时候写重做?</h4><ul><li>事务提交的时候。</li><li>每三秒一次</li><li>当重做日志缓冲区满三分之一时。</li><li>当重做日志缓冲区中有超过1兆字节的更改记录时。</li><li>在DBWn将数据库缓存中修改过的块写入到database files</li></ul><h4 id="LS-LSN"><a href="#LS-LSN" class="headerlink" title="LS &amp; LSN"></a>LS &amp; LSN</h4><p>日志交换机和日志序列号</p><p>日志开关是数据库停止写入一个重做日志文件并开始写入另一个日志文件的点。通常，日志切换发生在当前重做日志文件被完全填满，必须继续写入下一个重做日志文件的时候。但是，您可以将日志切换配置为定期发生，而不管当前重做日志文件是否被完全填满。你也可以手动强制日志切换。</p><p>Oracle数据库在每次日志切换发生并且LGWR开始写入时，为每个重做日志文件分配一个新的日志序列号。当数据库归档重做日志文件时，归档的日志保留其日志序列号。重做日志文件被循环回用时，会被赋予下一个可用的日志序列号。</p><p>每个在线或存档的重做日志文件都由其日志序列号唯一标识。在崩溃、实例或介质恢复期间，数据库通过使用必要的归档和重做日志文件的日志序列号，以升序正确地应用重做日志文件。</p><h4 id="强制日志开关和CK"><a href="#强制日志开关和CK" class="headerlink" title="强制日志开关和CK"></a>强制日志开关和CK</h4><p>强制日志开关:<br>    ALTER SYSTEM SWITCH LOGFILE;</p><p>可以通过以下方式强制设置检查点:</p><p>设置FAST_START_MTTR_TARGET参数<br>    FAST_START_MTTR_TARGET &#x3D; 600</p><p>修改系统检查点命令<br>    ALTER SYSTEM CHECKPOINT;</p><h4 id="添加重做文件组"><a href="#添加重做文件组" class="headerlink" title="添加重做文件组"></a>添加重做文件组</h4><pre><code>ALTER DATABASE ADD LOGFILE GROUP 3(&#39;$HOME/ORADATA/u01/log3a.rdo&#39;, &#39;$HOME/ORADATA/u02/log3b.rdo&#39;)SIZE 1M;</code></pre><p><img src="https://img-blog.csdnimg.cn/950aebcb3d154185bfc79526a0c1a608.png"></p><h4 id="添加Redo文件成员"><a href="#添加Redo文件成员" class="headerlink" title="添加Redo文件成员"></a>添加Redo文件成员</h4><pre><code>ALTER DATABASE ADD LOGFILE MEMBER&#39;$HOME/ORADATA/u04/log1c.rdo&#39; TO GROUP 1, &#39;$HOME/ORADATA/u04/1og2c.rdo&#39; TO GROUP 2, &#39;$HOME/ORADATA/u04/1og3c.rdo&#39; TO GROUP 3;</code></pre><p><img src="https://img-blog.csdnimg.cn/f943de0c50a64e1ab14701f54a116d14.png"></p><h4 id="删除Redo文件成员"><a href="#删除Redo文件成员" class="headerlink" title="删除Redo文件成员"></a>删除Redo文件成员</h4><ul><li>允许删除重做日志文件，使多路重做日志暂时变得不对称。例如，如果你使用双工重做日志文件组，你可以删除一个组中的一个成员，即使所有其他组每个组都有两个成员。但是，您应该立即纠正这种情况，以便所有组至少有两个成员，从而消除重做日志可能出现的单点故障。</li><li>一个实例总是需要至少两组有效的重做日志文件，而不管组中的成员有多少。(一个组由一个或多个成员组成。)如果要删除的成员是组中最后一个有效的成员，则在其他成员生效之前不能删除该成员。要查看重做日志文件状态，请使用V$LOGFILE视图。如果数据库无法访问重做日志文件，则重做日志文件变为INVALID。如果数据库怀疑它不完整或不正确，则变为STALE。当一个陈旧的日志文件的组下一次被设置为活动组时，该日志文件将再次变为有效的。</li><li>只有当重做日志成员不属于活动组或当前组时，才能删除该成员。如果你想删除一个活动组的成员，首先强制进行日志切换。</li><li>在删除成员之前，请确保重做日志成员所属的组已存档(如果存档已启用)。要查看是否发生了这种情况，使用V$LOG view。</li></ul><p>当重做日志成员从数据库中删除时，操作系统文件不会从磁盘中删除。相反，更新关联数据库的控制文件以从数据库结构中删除该成员。在删除重做日志文件后，确保删除成功完成，然后使用适当的操作系统命令删除被删除的重做日志文件。</p><h4 id="删除重做文件组"><a href="#删除重做文件组" class="headerlink" title="删除重做文件组"></a>删除重做文件组</h4><ul><li><p>一个实例至少需要两组在线重做日志文件。</p></li><li><p>不能删除活动组或当前组。</p></li><li><p>删除在线重做日志文件组时，不会删除操作系统文件。<br>ALTER DATABASE DROP LOGFILE GROUP 3;</p></li></ul><p><img src="https://img-blog.csdnimg.cn/bb9843c178034b3bbbac5dbdc319c6d7.png"></p><p>搬迁和重命名</p><p>您可以使用操作系统命令重新定位重做日志，然后使用ALTER DATABASE语句使数据库知道它们的新名称(位置)。这个过程是必要的，例如，如果当前用于某些重做日志文件的磁盘将被删除，或者数据文件和多个重做日志文件存储在同一个磁盘上，并且应该分开以减少争用。</p><p>要重命名重做日志成员，您必须具有ALTER DATABASE系统权限。此外，您可能还需要操作系统权限来将文件复制到所需的位置和特权，以打开和备份数据库。</p><p>在重新定位重做日志或对数据库进行任何其他结构更改之前，请完全备份数据库，以防在执行操作时遇到问题。作为预防措施，在重命名或重定位一组重做日志后日志文件，立即备份数据库控制文件。</p><h4 id="搬迁和重命名"><a href="#搬迁和重命名" class="headerlink" title="搬迁和重命名"></a>搬迁和重命名</h4><p>通过以下两种方式之一重新定位或重命名在线重做日志文件:</p><p>ALTER DATABASE重命名文件命令</p><ul><li><p>关闭数据库。</p></li><li><p>将在线重做日志文件复制到新位置。</p></li><li><p>将数据库置于MOUNT模式。</p></li><li><p>执行命令。</p></li><li><p>打开数据库进行正常操作。<br>ALTER DATABASE RENAME FILE ‘$HOME&#x2F;ORADATA&#x2F;u01&#x2F;log2a.rdo’ TO ‘$HOME&#x2F;ORADATA&#x2F;u02&#x2F;log1.rdo’;</p></li></ul><p>添加新成员，删除旧成员。</p><h4 id="清除重做文件"><a href="#清除重做文件" class="headerlink" title="清除重做文件"></a>清除重做文件</h4><p>清除数据库日志文件命令用于重新初始化在线重做日志文件。<br>    ALTER DATABASE CLEAR LOGFILE GROUP 2;</p><p>使用UNARCHIVED关键字，避免归档损坏的在线重做日志文件。<br>    ALTER DATABASE CLEAR UNARCHIVEDLOGFILE GROUP 2;</p><p>重做文件配置</p><blockquote><p>小贴士:在<a href="https://so.csdn.net/so/search?q=%E4%B8%8D%E5%90%8C%E7%9A%84&spm=1001.2101.3001.7020">不同的</a>磁盘上在设置多路重做日志时，将组的成员放在不同的物理磁盘上。如果单个磁盘发生故障，则组中只有一个成员对LGWR不可用，而LGWR仍然可以访问其他成员，因此实例可以继续运行。</p><p>如果归档重做日志，请将重做日志成员分散到磁盘上，以消除LGWR和ARCn后台进程之间的争用。例如，如果你有两组多工重做日志成员(双工重做日志)，将每个成员放在不同的磁盘上，并将存档目标设置为第五个磁盘。这样做可以避免LGWR(写入成员)和ARCn(读取成员)之间的争用。</p><p>数据文件也应该和重做日志文件放在不同的磁盘上，以减少写数据块和重做记录的争用。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/61dbd5f7075f44349a8b5ffa54865e8b.png"></p><p><img src="https://img-blog.csdnimg.cn/1a088e8655ff497bac9d02155d6f5a65.png"><img src="https://img-blog.csdnimg.cn/5bfb9c3cd6c4426698d1d0d27e3424e6.png"></p><p><img src="https://img-blog.csdnimg.cn/6462de1517be4792b5a06eaa99fac30b.png"></p><h4 id="用OMF管理重做文件"><a href="#用OMF管理重做文件" class="headerlink" title="用OMF管理重做文件"></a>用OMF管理重做文件</h4><p>定义DB_CREATE_ONLINE_LOG_DEST_n参数：<br>    DB_CREATE_ONLINE_LOG_DEST_1DB_CREATE_ONLINE_LOG_DEST_2</p><p>可以在没有文件规格的情况下添加组:<br>    Alter database add logfile;</p><p>删除组:<br>    Alter database drop logfile group 3;</p><h4 id="组-成员信息"><a href="#组-成员信息" class="headerlink" title="组&amp;成员信息"></a>组&amp;成员信息</h4><p>可以通过查询以下视图获取组及其成员的信息:</p><ul><li>V$LOG</li><li>V$LOGFILE</li></ul><p><img src="https://img-blog.csdnimg.cn/60eeaa63c018439fadf7bf241a420130.png"></p><h4 id="什么是重做线程"><a href="#什么是重做线程" class="headerlink" title="什么是重做线程?"></a>什么是重做线程?</h4><p>当在多个数据库实例的上下文中说话时，每个数据库实例的重做日志也被称为重做线程。在典型配置中，只有一个数据库实例访问一个Oracle数据库，因此只存在一个线程。然而，在Oracle真实应用集群环境中，两个或多个实例并发访问一个数据库，每个实例都有自己的重做线程。每个实例单独的重做线程避免了对一组重做日志文件的争用，从而消除了潜在的性能瓶颈。</p><h4 id="归档的重做日志文件"><a href="#归档的重做日志文件" class="headerlink" title="归档的重做日志文件"></a>归档的重做日志文件</h4><ul><li>由ARCn自动完成</li><li>通过SQL语句手动完成归档成功时:</li><li>在控制文件中做一个条目记录:存档日志名称、日志序号、高低系统变更号(SCN)</li><li>填满的在线重做日志文件不能被重用，直到:检查点已经发生—文件已被ARCn归档</li><li>能复用吗</li><li>由DBA维护</li></ul><blockquote><p>填满的在线重做日志文件可以归档。</p><p>以ARCHIVELOG模式运行数据库并存档在线重做日志文件有两个优点:</p><ul><li>恢复:数据库备份以及联机和归档的重做日志文件可以保证恢复所有已提交的事务。</li><li>备份:这可以在数据库打开时执行。</li></ul><p>默认情况下，数据库创建在无归档日志模式。</p></blockquote><h2 id="表空间和数据文件"><a href="#表空间和数据文件" class="headerlink" title="表空间和数据文件"></a>表空间和数据文件</h2><p>Oracle逻辑上将数据存储在表空间中，物理上将数据存储在数据文件中。</p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间:"></a>表空间:</h3><ul><li>一次只能属于一个数据库</li><li>由一个或多个数据文件组成</li><li>是否进一步划分为逻辑存储单元</li></ul><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件:"></a>数据文件:</h3><p>能只属于一个表空间和一个数据库</p><p>是模式对象数据的存储库</p><p><img src="https://img-blog.csdnimg.cn/d500eb06aa434047addd06a5bc4bb739.png"></p><h3 id="表空间的类型"><a href="#表空间的类型" class="headerlink" title="表空间的类型"></a>表空间的类型</h3><p>SYSTEM表空间</p><p>用数据库创建</p><ul><li>包含数据字典</li><li>包含SYSTEM撤消段</li></ul><p>非SYSTEM表空间 </p><ul><li>单独的部分</li><li>简化空间管理</li><li>控制分配给用户的空间量</li></ul><blockquote><p>permanent（永久表空间）、undo、temporary（临时表空间）</p></blockquote><h3 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h3><p>创建表空间的命令如下:<br>    CREATE TABLESPACE userdataDATAFILE ‘&#x2F;u01&#x2F;oradata&#x2F;userdata01.dbf’ SIZE 5M;</p><p><img src="https://img-blog.csdnimg.cn/63e8705a98c64688afa32ae01596b3a9.png"></p><h3 id="表空间中的空间管理"><a href="#表空间中的空间管理" class="headerlink" title="表空间中的空间管理"></a>表空间中的空间管理</h3><p>本地管理表空间:</p><ul><li>在表空间中管理空闲区。</li><li>位图用于记录空闲区。</li><li>每个位对应一个或一组块。</li><li>位值表示空闲或已使用。</li></ul><p>Dictionary-managed表空间:</p><ul><li>空闲区由数据字典管理。</li><li>当区段被分配或释放时，相应的表被更新。</li></ul><h4 id="Dictionary-Managed-TS"><a href="#Dictionary-Managed-TS" class="headerlink" title="Dictionary-Managed TS"></a>Dictionary-Managed TS</h4><ul><li><p>区段在数据字典中管理。</p></li><li><p>存储在表空间中的每个段可以有不同的存储子句。</p></li><li><p>需要进行Coalescing。<br>CREATE TABLE userdataDATAFILE ‘&#x2F;u01&#x2F;oradata&#x2F;userdata01.dbf’SIZE 500M EXTENT MANAGENT DICTIONARYDEFAULT STORAGE(initial 1M NEXT 1M PCTINCREASE);</p></li></ul><h4 id="迁移DM-SYSTEM-TS"><a href="#迁移DM-SYSTEM-TS" class="headerlink" title="迁移DM SYSTEM TS"></a>迁移DM SYSTEM TS</h4><p>将字典管理的SYSTEM表空间迁移到本地管理:</p><ol><li><p> 对数据库做一个完整的备份。</p></li><li><p> 确保数据库有一个非SYSTEM的默认临时表空间。使用CREATE TEMPORARY TABLESPACE命令创建临时表空间。</p></li><li><p> 在字典管理的表空间中消除任何撤消(回滚)段。</p></li><li><p> 本地管理的表空间中至少应该有一个在线撤销段，或者撤销表空间应该是在线的。</p></li><li><p> 除了包含undo空间和默认临时表空间的表空间外，所有表空间都应该设置为READ ONLY模式。</p></li><li><p> 以受限模式启动实例。</p></li><li><p> 迁移SYSTEM表空间:<br> DBMS_SPACE_ADMIN. TABLESPACE_MIGRATE_mig_TO_LOCAL(‘SYSTEM’);</p></li></ol><h3 id="Undo-Tablespace"><a href="#Undo-Tablespace" class="headerlink" title="Undo Tablespace"></a>Undo Tablespace</h3><ul><li><p>用于存储undo段</p></li><li><p>不能包含任何其他对象</p></li><li><p>区段是本地管理的</p></li><li><p>只能使用DATAFILE和EXTENT MANAGEMENT子句<br>CREATE UNDO TABLESPACE undo1DATAFILE ‘&#x2F;u01&#x2F;oradata&#x2F;undo01.dbf’ SIZE 40M;</p></li></ul><h3 id="Temporary-Tablespaces（临时表空间）"><a href="#Temporary-Tablespaces（临时表空间）" class="headerlink" title="Temporary Tablespaces（临时表空间）"></a>Temporary Tablespaces（临时表空间）</h3><ul><li><p>用于排序操作</p></li><li><p>能被多个用户共享</p></li><li><p>不能包含任何永久对象</p></li><li><p>建议使用本地管理的区段<br>CREATE TEMPORARY TABLESPACE tempTEMPFILE ‘u01&#x2F;oradata&#x2F;temp01.dbf’ SIZE 20MEXTENT MANAGEMENT LOCAL UNIFORM SIZE 4M;</p></li></ul><blockquote><p>当SYSTEM表空间是本地管理时，在创建数据库时必须至少定义一个默认的临时表空间。本地管理的SYSTEM表空间不能用作默认临时存储。</p><p>如果SYSTEM是字典管理的，并且在创建数据库时没有定义默认的临时表空间，那么SYSTEM仍然用于默认的临时存储。然而，你会在ALERT.LOG中收到一个警告，说默认临时表空间是推荐的，并且在未来的版本中是必要的。</p></blockquote><h3 id="Defauit-Temporary-TS（默认临时表空间）"><a href="#Defauit-Temporary-TS（默认临时表空间）" class="headerlink" title="Defauit Temporary TS（默认临时表空间）"></a>Defauit Temporary TS（默认临时表空间）</h3><p>指定数据库范围的默认临时表空间</p><p>避免使用SYSTEM表空间存储临时数据</p><p>可以使用以下命令创建:<br>    CREATE DATBASEALER DATABASE</p><h4 id="创建默认临时表空间"><a href="#创建默认临时表空间" class="headerlink" title="创建默认临时表空间"></a>创建默认临时表空间</h4><p>在数据库创建过程中：<br>    CREATE DATABASE DBA01LOGFILEGROUP 1 (‘&#x2F;SHOME&#x2F;ORADATA&#x2F;u01&#x2F;redo01.log’)SIZE 100MGROUP 2 (‘&#x2F;SHOME&#x2F;ORADATA&#x2F;u02&#x2F;redo02.log’)SIZE 100MMAXLOGFILES 5MAXLOGMEMBERS 5MAXLOGHISTORY 1MAXDATAFILES 100MAXINSTANCES 1DATAFILE，&#x2F;SHOME&#x2F;ORADATA&#x2F;u01&#x2F;system01.dbf’ SIZE 325MUNDO TABLESPACE undotbsDATAFILE9&#x2F;SHOME&#x2F;ORADATA&#x2F;u02&#x2F;undotbs01.dbf’ SIZE 200DEFAULT TEMPORARY TABLESPACE tempTEMPFILE’&#x2F;SHOME&#x2F;ORADATA&#x2F;u03&#x2F;temp01.dbf’ SIZE 4GCHARACTER SET US7ASCII</p><p>数据库创建后：<br>    ALTER DATAASEDEFAULT TEMPORARY TABLESPACE default_temp2;</p><p>查找数据库查询DATABASE_PROPERTIES的默认临时表空间：<br>    SELECT * from DATABASE_PROPERTIES;</p><blockquote><p>限制</p><p>默认临时表空间不能为:</p><ul><li>在新的默认表空间可用之前删除</li><li>离线</li><li>修改为永久表空间</li></ul></blockquote><p>只读表空间</p><p>使用以下命令将表空间设置为只读模式:<br>    ALTER TABLESPACE userdata READ ONLY;</p><ul><li>引起检查点</li><li>只能用于读操作的数据</li><li>对象可以从表空间中删除</li></ul><h3 id="使表空间离线"><a href="#使表空间离线" class="headerlink" title="使表空间离线"></a>使表空间离线</h3><ul><li>不可用于数据访问</li><li>不能离线的表空间:SYSTEM tablespace</li><li>具有活动undo段的表空间</li><li>默认临时表空间</li></ul><p>使表空间离线：<br>    ALTER TABLESPACE userdata OFFLINE;</p><p>使表空间在线：<br>    ALTER TABLESPACE userdata ONLINE;</p><h3 id="更改存储设置"><a href="#更改存储设置" class="headerlink" title="更改存储设置"></a>更改存储设置</h3><p>使用修改表空间命令修改存储设置:<br>    ALTER TABLESPACE userdata MINIMUM EXTENT 2M;</p><pre><code>ALTER TABLESPACE userdataDEFAULT STORAGE (INITIAL 2M NEXT 2M MAXEXTENTS 999);</code></pre><blockquote><p>本地管理的表空间的存储设置不能被修改。</p></blockquote><h3 id="调整表空间大小"><a href="#调整表空间大小" class="headerlink" title="调整表空间大小"></a>调整表空间大小</h3><p>表空间可以通过以下方式调整大小:</p><p>1.修改数据文件的大小:</p><ul><li>自动使用AUTOEXTEND</li><li>手动使用ALTER DATABASE</li></ul><p>2.使用ALTER TABLESPACE添加数据文件</p><h4 id="启用自动扩展"><a href="#启用自动扩展" class="headerlink" title="启用自动扩展"></a>启用自动扩展</h4><p>可以使用以下命令自动调整大小:</p><ul><li>CREATE DATABASE</li><li>CREATE TABLESPACE</li><li>ALTER TABLESPACE … ADD DATAFILE</li></ul><p>例子:<br>    CREATE TABLESPACE user_dataDATAFILE’&#x2F;u01&#x2F;oradata&#x2F;userdata01.dbf’ SIZE 200MAUTOEXTEND ON NEXT 10m MAXSIZE 500M;</p><p>查询DBA_DATA_FILES视图，确定是否启用了AUTOEXTEND。</p><h4 id="手动调整数据文件大小"><a href="#手动调整数据文件大小" class="headerlink" title="手动调整数据文件大小"></a>手动调整数据文件大小</h4><ul><li><p>手动增加或减少数据文件的大小更改数据库。</p></li><li><p>调整数据文件大小可以在不添加更多数据文件的情况下增加空间。</p></li><li><p>手动调整数据文件大小会回收数据库中未使用的空间。</p></li><li><p>例子:<br>ALTER DATABASEDATAFILE ‘&#x2F;u03&#x2F;oradata&#x2F;userdata02.dbf’RESIZE 200M;</p></li></ul><h4 id="向表空间添加数据文件"><a href="#向表空间添加数据文件" class="headerlink" title="向表空间添加数据文件"></a>向表空间添加数据文件</h4><ul><li><p>通过添加额外的数据文件来增加分配给表空间的空间</p></li><li><p>添加DATAFILE子句用于添加数据文件</p></li><li><p>例子:<br>ALTER TABLESPACE user_dataADD DATAFILE ‘&#x2F;u01&#x2F;oradata&#x2F;userdata03.dbf’SIZE 200M;</p></li></ul><h3 id="移动数据文件的方法"><a href="#移动数据文件的方法" class="headerlink" title="移动数据文件的方法"></a>移动数据文件的方法</h3><h4 id="ALTER-TABLESPACE"><a href="#ALTER-TABLESPACE" class="headerlink" title="ALTER TABLESPACE"></a>ALTER TABLESPACE</h4><ul><li><p>表空间必须离线。</p></li><li><p>目标数据文件必须存在。<br>ALTER TABLESPACE userdata RENAMEDATTAFILE ‘&#x2F;u01&#x2F;oradata&#x2F;userdata01.dbf’Tо ‘&#x2F;u02&#x2F;oradata&#x2F;userdata01.dbf’;</p></li></ul><h4 id="ALTER-DATABASE"><a href="#ALTER-DATABASE" class="headerlink" title="ALTER DATABASE"></a>ALTER DATABASE</h4><ul><li><p>必须挂载数据库(MOUNTED)。</p></li><li><p>目标数据文件必须存在。<br>ALTER DATABASE RENAMEFILE ‘&#x2F;u01&#x2F;oradata&#x2F;system01.dbf’TO ‘&#x2F;u03&#x2F;oradata&#x2F;system01.dbf’;</p></li></ul><h3 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h3><p>不能删除表空间，如果它:</p><ul><li>是SYSTEM表空间</li><li>有活动的段</li></ul><p>包括内容删除段。</p><p>包括内容和数据文件删除数据文件。</p><p>级联约束删除所有引用完整性约束。<br>    DROP TABLESPACE userdataINCLUDING CONTENTS AND DATAFILES;</p><h3 id="获取表空间信息"><a href="#获取表空间信息" class="headerlink" title="获取表空间信息"></a>获取表空间信息</h3><p>获取表空间信息和数据文件信息可通过以下查询方式获取:</p><p>表空间信息:<br>    DBA_TABLESPACESV$TABLESPACE</p><p>数据文件信息:<br>    DBA_DATA_FILESV$DATAFILE</p><p>临时文件信息:<br>    DBA_TEMP_FILESV$TEMPFILES</p><h3 id="存储层次结构摘要"><a href="#存储层次结构摘要" class="headerlink" title="存储层次结构摘要"></a>存储层次结构摘要</h3><ol><li>数据库由一个或多个表空间组成。</li><li>一个表空间由一个或多个数据文件组成。这些文件可能是文件系统中的cooked file，原始分区（raw partition），ASM 管理的数据库文件，或者是群集文件系统（clustered file system）中的文件。一个表空间包含段（segments）。</li><li>一个段(TABLE, INDEX等)由一个或多个区段组成。一个段存在于一个表空间中，但可能在该表空间内的许多数据文件中有数据。</li><li>区段是磁盘上逻辑上连续的一组块。区段位于单个表空间中，而且始终位于该表空间中的单个文件中。</li><li>块是数据库中最小的分配单位。块是数据库使用的最小I&#x2F;O单位。</li></ol><p> <img src="https://img-blog.csdnimg.cn/ed2b07a29c794e03b70c72cdbfed74af.png"></p><p><img src="https://img-blog.csdnimg.cn/57cc0316bbb04893bdcae871f1367879.png"></p>]]></content>
    
    
    <summary type="html">hello word~</summary>
    
    
    
    
    <category term="笔记" scheme="http://1414116846.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
