<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux常见命令</title>
    <url>/2023/10/12/linux%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="1-常用文件管理命令"><a href="#1-常用文件管理命令" class="headerlink" title="1.常用文件管理命令"></a>1.常用文件管理命令</h2><p>1.1 命令介绍<br>ㅤㅤ1. Ctrl c：取消命令，并且换行</p>
<p>ㅤㅤ2. Ctrl u：清空本行命令</p>
<p>ㅤㅤ3. tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p>
<p>ㅤㅤ4. ls：列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p>
<p>ㅤㅤㅤ●ㅤls -a：查看所有文件包括隐藏文件（以.开头的文件就是隐藏文件）</p>
<p>ㅤㅤㅤ●ㅤls -l：查看当前路径下文件的读、写、执行权限</p>
<p>ㅤㅤㅤ●ㅤls | wc -l：查看ls下有多少个文件</p>
<p>ㅤㅤ5. pwd：显示当前路径</p>
<p>ㅤㅤ6. cd XXX：进入XXX目录下，cd ..返回上层目录</p>
<p>ㅤㅤㅤ●ㅤ.：当前目录 ..：上级目录</p>
<p>ㅤㅤㅤ●ㅤ~：家目录，回回到路径&#x2F;home&#x2F;acs下</p>
<p>ㅤㅤㅤ●ㅤcd -：返回改变路径前的路径，比如当前在&#x2F;home&#x2F;acs&#x2F;homework然后cd** **&#x2F;这个时候就处于&#x2F;目录下，然后cd -就会回到改变路径前的路径也就是&#x2F;home&#x2F;acs&#x2F;homework</p>
<p>ㅤㅤ7. cp XXX YYY：将XXX文件复制成YYY，XXX和YYY可以是同一个路径，比如..&#x2F;dir_c&#x2F;a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p>
<p>ㅤㅤㅤ●ㅤcp XXX YYY -r将XXX目录（文件夹）复制到YYY下</p>
<p>ㅤㅤㅤ●ㅤ非当前路径重命名方法：cp a.txt ..&#x2F;b.txt</p>
<p>ㅤㅤ8. mkdir XXX：创建目录（文件夹）XXX</p>
<p>ㅤㅤㅤ●ㅤmkdir -p：-p：如果文件夹不存在，则创建</p>
<p>ㅤㅤ9. rm XXX：删除普通文件； rm XXX -r：删除文件夹</p>
<p>ㅤㅤㅤ●ㅤ支持正则表达式，删除所有.txt类型文件：rm *.txt</p>
<p>ㅤㅤㅤ●ㅤ删除所有文件（不包括文件夹）：rm *</p>
<p>ㅤㅤㅤ●ㅤ正则表达式删除所有文件夹：rm * -r即可</p>
<p>ㅤㅤ10. mv XXX YYY：将XXX文件移动到YYY下，和cp命令一样，XXX和YYY可以是同一个路径；重命名也是用这个命令</p>
<p>ㅤㅤㅤ●ㅤ非当前路径移动方法：mv a.txt ..&#x2F;b.txt</p>
<p>ㅤㅤ11. touch XXX：创建一个文件</p>
<p>ㅤㅤ12. cat XXX：展示文件XXX中的内容</p>
<p>ㅤㅤ13. 复制文本：windows&#x2F;Linux下：Ctrl + insert，Mac下：command + c</p>
<p>ㅤㅤ14. 粘贴文本：windows&#x2F;Linux下：Shift + insert，Mac下：command + v</p>
<p>ㅤㅤ15. history：查看历史输入指令</p>
<p>ㅤㅤ16. tree：以树形显示文件目录结构</p>
<h2 id="2-oracle命令"><a href="#2-oracle命令" class="headerlink" title="2.oracle命令"></a>2.oracle命令</h2><p><code>sqlplus / as sysdba</code>  使用管理员权限登录到操作系统中的Oracle安装用户。</p>
<p><code>conn / as sysdba;</code> 是Oracle数据库中的命令，用于使用sysdba权限连接到数据库。 <code>conn</code> 是connect的缩写，<code>/</code> 表示使用操作系统认证方式登录，<code>as sysdba</code> 表示以sysdba用户身份登录。这条命令通常在命令行或SQL*Plus工具中使用，以获得对数据库的管理员权限。</p>
<p><code>startup；</code> 启动数据库</p>
<p><code>shutdown immediate;</code> 关闭数据库</p>
<p><code>lsnrctl start</code> 启动监听</p>
<p><code>show user</code> 查看当前用户</p>
<p><code>conn scott/tiger</code> 连接用户名为scott密码为tiger的实例</p>
<p><code>shutdown transactional;</code>  事务完成后关闭数据库</p>
<p><code>select name from v$tempfile;</code> 获取临时表空间文件的名称。</p>
<p><code>select name from v$datafile;</code> 获取数据文件的名称。数据文件是用来存储表、索引和其他数据库对象的物理文件。</p>
]]></content>
  </entry>
  <entry>
    <title>算法模板</title>
    <url>/2023/02/14/ypy%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center">运算符</th>
<th align="center">结合律</th>
<th align="center">助记</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>::</code></td>
<td align="center">从左至右</td>
<td align="center">作用域</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>a++</code>、<code>a--</code>、 <code>type()</code>、<code>type&#123;&#125;</code>、 <code>a()</code>、<code>a[]</code>、 <code>.</code>、<code>-&gt;</code></td>
<td align="center">从左至右</td>
<td align="center">后缀自增减、 函数风格转型、 函数调用、下标、 成员访问</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>!</code>、<code>~</code>、 <code>++a</code>、<code>--a</code>、<code>+a</code>、<code>-a</code>、 <code>(type)</code>、<code>sizeof</code>、<code>&amp;a</code>、 <code>*a</code>、 <code>new</code>、 <code>new[]</code>、<code>delete</code>、 <code>delete[]</code></td>
<td align="center"><strong>从右至左</strong></td>
<td align="center">逻辑非、按位非、 前缀自增减、正负、 C 风格转型、取大小、取址、 指针访问、 动态内存分配</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>.*</code>、<code>-&gt;*</code></td>
<td align="center">从左至右</td>
<td align="center">指向成员指针</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>a*b</code>、<code>a/b</code>、<code>a%b</code></td>
<td align="center">从左至右</td>
<td align="center">乘除、取模</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><code>a+b</code>、<code>a-b</code></td>
<td align="center">从左至右</td>
<td align="center">加减</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td>
<td align="center">从左至右</td>
<td align="center">按位左右移</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td>
<td align="center">从左至右</td>
<td align="center">大小比较</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>==</code>、<code>!=</code></td>
<td align="center">从左至右</td>
<td align="center">等价比较</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><code>a&amp;b</code></td>
<td align="center">从左至右</td>
<td align="center">按位与</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><code>^</code></td>
<td align="center">从左至右</td>
<td align="center">按位异或</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">&#96;</td>
<td align="center">&#96;</td>
<td align="center">从左至右</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">从左至右</td>
<td align="center">逻辑与</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">&#96;</td>
<td align="center"></td>
<td align="center">&#96;</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><code>a?b:c</code>、 <code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&amp;=</code>、<code>^=</code>、&#96;</td>
<td align="center">&#x3D;<code>、</code>&lt;&lt;&#x3D;<code>、</code>&gt;&gt;&#x3D;&#96;</td>
<td align="center"><strong>从右至左</strong></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><code>,</code></td>
<td align="center">从左至右</td>
<td align="center">逗号</td>
</tr>
</tbody></table>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>以二分答案的check函数为例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; check = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=cnt&amp;&amp;a[i]&gt;=x-cnt<span class="number">-1</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="读入优化"><a href="#读入优化" class="headerlink" title="读入优化"></a>读入优化</h2><p>如果输入输出规模超过1e6就不建议使用cin&#x2F;cout</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭同步流</span></span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="int128"><a href="#int128" class="headerlink" title="__int128"></a>__int128</h2><p><code>__int128</code> 就是占用128字节的整数存储类型。由于是二进制，范围就是$-2^{127}$ ~ $2^{127} - 1$ </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">81</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">不能关流!!!!!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">__int128 a=read();</span></span><br><span class="line"><span class="comment">__int128 b=read();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">print(a+b);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> __int128 <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __int128 x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">9</span>)</span><br><span class="line">        <span class="built_in">print</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">__int128 game[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">__int128 f[MAXN][MAXN];</span><br><span class="line"><span class="function">__int128 <span class="title">solve</span><span class="params">(__int128 a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">0</span>;len&lt;=m;++len)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len&lt;=m;++i)</span><br><span class="line">            f[i][i+len]=<span class="built_in">max</span>(<span class="number">2</span>*f[i+<span class="number">1</span>][i+len]+<span class="number">2</span>*a[i],<span class="number">2</span>*f[i][i+len<span class="number">-1</span>]+<span class="number">2</span>*a[i+len]);</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int128 ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            game[i][j] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans+=<span class="built_in">solve</span>(game[i]);</span><br><span class="line">    <span class="built_in">print</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p><a href="https://blog.csdn.net/lanchunhui/article/details/49644373">(10条消息) C++基础——简单而强大的bitset_五道口纳什的博客-CSDN博客</a></p>
<p>里面存的是一个01串，可以用来当做标记数组</p>
<p>&lt;&lt;,&gt;&gt;运算符在这里是把<strong>值的位置</strong>往左或往右移动几位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">bitset&lt;maxn&gt; dp[<span class="number">102</span>];<span class="comment">//dp[i][j]-&gt;第i轮，值为j的数是否存在</span></span><br><span class="line"><span class="type">int</span> n, l ,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    dp[<span class="number">0</span>].<span class="built_in">set</span>(<span class="number">0</span>);             <span class="comment">//第0位要置1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = l; j &lt;= r; j++)</span><br><span class="line">            dp[i] |= dp[i<span class="number">-1</span>]&lt;&lt;(j * j);</span><br><span class="line">        		  <span class="comment">/* dp[i-1]&lt;&lt;(j * j) -&gt; 上一轮的所有数加上这一轮的数*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n].<span class="built_in">count</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双端队列（STL）"><a href="#双端队列（STL）" class="headerlink" title="双端队列（STL）"></a>双端队列（STL）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    deque&lt;<span class="type">int</span> &gt; dq;</span><br><span class="line">    dq.<span class="built_in">push_front</span>(a); <span class="comment">//添加元素到头</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(a); <span class="comment">//添加元素到尾</span></span><br><span class="line">    </span><br><span class="line">    a = dq.<span class="built_in">front</span>(); <span class="comment">//取出头元素</span></span><br><span class="line">    a = dq.<span class="built_in">back</span>(); <span class="comment">//取出尾元素</span></span><br><span class="line"></span><br><span class="line">    dq.<span class="built_in">pop_front</span>(); <span class="comment">//删除头元素</span></span><br><span class="line">    dq.<span class="built_in">pop_back</span>(); <span class="comment">//删除尾元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速计算a*b % mod的结果（主要目的是换乘法为加法，防止爆数据），或者快速计算a^b % mod 的结果，时间复杂度大大降低。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">q_pow</span><span class="params">(ll a, ll b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)	ans = (ans*a)%mod;</span><br><span class="line">		b /= <span class="number">2</span>;</span><br><span class="line">		a = (a*a)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列(priority_queue)"></a>优先队列(priority_queue)</h2><p>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p>
<p>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</p>
<p>一般是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型</span></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span> <span class="comment">//运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="type">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp2</span> <span class="comment">//重写仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l,r,len;</span><br><span class="line">	<span class="built_in">tmp1</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)&#123;l = a;r = b;len = c;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(len==a.len) <span class="keyword">return</span> l &gt; a.l;</span><br><span class="line">		<span class="keyword">return</span> len &lt; a.len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>insert(x) 可将 x 插入 set 容器中</p>
<p>find(value) 返回 set 中对应值为 value 的迭代器</p>
<p>erase(value) ，value 为所需要删除元素的值。</p>
<p>每次操作都是logn</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>c++中map与unordered_map的区别</p>
<ul>
<li><strong>运行效率方面</strong>：unordered_map最高，而map效率较低但 提供了稳定效率和有序的序列。</li>
<li><strong>占用内存方面</strong>：map内存占用略低，unordered_map内存占用略高,而且是线性成比例的。</li>
</ul>
<h2 id="sqrt精度调整"><a href="#sqrt精度调整" class="headerlink" title="sqrt精度调整"></a>sqrt精度调整</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll x=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">while</span> (x*x&gt;n) x--;</span><br><span class="line"><span class="keyword">while</span> ((x+<span class="number">1</span>)*(x+<span class="number">1</span>)&lt;=n) x++;</span><br></pre></td></tr></table></figure>

<h2 id="预处理小规模组合数"><a href="#预处理小规模组合数" class="headerlink" title="预处理小规模组合数"></a>预处理小规模组合数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">60</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> C[i][j] = (C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>]) % mod;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">2</span>&lt;&lt;<span class="number">14</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">	<span class="type">int</span> temp = n;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">14</span>;j++) <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>) temp -= b[j], cnt++;</span><br><span class="line">	res = <span class="built_in">min</span>(res, cnt + __builtin_popcountll(temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>__builtin_popcountll()函数可求一个数的二进制表示有多少个1</p>
<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><h2 id="简单模板"><a href="#简单模板" class="headerlink" title="简单模板"></a>简单模板</h2><p> <a href="https://vjudge.csgrandeur.cn/problem/HDU-2222/origin">HDU - 2222 </a></p>
<p>给定 <code>n</code> 个长度不超过 50 的由小写英文字母组成的单词准备查询，以及一篇长为 <code>m</code> 的文章，问：文中出现了多少种待查询的单词。多组数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ms(a,b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> * <span class="number">55</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>],fail[N];<span class="comment">//tire树 和 失匹指针</span></span><br><span class="line"><span class="type">int</span> idx,cnt[N];</span><br><span class="line"><span class="type">char</span> s[M];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span> <span class="comment">//tire插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>,l = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u = s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!tr[p][u]) tr[p][u] = ++idx;</span><br><span class="line">		p = tr[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getfail</span><span class="params">()</span> <span class="comment">//获取fail</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//BFS遍历每一层</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="comment">//遍历第一层，初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!tr[p][i]) tr[p][i] = tr[fail[p]][i]; <span class="comment">//如果当前节点i不存在</span></span><br><span class="line">			                                         <span class="comment">//则让这个【节点】指向它的父亲节点的fail指针                                                      //所指向的节点i</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">//否则就让当前【节点i的fail】指向它的父亲节点的fail指针所指向的节点i</span></span><br><span class="line">			&#123;</span><br><span class="line">				fail[tr[p][i]] = tr[fail[p]][i];</span><br><span class="line">				q.<span class="built_in">push</span>(tr[p][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>,ans = <span class="number">0</span>,l = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u = s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		p = tr[p][u];</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> j = p;</span><br><span class="line">		<span class="keyword">while</span>(j) <span class="comment">//一直向上找</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans += cnt[j];</span><br><span class="line">			cnt[j] = <span class="number">0</span>;</span><br><span class="line">			j = fail[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ms</span>(tr,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">ms</span>(fail,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">ms</span>(cnt,<span class="number">0</span>);</span><br><span class="line">	idx = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">		<span class="built_in">insert</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">getfail</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h2><p>1、如果两个元素已经在一个集合中，不需要合并操作（尤其是有边权的时候，会导致边权翻倍）</p>
<h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h2><p><a href="https://www.acwing.com/problem/content/description/838/">836. 合并集合 - AcWing题库</a></p>
<p>一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p>
<p>现在要进行 mm 个操作，操作共有两种：</p>
<ol>
<li><code>M a b</code>，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li>
<li><code>Q a b</code>，询问编号为 a 和 b 的两个数是否在同一个集合中；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N],a,b;</span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">//路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p><a href="https://www.acwing.com/problem/content/242/">240. 食物链 - AcWing题库</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,op;</span><br><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p[x]!=x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = <span class="built_in">find</span>(p[x]); <span class="comment">//先压缩路径</span></span><br><span class="line">		d[x] += d[p[x]]; <span class="comment">//再更新权值</span></span><br><span class="line">		p[x] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i] = i;</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(a&gt;n||b&gt;n) res ++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> pa = <span class="built_in">find</span>(a);</span><br><span class="line">			<span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">			<span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(pa==pb&amp;&amp;(d[a]-d[b])%<span class="number">3</span>) res++;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">				&#123;</span><br><span class="line">					p[pa] = pb;</span><br><span class="line">					d[pa] = d[b] - d[a]; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(pa==pb&amp;&amp;(d[a]-d[b]<span class="number">-1</span>)%<span class="number">3</span>) res++;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">				&#123;</span><br><span class="line">					p[pa] = pb;</span><br><span class="line">					d[pa] = d[b]+<span class="number">1</span>-d[a];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><a href="https://www.acwing.com/problem/content/description/241/">239. 奇偶游戏 - AcWing题库</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!mp[x]) mp[x] = ++cnt;</span><br><span class="line">	<span class="keyword">return</span> mp[x]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p[x] != x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = <span class="built_in">find</span>(p[x]);</span><br><span class="line">		d[x] ^= d[p[x]];</span><br><span class="line">		p[x] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s&quot;</span>,&amp;a,&amp;b,op);</span><br><span class="line">		a = <span class="built_in">get</span>(a<span class="number">-1</span>);</span><br><span class="line">		b = <span class="built_in">get</span>(b);</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;o&#x27;</span>) t = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> pa = <span class="built_in">find</span>(a) , pb = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pa==pb)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(d[a]^d[b]!=t)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = i<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p[pa] = pb;</span><br><span class="line">			d[pa] = d[a]^d[b]^t;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h2><p><img src="https://s2.loli.net/2022/06/28/T9N2gpiSZXf54Yk.jpg" alt="2675_e50e111055-4"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>, Base = N / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.<span class="built_in">count</span>(x) == <span class="number">0</span>) &#123;</span><br><span class="line">        S[x] = ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = m;  <span class="comment">//如果无矛盾, 输出问题数量, 初始的时候为m</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        string type;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; type;</span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);  <span class="comment">// s[a-1], s[b]</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;even&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a + Base) == <span class="built_in">find</span>(b)||<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b+Base)) &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a + Base)] = <span class="built_in">find</span>(b + Base);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)||<span class="built_in">find</span>(a+Base)==<span class="built_in">find</span>(b+Base)) &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a + Base)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b + Base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>树状数组作用：<br>1.快速求前缀和<code>O(log n)</code><br>2.修改某一个数<code>O(log n)</code></p>
<p>3.求数组逆序对</p>
<p><img src="https://s2.loli.net/2022/06/29/9iEmkKQPYqts4M3.png" alt="树状数组.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lowbit:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line">查询：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) sum+=tr[i];</span><br><span class="line">更改：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=c;</span><br></pre></td></tr></table></figure>

<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>最坏情况下时间复杂度有$O(4×nlogn)$，全局longlong，输入输出都会影响复杂度</p>
<h2 id="懒标记线段树"><a href="#懒标记线段树" class="headerlink" title="懒标记线段树"></a>懒标记线段树</h2><p>可以使用懒标记的操作有：区间加减，区间乘除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N =  <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">	ll l,r,lazy,sum;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line">ll temp_num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[i].sum = tree[i*<span class="number">2</span>].sum + tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[i].lazy)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i*<span class="number">2</span>].lazy += tree[i].lazy;</span><br><span class="line">		tree[i*<span class="number">2</span>+<span class="number">1</span>].lazy += tree[i].lazy;</span><br><span class="line">		tree[i*<span class="number">2</span>].sum += (tree[i*<span class="number">2</span>].r - tree[i*<span class="number">2</span>].l + <span class="number">1</span>) * tree[i].lazy;</span><br><span class="line">		tree[i*<span class="number">2</span>+<span class="number">1</span>].sum += (tree[i*<span class="number">2</span>+<span class="number">1</span>].r - tree[i*<span class="number">2</span>+<span class="number">1</span>].l + <span class="number">1</span>) * tree[i].lazy;</span><br><span class="line">		tree[i].lazy = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l ,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[i].l = l;</span><br><span class="line">	tree[i].r = r;</span><br><span class="line">	tree[i].lazy = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i].sum = temp_num[l];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> mid = tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(i*<span class="number">2</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(i*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r,ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i].sum += (tree[i].r - tree[i].l + <span class="number">1</span>)*num;</span><br><span class="line">		tree[i].lazy += num;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> mid = tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(i);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) <span class="built_in">add</span>(i*<span class="number">2</span>,l,r,num);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">add</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r,num);</span><br><span class="line">	<span class="built_in">pushup</span>(i);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> tree[i].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">pushdown</span>(i);</span><br><span class="line">	<span class="type">int</span> mid = tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ll s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) s += <span class="built_in">query</span>(i*<span class="number">2</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) s += <span class="built_in">query</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="势能线段树"><a href="#势能线段树" class="headerlink" title="势能线段树"></a>势能线段树</h2><p>某些修改存在一些奇妙的性质，使得序列每个元素被修改的次数有一个<strong>上限</strong>(如开方)</p>
<p>可以在线段树每个节点上记录一个值，<strong>表示对应区间内是否每个元素都达到修改次数上限</strong></p>
<p>区间修改时暴力递归到叶子节点，如果途中遇到一个节点，这个节点的对应区间内每个元素都达到修改次数上限则在这个节点 return 掉</p>
<p>可以证明复杂度为 $O(nlogn ×修改次数上限)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum,cnt[<span class="number">25</span>];</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[i].sum = (tr[i&lt;&lt;<span class="number">1</span>].sum + tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">        tr[i].cnt[j] = tr[i&lt;&lt;<span class="number">1</span>].cnt[j] + tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[i].l = l,tr[i].r = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        tr[i].sum = (a[l]*a[l])%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">            tr[i].cnt[j] = a[l]&gt;&gt;j&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l==tr[i].r) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tr[i].cnt[j]&amp;&amp;(x&gt;&gt;j&amp;<span class="number">1</span>)) sum|=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">            <span class="keyword">else</span> tr[i].cnt[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tr[i].sum = (ll)sum*sum%mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r) &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[i].cnt[j]&amp;&amp;(x&gt;&gt;j&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=l) <span class="built_in">modify</span>(i&lt;&lt;<span class="number">1</span>,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) <span class="built_in">modify</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x);</span><br><span class="line">    <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r) <span class="keyword">return</span> tr[i].sum;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=l) s = <span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>,l,r)%mod;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) s = (s+<span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%mod;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="type">int</span> op,l,r,x;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l,r)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="杂选题"><a href="#杂选题" class="headerlink" title="杂选题"></a>杂选题</h2><h3 id="导弹拦截"><a href="#导弹拦截" class="headerlink" title="导弹拦截"></a>导弹拦截</h3><p>[P1020 <a href="https://www.luogu.com.cn/problem/P1020">NOIP1999 普及组] 导弹拦截 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>DP + 贪心 + 二分  <strong>O(nlogn)</strong></p>
<p><strong>Dilworth 定理</strong></p>
<p>将拦截的导弹的高度提出来成为原高度序列的一个子序列，根据题意这个子序列中的元素是单调不增的（即后一项总是不大于前一项），我们称为<strong>单调不升子序列</strong>。本问所求能拦截到的最多的导弹，即求<strong>最长的单调不升子序列</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> n,cnt;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[++n]));</span><br><span class="line">    n--;</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>; <span class="comment">//初始化一个最大值，防止边界溢出</span></span><br><span class="line">    <span class="type">int</span> l,r,len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l = <span class="number">0</span>,r = len;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(b[mid]&gt;=a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = r+<span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[i]); <span class="comment">//记录答案</span></span><br><span class="line">        b[r+<span class="number">1</span>] = a[i]; <span class="comment">//更新当前 长度+1 的序列中最大的最后一位数</span></span><br><span class="line">        len = <span class="built_in">max</span>(len,r+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    t[<span class="number">1</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>,r = res;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t[mid]&gt;=a[i]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t[r]&gt;=a[i]) t[r] = a[i];</span><br><span class="line">        <span class="keyword">else</span> t[++res] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从左到右依次枚举每个导弹。假设现在有若干个导弹拦截系统可以拦截它，那么我们肯定选择这些系统当中位置最低的那一个。如果不存在任何一个导弹拦截系统可以拦截它，那我们只能新加一个系统了</p>
<p>观察第二问的代码，与第一问进行比较，可以发现这段代码<strong>等价于</strong>计算最长上升子序列（严格上升，即后一项大于前一项）。这其实是 <strong>Dilworth 定理</strong>（将一个序列剖成若干个单调不升子序列的最小个数等于该序列最长上升子序列的个数），本处从代码角度证明了该结论。</p>
<h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> w[N][N],v[N][N],f[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,V;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;V);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;v[i][j],&amp;w[i][j]);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=s[i];k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=v[i][k]) f[j] = <span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[V]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line">ll f[N][N];</span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ms</span>(f,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++) &#123; <span class="comment">//枚举区间长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=len;j&lt;=n;i++,j++) &#123; <span class="comment">//枚举区间左右下标</span></span><br><span class="line">            <span class="keyword">if</span>(i==j) &#123; <span class="comment">//初始化区间长度为1的值</span></span><br><span class="line">                f[i][j] = a[i]*b[n];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j],f[i][j<span class="number">-1</span>]+b[n-(j-i)]*a[j]);</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j],f[i+<span class="number">1</span>][j]+b[n-(j-i)]*a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p><a href="https://www.acwing.com/problem/content/287/">285. 没有上司的舞会 - AcWing题库</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6050</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[N];<span class="comment">//储存每个上司的儿子</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][0] 不选i，子树的最大值 </span></span><br><span class="line"><span class="comment">f[i][1] 选i，子树的最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//边界</span></span><br><span class="line">    f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>] = a[u];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:son[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[i][<span class="number">0</span>];</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[i][<span class="number">1</span>],f[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> root = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        root -= u;</span><br><span class="line">        son[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(f[root][<span class="number">1</span>],f[root][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h3><p>换根DP 一般分为三个步骤：</p>
<p>指定任意一个根节点<br>一次dfs遍历，统计出当前子树内的节点对当前节点的贡献</p>
<p>一次dfs遍历，统计出当前节点的父节点对当前节点的贡献，然后合并统计答案</p>
<p>那么我们就要先 dfs 一遍，预处理出当前子树对于根的最大贡献（距离）和 次大贡献（距离）</p>
<p>处理 次大贡献（距离） 的原因是：</p>
<p>如果 当前节点 是其 父节点子树 的 最大路径 上的点，则 父节点子树 的 最大贡献 不能算作对该节点的贡献</p>
<p>因为我们的路径是 简单路径，不能 走回头路</p>
<p>然后我们再 dfs 一遍，求解出每个节点的父节点对他的贡献（即每个节点往上能到的最远路径</p>
<p>两者比较，取一个 max 即可</p>
<p><img src="https://s2.loli.net/2022/08/04/7sEvdAyQIuW5Fbr.png" alt="image-20220726183319977"></p>
<p><a href="https://www.acwing.com/problem/content/1075/">1073. 树的中心 - AcWing题库</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line">vector&lt;PII &gt; son[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> dow[N]; <span class="comment">//记录i结点的最长子节点,即i与dow[i]连接时获得的值最大;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> <span class="comment">//向下找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v = i.first, w = i.second;</span><br><span class="line">		<span class="keyword">if</span>(fa==v) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs1</span>(v,u);</span><br><span class="line">		<span class="type">int</span> dist = f[v][<span class="number">0</span>] + w;</span><br><span class="line">		<span class="keyword">if</span>(dist&gt;f[u][<span class="number">0</span>]) <span class="built_in">swap</span>(f[u][<span class="number">0</span>],f[u][<span class="number">1</span>]), f[u][<span class="number">0</span>] = dist, dow[u] = v;</span><br><span class="line">		<span class="keyword">else</span> f[u][<span class="number">1</span>] = <span class="built_in">max</span>(f[u][<span class="number">1</span>],dist);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> <span class="comment">//向上找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v = i.first, w = i.second;</span><br><span class="line">		<span class="keyword">if</span>(fa==v) <span class="keyword">continue</span>;</span><br><span class="line">		f[v][<span class="number">2</span>] = w;</span><br><span class="line">		<span class="keyword">if</span>(v==dow[u]) f[v][<span class="number">2</span>] += <span class="built_in">max</span>(f[u][<span class="number">2</span>],f[u][<span class="number">1</span>]); </span><br><span class="line">		<span class="keyword">else</span> f[v][<span class="number">2</span>] += <span class="built_in">max</span>(f[u][<span class="number">2</span>],f[u][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">dfs2</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		son[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">		son[b].<span class="built_in">push_back</span>(&#123;a,c&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> res = f[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		res = <span class="built_in">min</span>(res, <span class="built_in">max</span>(f[i][<span class="number">0</span>],f[i][<span class="number">2</span>]));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h3><p><a href="https://ac.nowcoder.com/acm/problem/50510">皇宫看守 (nowcoder.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1510</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[N];</span><br><span class="line"><span class="type">int</span> st[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    f[i][0] 对于i这个子树，i点由 其父 节点看守的最小花费</span></span><br><span class="line"><span class="comment">    f[i][1] 对于i这个子树，i点由 其子 节点看守的最小花费</span></span><br><span class="line"><span class="comment">    f[i][2] 对于i这个子树，i点由 本身 节点看守的最小花费</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>] = inf;</span><br><span class="line">    f[u][<span class="number">2</span>] = w[u];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i,u);</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]);</span><br><span class="line">        f[u][<span class="number">2</span>] += <span class="built_in">min</span>(f[i][<span class="number">0</span>],<span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]));</span><br><span class="line">        sum += <span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa) <span class="keyword">continue</span>;</span><br><span class="line">        f[u][<span class="number">1</span>] = <span class="built_in">min</span>(f[u][<span class="number">1</span>], sum - <span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]) + f[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        w[a] = b;</span><br><span class="line">        cin&gt;&gt;b;</span><br><span class="line">        <span class="keyword">while</span>(b--) &#123;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            son[a].<span class="built_in">push_back</span>(c);</span><br><span class="line">            son[c].<span class="built_in">push_back</span>(a);</span><br><span class="line">            st[c] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(st[root]) root++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(f[root][<span class="number">1</span>],f[root][<span class="number">2</span>])&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">10</span>) + <span class="number">10</span>;</span><br><span class="line">ll f[<span class="number">12</span>][<span class="number">110</span>][N]; <span class="comment">//f[i][j][k] 第i行放置了j个将军，状态为k的所有方案</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line">vector&lt;<span class="type">int</span> &gt; a,b[N]; <span class="comment">//a放置合法状态,b放置a的合法转移状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//检查x有没有两个相邻的1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(x&amp;x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//获得x中有几个1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) c += (x&gt;&gt;i &amp; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(i)) a.<span class="built_in">push_back</span>(i), cnt[i] = <span class="built_in">count</span>(i); <span class="comment">//储存所有的合法状态</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i : a) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> j : a) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(i|j)&amp;&amp;((i&amp;j)==<span class="number">0</span>)) b[i].<span class="built_in">push_back</span>(j); <span class="comment">//储存所有的合法转移状态,i状态的上下行可以是j</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) <span class="comment">//n行转移，n+1行是为了好统计答案</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++) <span class="comment">//目前使用的国王棋子数量</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> k : a)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> u : b[k]) &#123;</span><br><span class="line">					<span class="type">int</span> c = cnt[k]; <span class="comment">//查看a中有几个已经放置的国王</span></span><br><span class="line">					<span class="keyword">if</span>(j&gt;=c) <span class="comment">//目前一共放j个国王，从b转移到a，要满足国王数不超标</span></span><br><span class="line">                        f[i][j][k] += f[i<span class="number">-1</span>][j-c][u];</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;f[n+<span class="number">1</span>][k][<span class="number">0</span>]&lt;&lt;endl; <span class="comment">//第n+1行什么都不放，相当于只在1~n行放国王，目前一共放了k个国王的总方案数，其实就是答案要求的方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> temp[N], s[<span class="number">2</span> * N];<span class="comment">//temps是原字符串,s是处理后的字符串</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span> * N]; <span class="comment">// p[i]-1 是对于s串，以i个字符为中心的最长回文串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    s[cnt++] = <span class="string">&#x27;@&#x27;</span>; <span class="comment">//左边界字符</span></span><br><span class="line">    s[cnt++] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">//填充字符</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(temp + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[cnt++] = temp[i];</span><br><span class="line">        s[cnt++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[cnt] = <span class="string">&#x27;!&#x27;</span>; <span class="comment">//右边界字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">            p[i] = <span class="built_in">min</span>(mx - i, p[<span class="number">2</span> * id - i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[i - p[i]] == s[i + p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = p[i] + i;</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">初始化：一般不需要</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="数Math"><a href="#数Math" class="headerlink" title="数Math"></a>数Math</h1><h2 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">去掉最后一位  	x &gt;&gt; 1</span></span><br><span class="line"><span class="comment">在最后加一个0 	x &lt;&lt; 1</span></span><br><span class="line"><span class="comment">在最后加一个1		(x &lt;&lt; 1) - 1</span></span><br><span class="line"><span class="comment">把最后一位变成1	x | 1</span></span><br><span class="line"><span class="comment">把最后一位变成0	(x | 1) - 1</span></span><br><span class="line"><span class="comment">最后一位取反		 x ^ 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">把右数第k位变成0	x &amp; (~(1 &lt;&lt; (k-1)))</span></span><br><span class="line"><span class="comment">把右数第k位取反	x ^ ((1 &lt;&lt; (k-1)))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">取末k位		  x &amp; ((1 &lt;&lt; k) - 1)</span></span><br><span class="line"><span class="comment">取右数第k位		 (x &gt;&gt; (k-1)) &amp; 1</span></span><br><span class="line"><span class="comment">把末k位变成1		 x | ((1 &lt;&lt; k) - 1)</span></span><br><span class="line"><span class="comment">末k位取反		  x ^ ((1 &lt;&lt; k) - 1)</span></span><br><span class="line"><span class="comment">把右边连续的1变成0 (x &amp; (x + 1))</span></span><br><span class="line"><span class="comment">把右边第一个0变成1  x | (x + 1) </span></span><br><span class="line"><span class="comment">把右边连续的0变成1	x | (x - 1)</span></span><br><span class="line"><span class="comment">取右边连续的1 	 (x ^ (x + 1)) &gt;&gt; 1</span></span><br><span class="line"><span class="comment">去掉右起第一个1的左边(lowbit)  x &amp; ( -x )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="gcd-lcm"><a href="#gcd-lcm" class="headerlink" title="gcd &amp; lcm"></a>gcd &amp; lcm</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辗转相除，它们的最大公约数等于a除以b的余数c和b之间的最大公约数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">return</span> b&gt;<span class="number">0</span> ? <span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lcm代码如下：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;<span class="comment">//防溢出 ， 很妙啊 ，大家可以记一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更相减损，两个正整数a和b（a&gt;b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数，避免了大整数取模，但是运算次数较多。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a-b,b);</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b-a,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><h3 id="算术基本定理（唯一分解"><a href="#算术基本定理（唯一分解" class="headerlink" title="算术基本定理（唯一分解"></a>算术基本定理（唯一分解</h3><p>就是因式分解的定理，所有的整数都可以唯一分解成若干个质因子乘积的形式：</p>
<p>$N &#x3D; P_1^{a1}\times P_2^{a2}\times … \times P_k^{ak}$ 其中 $P_i$ 是质数，每一个 $a_i \geq 0$</p>
<h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//求出n的所有约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i != n / i) &#123;  <span class="comment">// 避免 i==n/i, 重复放入 （n是完全平方数）</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : res) &#123;</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><h3 id="筛法求素数——线性筛法（欧拉筛法）"><a href="#筛法求素数——线性筛法（欧拉筛法）" class="headerlink" title="筛法求素数——线性筛法（欧拉筛法）"></a>筛法求素数——线性筛法（欧拉筛法）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> st[N];</span><br><span class="line">vector&lt;<span class="type">int</span> &gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxnum = N<span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=maxnum;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]&lt;=maxnum/i;j++) &#123;</span><br><span class="line">            st[i*primes[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p><img src="https://s2.loli.net/2022/11/28/ZfrhuQjXKT4OGdB.jpg" alt="1.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,res;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        res = a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=a/i;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(a%i==<span class="number">0</span>)</span><br><span class="line">                    a/=i;</span><br><span class="line">                res = res / i*(i<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">1</span>) res = res /a*(a<span class="number">-1</span>);</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h2><p><img src="https://s2.loli.net/2022/11/29/5kSTrqy7gLsD1NX.jpg" alt="6B8715BC-6CB8-4C2F-99BC-8762C6959443.jpeg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[primes[j] * i] = phi[i] * primes[j]; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[primes[j] * i] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂求逆元（费马小定理）"><a href="#快速幂求逆元（费马小定理）" class="headerlink" title="快速幂求逆元（费马小定理）"></a>快速幂求逆元（费马小定理）</h2><p>$a &#x2F; b ≡ a * x (mod n)$<br>两边同乘b可得 $a ≡ a * b * x (mod n)$<br>即 $1 ≡ b * x (mod n)$<br>同 $b * x ≡ 1 (mod n)$<br>由费马小定理可知，当n为质数时<br>$b ^ {(n - 1)} ≡ 1 (mod n)$<br>拆一个b出来可得 $b * b ^ {(n - 2)} ≡ 1 (mod n)$<br>故当n为质数时，b的乘法逆元 $x &#x3D; b ^{ (n - 2)}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">q_pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = (res * a)%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a = (a * a)%p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,p;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;p;</span><br><span class="line">    <span class="keyword">if</span>(__gcd(a,p)==<span class="number">1</span>) cout&lt;&lt;<span class="built_in">q_pow</span>(a,p<span class="number">-2</span>,p)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展欧几里得求逆元"><a href="#扩展欧几里得求逆元" class="headerlink" title="扩展欧几里得求逆元"></a>扩展欧几里得求逆元</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> &amp;x, <span class="type">long</span> <span class="type">long</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (x % b + b) % b);<span class="comment">//这里防止出现负数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a , ll b , ll modd)</span></span>&#123;		<span class="comment">//快速幂 </span></span><br><span class="line">	ll ans = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)	ans = ans * a % modd ;</span><br><span class="line">		a = a * a % modd ;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n , ll m)</span></span>&#123;			<span class="comment">//组合数Cnm的值 </span></span><br><span class="line">	ll ans1 = <span class="number">1</span> , ans2 = <span class="number">1</span> , ans3 = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">		ans1 = ans1 * i % mod ;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= m ; i++)</span><br><span class="line">		ans2 = ans2 * i % mod ;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= n - m ; i++)</span><br><span class="line">		ans3 = ans3 * i % mod ;</span><br><span class="line">	<span class="keyword">return</span> ans1 * <span class="built_in">qpow</span>(ans2 , mod - <span class="number">2</span> , mod) % mod * <span class="built_in">qpow</span>(ans3 , mod - <span class="number">2</span> , mod) % mod ;</span><br><span class="line">	<span class="comment">//费马小定理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="临时"><a href="#临时" class="headerlink" title="临时"></a>临时</h1><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><p>给定长度为 N 的整数序列 AA，下标为 1∼N。</p>
<p>现在要执行 MM 次操作，其中第 ii 次操作为给出三个整数 li,ri,ki，求$A[li],A[li+1],…,A[ri](即 A 的下标区间 [li,ri][li,ri]) $中第 ki 小的数是多少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="type">int</span> idx; <span class="comment">//用来搞下标</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r; <span class="comment">// 这里的l,r存的是左右儿子的下标,这里的区间需要自己推一下</span></span><br><span class="line">    <span class="type">int</span> cnt; <span class="comment">// 在这个点包含的区间里面有多少个数字</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span> + N* <span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> root[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回的是一个下标 这个下标从0开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),x) - nums.<span class="built_in">begin</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = ++idx;<span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> p; <span class="comment">// 代表到了叶子节点</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    tr[p].l = <span class="built_in">build</span>(l,mid); <span class="comment">// tr[]数组里面的l,r是自己左右儿子的下标 不是p这个点所代表的范围</span></span><br><span class="line">    tr[p].r = <span class="built_in">build</span>(mid + <span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = ++idx; <span class="comment">// 这是现在的节点</span></span><br><span class="line">    tr[now] = tr[pre]; <span class="comment">//这个节点会继承前一个版本的所有信息</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="comment">// 代表到了叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[now].cnt++; <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 下一个insert的前驱就是这个insert的前驱的左右儿子,因为x在的位置区间,都需要修改</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)<span class="comment">// 代表这个点在左边 ,</span></span><br><span class="line">    tr[now].l = <span class="built_in">insert</span>(tr[pre].l,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在右边</span></span><br><span class="line">    tr[now].r = <span class="built_in">insert</span>(tr[pre].r,mid + <span class="number">1</span>,r,x);</span><br><span class="line"></span><br><span class="line">    tr[now].cnt = tr[tr[now].l].cnt + tr[tr[now].r].cnt; <span class="comment">// 当前这个节点的cnt是左儿子的节点 + 右儿子的节点</span></span><br><span class="line">    <span class="comment">// 相当于pushup操作</span></span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> r;<span class="comment">// 代表到了叶子节点,也就是找到了这个点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = tr[tr[now].l].cnt - tr[tr[pre].l].cnt; <span class="comment">// 代表在询问区间L,R里面有几个数字</span></span><br><span class="line">    <span class="comment">// 前R个版本你在l,r里面有tr[tr[now].l].cnt 数字</span></span><br><span class="line">    <span class="comment">// 前L - 1个版本里面你在l,r里面有tr[tr[pre].l].cnt个数字</span></span><br><span class="line">    <span class="comment">// 那在[L,R]这个版本里面你在l,r里面就是有tr[tr[now].l].cnt - tr[tr[pre].l].cnt个数字</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= k) ans = <span class="built_in">query</span>(tr[pre].l,tr[now].l,l,mid,k); <span class="comment">// 代表你想要找的在区间左边 还是要找第k个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 右区间</span></span><br><span class="line">    ans = <span class="built_in">query</span>(tr[pre].r,tr[now].r,mid + <span class="number">1</span>,r,k - cnt);<span class="comment">//在右边就是找 第k - cnt个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 建立一下线段树的整体框架,因为框架是不变的,变的是里面的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++ ) <span class="comment">//接下来就是每一个版本了</span></span><br><span class="line">    &#123;</span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>],<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>,<span class="built_in">find</span>(a[i])); <span class="comment">// 可持久化数据结构都是联系自己前一个版本的信息</span></span><br><span class="line">        <span class="comment">//find(a[i]) 就是加入数字离散化下的下标 这里当成这个数字在用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; nums[<span class="built_in">query</span>(root[l - <span class="number">1</span>],root[r],<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>,k)] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="tire"><a href="#tire" class="headerlink" title="tire"></a>tire</h2><p>在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？</p>
<blockquote>
<p>字典树的初始化：只需要将0~idx之间的节点初始化即可，时间复杂度为线性</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N=<span class="number">100010</span>,M=<span class="number">31</span>*N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>],idx;</span><br><span class="line"><span class="comment">//M代表一个数字串二进制可以到多长</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;  <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;   <span class="comment">/////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx; <span class="comment">///如果插入中发现没有该子节点,开出这条路</span></span><br><span class="line">        p=son[p][u]; <span class="comment">//指针指向下一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;                               <span class="comment">///从最大位开始找</span></span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u]) <span class="comment">////如果当前层有对应的不相同的数</span></span><br><span class="line">        &#123;   <span class="comment">///p指针就指到不同数的地址</span></span><br><span class="line"></span><br><span class="line">          p=son[p][!u];</span><br><span class="line">          res=res*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">             <span class="comment">///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001</span></span><br><span class="line">        &#125;                                                       <span class="comment">///       010 </span></span><br><span class="line">        <span class="keyword">else</span>                                            <span class="comment">////          ---&gt;011                                                                           //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=son[p][u];</span><br><span class="line">            res=res*<span class="number">2</span>+<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        res=<span class="built_in">max</span>(res,<span class="built_in">search</span>(a[i]));  <span class="comment">///search(a[i])查找的是a[i]值的最大与或值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[N],p[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d%s&quot;</span>,&amp;n,p+<span class="number">1</span>,&amp;m,s+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求ne</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>pythoncincout.md</title>
    <url>/2023/09/24/python%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>确保您已经安装了<code>pandas</code>和<code>openpyxl</code>库（如果您的Python版本是3.8以下），然后按照下面的步骤进行操作：</p>
<ol>
<li>创建并输入样本数据到TXT文件（sample.txt）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制代码<span class="comment"># 打开文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># 写入数据</span></span><br><span class="line">    file.write(<span class="string">&quot;Hello, World!\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;This is a sample text file.\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;It contains multiple lines of text.&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>创建并输入样本数据到CSV文件（sample.csv）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Gender&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;John&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;Male&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;Alice&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;Female&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;Male&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件并写入数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerows(data)</span><br></pre></td></tr></table></figure>

<ol>
<li>创建并输入样本数据到Excel文件（sample.xlsx）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">28</span>],</span><br><span class="line">    <span class="string">&#x27;Gender&#x27;</span>: [<span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;Female&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将DataFrame写入Excel文件</span></span><br><span class="line">df.to_excel(<span class="string">&#x27;sample.xlsx&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>使用Python读取这三种文件：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取TXT文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    txt_data = file.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">csv_data = pd.read_csv(<span class="string">&#x27;sample.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取Excel文件</span></span><br><span class="line">excel_data = pd.read_excel(<span class="string">&#x27;sample.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;TXT 文件内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(txt_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nCSV 文件内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(csv_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nExcel 文件内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(excel_data)</span><br></pre></td></tr></table></figure>

<p>这样，您就可以创建并输入样本数据到TXT、CSV和Excel文件，并使用Python读取这三种文件了。请注意，这些示例代码假设您当前的工作目录中已经有了相应的文件。如果不是，请确保将文件路径调整为正确的位置。</p>
]]></content>
  </entry>
  <entry>
    <title>英语</title>
    <url>/2023/09/22/%E8%8B%B1%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="bios-牵连"><a href="#bios-牵连" class="headerlink" title="bios 牵连"></a>bios 牵连</h1><h2 id="main-重要设置"><a href="#main-重要设置" class="headerlink" title="main 重要设置"></a>main 重要设置</h2><p>小结：在Main界面中，会展示一些硬件方面的详细信息，比如biso版本、主板的名称或者是处理器的信息，还有一级缓存等等。</p>
<p>另外，一些重要的设置，比如系统时间以及日期设置。</p>
<p>processor 处理器</p>
<p>settings 设置</p>
<p>system 系统</p>
<p>time 时间</p>
<p>date 日期</p>
<p>version 版本</p>
<p>product 产品</p>
<p>service 服务</p>
<p>tag 标签</p>
<p>type 类型</p>
<p>speed 速度</p>
<p>cpu id用户计算机信息</p>
<p>cache  缓存</p>
<p>L1 一级</p>
<p>fixed 固定</p>
<p>hdd 硬盘</p>
<p>sata 串口</p>
<p>odd 光盘</p>
<p>device 模式</p>
<p>esata device 设置串口模式</p>
<p>ac adapter type ac适配器类型</p>
<p>memory 内存</p>
<p>extended 扩展</p>
<h2 id="advanced-高级设置"><a href="#advanced-高级设置" class="headerlink" title="advanced 高级设置"></a>advanced 高级设置</h2><p>小结：主要针对主板硬件上的功能，比如虚拟化激活、集成网卡、USB相关的设置等等。都可以在这个页面直接设置。</p>
<p>如果要进行sata的设置，也是在这个页面进行的。</p>
<p>enabled 激活的</p>
<p>disabled 无效的</p>
<p>intelspeedstep 因特尔速度步长</p>
<p>Virtual Izat 1on虚拟化</p>
<p>Integrated NIC集成网卡</p>
<p>USB Emulat ion usb仿真</p>
<p>USB Powershare USB电源共享</p>
<p>USB Hake Support USB映醒支持</p>
<p>SATA Operat lon SATA操作</p>
<p>Adapter Harnings 造配器警告</p>
<p>Function Key Behav lor功能健行为</p>
<p>charger Behavior 充电器行为</p>
<p>Miscellaneous Devices 杂项设备设置</p>
<h2 id="security-安全设置"><a href="#security-安全设置" class="headerlink" title="security  安全设置"></a>security  安全设置</h2><p>小结：这个页面是和安全有关的，主要就是设置相关的密码，其中包括管理员密码、系统密码以及启动密码。</p>
<p>另外，你也可以看到密码的状态。</p>
<p>unkocked 解锁</p>
<p>not set未设置</p>
<p>enabied 启动</p>
<p>Unlock Setup status解锁设置状态</p>
<p>Admin Passuord Status管理员密码状态</p>
<p>System Password Status 系统密码状态</p>
<p>HDD Password Status硬盘密码状态</p>
<p>Set Admin Passuord 设置管理员密码</p>
<p>Set System Passuord设置系统密码</p>
<p>Password on Boot启动码</p>
<p>Computrace计算机想踪</p>
<h2 id="BOOT-启动引导设置"><a href="#BOOT-启动引导设置" class="headerlink" title="BOOT-启动引导设置"></a>BOOT-启动引导设置</h2><p>小结：这个启动引导的设置界面，可以说是我们在重装系统时，非常重要的一项设置。</p>
<p>我们在这个页面，设置U盘作为第一启动项，使得电脑在开机时能够读取U盘winpe系统，进入系统重装的页面。</p>
<p>以下这个显示界面就是已经将U盘设置第一启动项了，即1st Boot Priority。</p>
<p>Sot Boot Priority引导设置优先级<br>1st Boot Prlority 第一引导优先级<br>2nd Boot Prlority  第二引导优先级<br>3rd Boot Priority 第三引导优先级<br>4th Boot Prlority 第四引导优先级<br>Sth Boot Prlority 第五引导优先级<br>6th Boot Priority 第六引导优先级</p>
<p>fusB storage Deyice] USB储存设备<br>[Hard Drive]硬盘动<br>lolskette Dr Ive]软磁盘驱动器<br>[CD&#x2F;DVD&#x2F;CD-RH Drive] CD DVD光盘驱动器<br>LeSATAI扩展卡<br>[Netuork]网络</p>
<h2 id="Exit-退出设置"><a href="#Exit-退出设置" class="headerlink" title="Exit-退出设置"></a>Exit-退出设置</h2><p>小结：前面，所有的设置完成之后，可以在这个页面，你可以“保存更改或者重置”、或者“放弃更改或者重置”。</p>
<p>你也可以直接“恢复默认值”，此项设置会将你之前的其他相关设置全部清除，恢复最原始的状态。</p>
<p>Save Changes and Reset保存 改和重置<br>Discard Changes and Reset 放弃更改和重置<br>Restore Def aults天复 认值<br>DIscard Changes放弃更改<br>Save changes保存更改</p>
]]></content>
  </entry>
  <entry>
    <title>图论模板</title>
    <url>/2023/03/22/qsq%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="300-拓扑排序"><a href="#300-拓扑排序" class="headerlink" title="300 拓扑排序"></a><a href="https://www.cnblogs.com/dx123/p/16320427.html">300 拓扑排序</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////Kahn 算法  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N], tp;</span><br><span class="line"><span class="type">int</span> din[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span>(din[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> x=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    tp.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : e[x])&#123;</span><br><span class="line">      <span class="keyword">if</span>(--din[y]==<span class="number">0</span>) q.<span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tp.<span class="built_in">size</span>() == n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    din[b]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">toposort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">auto</span> x:tp)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////DFS 算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N], tp;</span><br><span class="line"><span class="type">int</span> c[N]; <span class="comment">//染色数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  c[x] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[y]&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//有环 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!c[y])</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">dfs</span>(y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  c[x] = <span class="number">1</span>;</span><br><span class="line">  tp.<span class="built_in">push_back</span>(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">    <span class="keyword">if</span>(!c[x])</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">dfs</span>(x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">reverse</span>(tp.<span class="built_in">begin</span>(),tp.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">toposort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x:tp)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓扑序"><a href="#拓扑序" class="headerlink" title="拓扑序"></a>拓扑序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=cnt;x;x--)&#123;</span><br><span class="line">   <span class="keyword">if</span>(dp[x]==<span class="number">0</span>) <span class="comment">//若x为路的起点</span></span><br><span class="line">     dp[x]=nw[x];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> y : ne[x])</span><br><span class="line">     dp[y]=<span class="built_in">max</span>(dp[y],dp[x]+nw[y]);</span><br><span class="line"> &#125; <span class="comment">//在拓扑图上逆序dp</span></span><br></pre></td></tr></table></figure>



<h1 id="301-最短路-Dijkstra-算法"><a href="#301-最短路-Dijkstra-算法" class="headerlink" title="301 最短路 Dijkstra 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320431.html">301 最短路 Dijkstra 算法</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define inf 2147483647</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">int n,m,s,a,b,c;</span><br><span class="line">struct edge&#123;int v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">int d[N], vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">  for(int i=0;i&lt;=n;i++) d[i]=inf;</span><br><span class="line">  d[s]=0; q.push(&#123;0,s&#125;);</span><br><span class="line">  while(q.size())&#123;</span><br><span class="line">    auto t=q.top(); q.pop();</span><br><span class="line">    int u=t.second;</span><br><span class="line">    if(vis[u])continue;//再出队跳过</span><br><span class="line">    vis[u]=1;//标记u已出队</span><br><span class="line">    for(auto ed : e[u])&#123;</span><br><span class="line">      int v=ed.v, w=ed.w;</span><br><span class="line">      if(d[v]&gt;d[u]+w)&#123;</span><br><span class="line">        d[v]=d[u]+w;</span><br><span class="line">        q.push(&#123;-d[v],v&#125;);//大根堆</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">  for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    e[a].push_back(&#123;b,c&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  dijkstra(s);</span><br><span class="line">  for(int i=1;i&lt;=n;i++)</span><br><span class="line">    printf(&quot;%d &quot;,d[i]); </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;LL v,c,ne;&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="comment">//e[i].b  出边</span></span><br><span class="line">    <span class="comment">//e[i].c  边权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大根堆重构"><a href="#大根堆重构" class="headerlink" title="大根堆重构"></a>大根堆重构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node&amp; a, <span class="type">const</span> Node&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value &lt; b.value; <span class="comment">//将value的值由大到小排列，形成Node的大根堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="302-最短路-Bellman-Ford-算法-spfa-算法-判负环"><a href="#302-最短路-Bellman-Ford-算法-spfa-算法-判负环" class="headerlink" title="302 最短路 Bellman-Ford 算法 spfa 算法 判负环"></a><a href="https://www.cnblogs.com/dx123/p/16320435.html">302 最短路 Bellman-Ford 算法 spfa 算法 判负环</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Ford 判负环 740ms</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const int N=2010,M=6010;</span><br><span class="line">int n,m;</span><br><span class="line">int to[M],ne[M],w[M],h[N],tot;</span><br><span class="line">int d[N];</span><br><span class="line"></span><br><span class="line">void add(int a,int b,int c)&#123;</span><br><span class="line">  to[++tot]=b;w[tot]=c;</span><br><span class="line">  ne[tot]=h[a];h[a]=tot;</span><br><span class="line">&#125;</span><br><span class="line">bool ford()&#123;</span><br><span class="line">  memset(d,inf,sizeof d); d[1]=0;</span><br><span class="line">  bool flag; //是否松弛</span><br><span class="line">  for(int i=1;i&lt;=n;i++)&#123; //跑n轮</span><br><span class="line">    flag=false;</span><br><span class="line">    for(int u=1;u&lt;=n;u++)&#123; //n个点</span><br><span class="line">      if(d[u]==inf)continue;</span><br><span class="line">      for(int j=h[u];j;j=ne[j])&#123;</span><br><span class="line">        int v=to[j];</span><br><span class="line">        if(d[v]&gt;d[u]+w[j])&#123;</span><br><span class="line">          d[v]=d[u]+w[j];</span><br><span class="line">          flag=true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)break;</span><br><span class="line">  &#125;</span><br><span class="line">  return flag; //第n轮=true,有负环</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  int T;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">  while(T--)&#123;</span><br><span class="line">    tot=0; memset(h,0,sizeof(h));</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">      int u,v,w;</span><br><span class="line">      scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      add(u,v,w);</span><br><span class="line">      if(w&gt;=0)add(v,u,w);;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(ford()?&quot;YES&quot;:&quot;NO&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="303-最短路-Floyd-算法"><a href="#303-最短路-Floyd-算法" class="headerlink" title="303 最短路 Floyd 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320442.html">303 最短路 Floyd 算法</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=210,M=20010;</span><br><span class="line">int n,m,a,b,c;</span><br><span class="line">int d[N][N];</span><br><span class="line"></span><br><span class="line">void floyd()&#123;</span><br><span class="line">  for(int k=1; k&lt;=n; k++)</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">      for(int j=1; j&lt;=n; j++)</span><br><span class="line">        d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  memset(d,0x3f,sizeof d);</span><br><span class="line">  for(int i=1; i&lt;=n; i++)d[i][i]=0;</span><br><span class="line">  for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    d[a][b]=min(d[a][b],c); //重边</span><br><span class="line">  &#125;</span><br><span class="line">  floyd();</span><br><span class="line">  for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    for(int j=1;j&lt;=n;j++) </span><br><span class="line">      printf(&quot;%d &quot;,d[i][j]);</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="304-最短路-Johnson-算法"><a href="#304-最短路-Johnson-算法" class="headerlink" title="304 最短路 Johnson 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320444.html">304 最短路 Johnson 算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P5905 【模板】Johnson 全源最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 30010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a,b,c;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> vis[N],cnt[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> h[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">63</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    h[<span class="number">0</span>]=<span class="number">0</span>,vis[<span class="number">0</span>]=<span class="number">1</span>;q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed : e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v=ed.v,w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(h[v]&gt;h[u]+w)&#123;</span><br><span class="line">                h[v]=h[u]+w;</span><br><span class="line">        cnt[v]=cnt[u]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[v]&gt;n)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)d[i]=INF;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    d[s]=<span class="number">0</span>; q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">top</span>().second;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed : e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v=ed.v,w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+w)&#123;</span><br><span class="line">                d[v]=d[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(&#123;-d[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c, e[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      e[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;i,<span class="number">0</span>&#125;);<span class="comment">//加虚拟边</span></span><br><span class="line">      </span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ed:e[u])</span><br><span class="line">        ed.w+=h[u]-h[ed.v];<span class="comment">//构造新边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">dijkstra</span>(i);<span class="comment">//i次循环</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j]==INF) ans+=(<span class="type">long</span> <span class="type">long</span>)j*INF;</span><br><span class="line">            <span class="keyword">else</span> ans+=(<span class="type">long</span> <span class="type">long</span>)j*(d[j]+h[j]-h[i]);<span class="comment">//(d[j]+h[j]-h[i])为i到j的边权</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="305-最小环"><a href="#305-最小环" class="headerlink" title="305 最小环"></a><a href="https://www.cnblogs.com/dx123/p/16320450.html">305 最小环</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=110;</span><br><span class="line">int n,m,a,b,c,ans=1e8;</span><br><span class="line">int w[N][N],d[N][N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  for(int i=1;i&lt;=n;i++)</span><br><span class="line">    for(int j=1;j&lt;=n;j++)</span><br><span class="line">      if(i!=j) w[i][j]=1e8;</span><br><span class="line">  for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    w[a][b]=w[b][a]=c;</span><br><span class="line">  &#125;</span><br><span class="line">  memcpy(d,w,sizeof d);</span><br><span class="line">  </span><br><span class="line">  for(int k=1; k&lt;=n; k++)&#123;</span><br><span class="line">    for(int i=1; i&lt;k; i++)</span><br><span class="line">      for(int j=i+1; j&lt;k; j++)</span><br><span class="line">        ans=min(ans,d[i][j]+w[j][k]+w[k][i]);</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">      for(int j=1; j&lt;=n; j++)</span><br><span class="line">        d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  if(ans==1e8) puts(&quot;No solution.&quot;);</span><br><span class="line">  else printf(&quot;%d\n&quot;,ans);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="311-最小生成树-Prim-算法"><a href="#311-最小生成树-Prim-算法" class="headerlink" title="311 最小生成树 Prim 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320452.html">311 最小生成树 Prim 算法</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define inf 1e9</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=5010;</span><br><span class="line">int n,m,a,b,c,ans,cnt;</span><br><span class="line">struct edge&#123;int v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">int d[N], vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">bool prim(int s)&#123;</span><br><span class="line">  for(int i=0;i&lt;=n;i++) d[i]=inf;</span><br><span class="line">  d[s]=0; q.push(&#123;0,s&#125;);</span><br><span class="line">  while(q.size())&#123;</span><br><span class="line">    int u=q.top().second; q.pop();</span><br><span class="line">    if(vis[u])continue;//再出队跳过</span><br><span class="line">    vis[u]=1;//标记u已出队</span><br><span class="line">    ans+=d[u]; cnt++;</span><br><span class="line">    for(auto ed : e[u])&#123;</span><br><span class="line">      int v=ed.v, w=ed.w;</span><br><span class="line">      if(d[v]&gt;w)&#123;</span><br><span class="line">        d[v]=w;</span><br><span class="line">        q.push(&#123;-d[v],v&#125;);//大根堆</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cnt==n;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    e[a].push_back(&#123;b,c&#125;);</span><br><span class="line">    e[b].push_back(&#123;a,c&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  if(!prim(1))puts(&quot;orz&quot;);</span><br><span class="line">  else printf(&quot;%d\n&quot;,ans); </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="321-最近公共祖先-倍增算法"><a href="#321-最近公共祖先-倍增算法" class="headerlink" title="321 最近公共祖先 倍增算法"></a><a href="https://www.cnblogs.com/dx123/p/16320461.html">321 最近公共祖先 倍增算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>; </span><br><span class="line"><span class="type">int</span> n,m,s,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dep[N],fa[N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">  fa[u][<span class="number">0</span>]=f;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">19</span>; i++) </span><br><span class="line">    fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : e[u])</span><br><span class="line">    <span class="keyword">if</span>(v!=f) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u, v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>; ~i; i--)</span><br><span class="line">    <span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v])</span><br><span class="line">      u=fa[u][i];</span><br><span class="line">  <span class="keyword">if</span>(u==v) <span class="keyword">return</span> v;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>; ~i; i--)</span><br><span class="line">    <span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">      u=fa[u][i], v=fa[v][i];</span><br><span class="line">  <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n,&amp;m,&amp;s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lca</span>(a, b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用dfs建立深度，最大子树，节点总值，数组"><a href="#利用dfs建立深度，最大子树，节点总值，数组" class="headerlink" title="利用dfs建立深度，最大子树，节点总值，数组"></a>利用dfs建立深度，最大子树，节点总值，数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mina[x] = a[x];<span class="comment">//最小子树</span></span><br><span class="line">	cnt[x] = <span class="number">1</span>;<span class="comment">//子节点个数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> tx : e[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(tx == fa) <span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		dep[tx] = dep[x] + <span class="number">1</span>;<span class="comment">//深度</span></span><br><span class="line">		f[tx][<span class="number">0</span>] = x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">			f[tx][i] = f[f[tx][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">dfs</span>(tx, x);</span><br><span class="line">		mina[x] = <span class="built_in">min</span>(mina[x], mina[tx]);</span><br><span class="line">		cnt[x] += cnt[tx];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="322-最近公共祖先-Tarjan算法"><a href="#322-最近公共祖先-Tarjan算法" class="headerlink" title="322 最近公共祖先 Tarjan算法"></a><a href="https://www.cnblogs.com/dx123/p/16320465.html">322 最近公共祖先 Tarjan算法</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=500005,M=2*N;</span><br><span class="line">int n,m,s,a,b;</span><br><span class="line">vector&lt;int&gt; e[N];</span><br><span class="line">vector&lt;pair&lt;int,int&gt;&gt;query[N];</span><br><span class="line">int fa[N],vis[N],ans[M]; </span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">  if(x==fa[x]) return x;</span><br><span class="line">  return fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void tarjan(int x)&#123;</span><br><span class="line">  vis[x]=true;//标记x已访问</span><br><span class="line">  for(auto y : e[x])&#123;</span><br><span class="line">    if(!vis[y])&#123;</span><br><span class="line">      tarjan(y);</span><br><span class="line">      fa[y]=x;//回到x时指向x</span><br><span class="line">    &#125;        </span><br><span class="line">  &#125;</span><br><span class="line">  //离开x时找LCA</span><br><span class="line">  for(auto q : query[x])&#123;</span><br><span class="line">    int y=q.first,i=q.second;</span><br><span class="line">    if(vis[y])ans[i]=find(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  scanf(&quot;%d%d%d&quot;, &amp;n,&amp;m,&amp;s);</span><br><span class="line">  for(int i=1; i&lt;n; i++)&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    e[a].push_back(b);</span><br><span class="line">    e[b].push_back(a);</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    query[a].push_back(&#123;b,i&#125;);</span><br><span class="line">    query[b].push_back(&#123;a,i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for(int i=1;i&lt;=N;i++)fa[i]=i;</span><br><span class="line">  tarjan(s);</span><br><span class="line">  for(int i=1; i&lt;=m; i++)</span><br><span class="line">    printf(&quot;%d\n&quot;,ans[i]);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="323-最近公共祖先-树链剖分"><a href="#323-最近公共祖先-树链剖分" class="headerlink" title="323 最近公共祖先 树链剖分"></a><a href="https://www.cnblogs.com/dx123/p/16320467.html">323 最近公共祖先 树链剖分</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P3379 【模板】最近公共祖先（LCA）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N],son[N],dep[N],sz[N];</span><br><span class="line"><span class="type">int</span> top[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123; <span class="comment">//搞fa,dep,son</span></span><br><span class="line">  fa[u]=father,dep[u]=dep[father]+<span class="number">1</span>,sz[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==father) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">    sz[u]+=sz[v];</span><br><span class="line">    <span class="keyword">if</span>(sz[son[u]]&lt;sz[v])son[u]=v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123; <span class="comment">//搞top</span></span><br><span class="line">  top[u]=t; <span class="comment">//记录链头</span></span><br><span class="line">  <span class="comment">// printf(&quot;top[%d]=%d\n&quot;,u,t);</span></span><br><span class="line">  <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;<span class="comment">//无重儿子返回</span></span><br><span class="line">  <span class="built_in">dfs2</span>(son[u],t); <span class="comment">//搜重儿子</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==son[u])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(v,v); <span class="comment">//搜轻儿子</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    u=fa[top[u]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dep[u]&lt;dep[v]?u:v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(s,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(s,s);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lca</span>(a,b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="324-树上修改与查询-树链剖分"><a href="#324-树上修改与查询-树链剖分" class="headerlink" title="324 树上修改与查询 树链剖分"></a><a href="https://www.cnblogs.com/dx123/p/16320469.html">324 树上修改与查询 树链剖分</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Luogu P3384 【模板】轻重链剖分/树链剖分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc u&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,root,p;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N],dep[N],sz[N],son[N];</span><br><span class="line"><span class="type">int</span> top[N],id[N],nw[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;<span class="comment">//搞fa,dep,sz,son</span></span><br><span class="line">  fa[u]=father,dep[u]=dep[father]+<span class="number">1</span>,sz[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==father) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">    sz[u]+=sz[v];</span><br><span class="line">    <span class="keyword">if</span>(sz[son[u]]&lt;sz[v]) son[u]=v; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;<span class="comment">//搞top,id,nw</span></span><br><span class="line">  top[u]=t,id[u]=++cnt,nw[cnt]=w[u];</span><br><span class="line">  <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[u],t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==son[u])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">  <span class="type">int</span> l,r; </span><br><span class="line">  LL add,sum;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>]; <span class="comment">//线段树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  tr[u].sum=tr[lc].sum+tr[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tr[u].add)&#123;</span><br><span class="line">    tr[lc].sum+=tr[u].add*(tr[lc].r-tr[lc].l+<span class="number">1</span>);</span><br><span class="line">    tr[rc].sum+=tr[u].add*(tr[rc].r-tr[rc].l+<span class="number">1</span>);</span><br><span class="line">    tr[lc].add+=tr[u].add;</span><br><span class="line">    tr[rc].add+=tr[u].add;</span><br><span class="line">    tr[u].add=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  tr[u]=&#123;l,r,<span class="number">0</span>,nw[r]&#125;;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(lc,l,mid),<span class="built_in">build</span>(rc,mid+<span class="number">1</span>,r);</span><br><span class="line">  <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r)&#123;</span><br><span class="line">    tr[u].add+=k;</span><br><span class="line">    tr[u].sum+=k*(tr[u].r-tr[u].l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(u);</span><br><span class="line">  <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(lc,l,r,k);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(rc,l,r,k);</span><br><span class="line">  <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_path</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>,id[top[u]],id[u],k);</span><br><span class="line">    u=fa[top[u]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>,id[v],id[u],k);<span class="comment">//最后一段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tree</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>,id[u],id[u]+sz[u]<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r)<span class="keyword">return</span> tr[u].sum;</span><br><span class="line">  <span class="built_in">pushdown</span>(u);</span><br><span class="line">  <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  LL res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">query</span>(lc,l,r);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">query</span>(rc,l,r);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query_path</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  LL res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    res+=<span class="built_in">query</span>(<span class="number">1</span>,id[top[u]],id[u]);</span><br><span class="line">    u=fa[top[u]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">  res+=<span class="built_in">query</span>(<span class="number">1</span>,id[v],id[u]);<span class="comment">//最后一段</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query_tree</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,id[u],id[u]+sz[u]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root,&amp;p);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(root,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(root,root);<span class="comment">//把树拆成链</span></span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n); <span class="comment">//用链建线段树</span></span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> t,u,v,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t,&amp;u);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v,&amp;k);</span><br><span class="line">      <span class="built_in">update_path</span>(u,v,k);<span class="comment">//表示将树从 xx 到 yy 结点最短路径上所有节点的值都加上 zz。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">      <span class="built_in">update_tree</span>(u,k);<span class="comment">//表示求树从 xx 到 yy 结点最短路径上所有节点的值之和。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_path</span>(u,v)%p);<span class="comment">//表示求树从 xx 到 yy 结点最短路径上所有节点的值之和。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_tree</span>(u)%p);<span class="comment">//表示求以 xx 为根节点的子树内所有节点值之和</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="341-强连通分量-Tarjan-算法"><a href="#341-强连通分量-Tarjan-算法" class="headerlink" title="341 强连通分量 Tarjan 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320476.html">341 强连通分量 Tarjan 算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],instk[N],top;</span><br><span class="line"><span class="type">int</span> scc[N],siz[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="comment">//入x时，盖戳、入栈</span></span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  stk[++top]=x,instk[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]);<span class="comment">//回x时更新low</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(instk[y])<span class="comment">//若y已访问且在栈中</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);<span class="comment">//在x时更新low</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//离x时，收集SCC</span></span><br><span class="line">  <span class="keyword">if</span>(dfn[x]==low[x])&#123;<span class="comment">//若x是SCC的根</span></span><br><span class="line">    <span class="type">int</span> y; ++cnt;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      y=stk[top--];</span><br><span class="line">      instk[y]=<span class="number">0</span>;</span><br><span class="line">      scc[y]=cnt;<span class="comment">//SCC编号</span></span><br><span class="line">      ++siz[cnt];<span class="comment">//SCC大小</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b, e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//可能不连通</span></span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">   <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">     <span class="keyword">if</span>(siz[i]&gt;<span class="number">1</span>) ans++;</span><br><span class="line">   cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="342-Tarjan-缩点"><a href="#342-Tarjan-缩点" class="headerlink" title="342 Tarjan 缩点"></a><a href="https://www.cnblogs.com/dx123/p/16320478.html">342 Tarjan 缩点</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],instk[N],top;</span><br><span class="line"><span class="type">int</span> scc[N],cnt;</span><br><span class="line"><span class="type">int</span> din[N],dout[N];<span class="comment">//SCC的入度,出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot; </span><br><span class="line">  stk[++top]=x,instk[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);<span class="comment">////</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(instk[y])<span class="comment">//若y已访问且在栈中</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dfn[x]==low[x])&#123;<span class="comment">//若x是SCC的根</span></span><br><span class="line">    <span class="type">int</span> y;++cnt;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      y=stk[top--];</span><br><span class="line">      instk[y]=<span class="number">0</span>;</span><br><span class="line">      scc[y]=cnt; <span class="comment">//y属于哪个SCC</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, a; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a, a) </span><br><span class="line">      e[i].<span class="built_in">push_back</span>(a);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y : e[x])</span><br><span class="line">      <span class="keyword">if</span>(scc[x]!=scc[y])&#123;</span><br><span class="line">        din[scc[y]]++;</span><br><span class="line">        dout[scc[x]]++;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="type">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!din[i]) a++;</span><br><span class="line">    <span class="keyword">if</span>(!dout[i]) b++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">  <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(a,b));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="343-Tarjan-割点"><a href="#343-Tarjan-割点" class="headerlink" title="343 Tarjan 割点"></a><a href="https://www.cnblogs.com/dx123/p/16320481.html">343 Tarjan 割点</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P3388 【模板】割点</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  <span class="type">int</span> child=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]); </span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">        child++;<span class="comment">//子树个数</span></span><br><span class="line">        <span class="keyword">if</span>(x!=root||child&gt;<span class="number">1</span>)</span><br><span class="line">          cut[x]=<span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//若y已经访问</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b),</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(root=<span class="number">1</span>; root&lt;=n; root++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[root])<span class="built_in">tarjan</span>(root);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(cut[i]) ans++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(cut[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h1 id="344-Tarjan-割边"><a href="#344-Tarjan-割边" class="headerlink" title="344 Tarjan 割边"></a><a href="https://www.cnblogs.com/dx123/p/16320483.html">344 Tarjan 割边</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v;&#125;;</span><br><span class="line">vector&lt;edge&gt;e;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;h[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bridge</span>&#123;</span><br><span class="line">  <span class="type">int</span> x,y;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> bridge &amp;t)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t.x)<span class="keyword">return</span> y&lt;t.y;</span><br><span class="line">    <span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;bri[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e.<span class="built_in">push_back</span>(&#123;a,b&#125;);</span><br><span class="line">  h[a].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> in_edge)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=h[x][i], y=e[j].v;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y,j);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;dfn[x])&#123;</span><br><span class="line">        bri[cnt++]=&#123;x,y&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j!=(in_edge^<span class="number">1</span>))<span class="comment">//不是反边</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(bri,bri+cnt);  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,bri[i].x,bri[i].y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="345-Tarjan-eDCC-缩点"><a href="#345-Tarjan-eDCC-缩点" class="headerlink" title="345 Tarjan eDCC 缩点"></a><a href="https://www.cnblogs.com/dx123/p/16320488.html">345 Tarjan eDCC 缩点</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// POJ 3177 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>;<span class="comment">//2,3开始配对</span></span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">int</span> dcc[N],cnt;</span><br><span class="line"><span class="type">int</span> bri[M],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx].v=b; e[idx].ne=h[a];</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> in_edg)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  stk.<span class="built_in">push</span>(x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> y=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y,i);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;dfn[x])</span><br><span class="line">        bri[i]=bri[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i!=(in_edg^<span class="number">1</span>))<span class="comment">//不是反边</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">int</span> y=stk.<span class="built_in">top</span>();stk.<span class="built_in">pop</span>();</span><br><span class="line">      dcc[y]=cnt;<span class="comment">//记录eDCC</span></span><br><span class="line">      <span class="keyword">if</span>(y==x)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=idx;i++)</span><br><span class="line">    <span class="keyword">if</span>(bri[i])</span><br><span class="line">      d[dcc[e[i].v]]++;<span class="comment">//度数</span></span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    <span class="keyword">if</span>(d[i]==<span class="number">1</span>) sum++;<span class="comment">//叶节点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(sum+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="346-Tarjan-vDCC-缩点"><a href="#346-Tarjan-vDCC-缩点" class="headerlink" title="346 Tarjan vDCC 缩点"></a><a href="https://www.cnblogs.com/dx123/p/16320490.html">346 Tarjan vDCC 缩点</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N],ne[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],top;</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N];</span><br><span class="line"><span class="type">int</span> root,cnt,num,id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  stk[++top]=x;</span><br><span class="line">  <span class="keyword">if</span>(x==root&amp;&amp;!e[x].<span class="built_in">size</span>())&#123;<span class="comment">//孤立点</span></span><br><span class="line">    dcc[++cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> child=<span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);<span class="comment">////</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]); </span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">        child++;</span><br><span class="line">        <span class="keyword">if</span>(x!=root||child&gt;<span class="number">1</span>)</span><br><span class="line">          cut[x]=<span class="literal">true</span>; </span><br><span class="line">        <span class="type">int</span> z; cnt++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vDCC:&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123; <span class="comment">//记录vDCC</span></span><br><span class="line">          z=stk[top--];</span><br><span class="line">          dcc[cnt].<span class="built_in">push_back</span>(z);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,z);</span><br><span class="line">        &#125;<span class="keyword">while</span>(z!=y);</span><br><span class="line">        dcc[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//若y已经访问</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b),</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(root=<span class="number">1</span>;root&lt;=n;root++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[root])</span><br><span class="line">      <span class="built_in">tarjan</span>(root);</span><br><span class="line">      </span><br><span class="line">  <span class="comment">//给每个割点一个新编号（cnt+1开始）</span></span><br><span class="line">  num=cnt;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(cut[i])id[i]=++num;</span><br><span class="line">  <span class="comment">//建新图，从每个vDCC向对应割点连边</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dcc[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">      <span class="type">int</span> x=dcc[i][j];</span><br><span class="line">      <span class="keyword">if</span>(cut[x])&#123;</span><br><span class="line">        ne[i].<span class="built_in">push_back</span>(id[x]),</span><br><span class="line">        ne[id[x]].<span class="built_in">push_back</span>(i);        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="361-网络流-最大流-EK-算法"><a href="#361-网络流-最大流-EK-算法" class="headerlink" title="361 网络流 最大流 EK 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320492.html">361 网络流 最大流 EK 算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P3376 【模板】网络最大流</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;LL v,c,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>;<span class="comment">//从2,3开始配对</span></span><br><span class="line">LL mf[N],pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//找增广路</span></span><br><span class="line">  <span class="built_in">memset</span>(mf,<span class="number">0</span>,<span class="keyword">sizeof</span> mf);</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(S); mf[S]=<span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">      LL v=e[i].v;</span><br><span class="line">      <span class="keyword">if</span>(mf[v]==<span class="number">0</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">        mf[v]=<span class="built_in">min</span>(mf[u],e[i].c);</span><br><span class="line">        pre[v]=i;<span class="comment">//存前驱边</span></span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(v==T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">EK</span><span class="params">()</span></span>&#123;<span class="comment">//累加可行流</span></span><br><span class="line">  LL flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">    <span class="type">int</span> v=T;</span><br><span class="line">    <span class="keyword">while</span>(v!=S)&#123;<span class="comment">//更新残留网</span></span><br><span class="line">      <span class="type">int</span> i=pre[v];</span><br><span class="line">      e[i].c-=mf[T];</span><br><span class="line">      e[i^<span class="number">1</span>].c+=mf[T];</span><br><span class="line">      v=e[i^<span class="number">1</span>].v;</span><br><span class="line">    &#125;</span><br><span class="line">    flow+=mf[T];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">add</span>(a,b,c); </span><br><span class="line">    <span class="built_in">add</span>(b,a,<span class="number">0</span>);<span class="comment">//反向边</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">EK</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="362-网络流-最大流-Dinic-算法"><a href="#362-网络流-最大流-Dinic-算法" class="headerlink" title="362 网络流 最大流 Dinic 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320495.html">362 网络流 最大流 Dinic 算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;LL v,c,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>; <span class="comment">//从2,3开始配对</span></span><br><span class="line"><span class="type">int</span> d[N],cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123; <span class="comment">//对点分层，找增广路</span></span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt;q; </span><br><span class="line">  q.<span class="built_in">push</span>(S); d[S]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">      <span class="type">int</span> v=e[i].v;</span><br><span class="line">      <span class="keyword">if</span>(d[v]==<span class="number">0</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">        d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(v==T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, LL mf)</span></span>&#123; <span class="comment">//多路增广</span></span><br><span class="line">  <span class="keyword">if</span>(u==T) <span class="keyword">return</span> mf;</span><br><span class="line">  LL sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].ne)&#123;</span><br><span class="line">    cur[u]=i; <span class="comment">//当前弧优化</span></span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(d[v]==d[u]+<span class="number">1</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">      LL f=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(mf,e[i].c));</span><br><span class="line">      e[i].c-=f; </span><br><span class="line">      e[i^<span class="number">1</span>].c+=f; <span class="comment">//更新残留网</span></span><br><span class="line">      sum+=f; <span class="comment">//累加u的流出流量</span></span><br><span class="line">      mf-=f;  <span class="comment">//减少u的剩余流量</span></span><br><span class="line">      <span class="keyword">if</span>(mf==<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//余量优化</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(sum==<span class="number">0</span>) d[u]=<span class="number">0</span>; <span class="comment">//残枝优化</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dinic</span><span class="params">()</span></span>&#123; <span class="comment">//累加可行流</span></span><br><span class="line">  LL flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, h, <span class="keyword">sizeof</span> h);</span><br><span class="line">    flow+=<span class="built_in">dfs</span>(S,<span class="number">1e9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">  <span class="keyword">while</span>(m -- )&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">add</span>(a,b,c); <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">dinic</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="381-二分图判定-染色法"><a href="#381-二分图判定-染色法" class="headerlink" title="381 二分图判定 染色法"></a><a href="https://www.cnblogs.com/dx123/p/16418198.html">381 二分图判定 染色法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  color[u]=c;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(!color[v])&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">dfs</span>(v,<span class="number">3</span>-c))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(color[v]==c)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//有奇环</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">add</span>(a,b); </span><br><span class="line">    <span class="built_in">add</span>(b,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!color[i])</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">dfs</span>(i,<span class="number">1</span>))&#123;</span><br><span class="line">        flag=<span class="number">1</span>;<span class="comment">//有奇环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="382-二分图最大匹配-匈牙利算法"><a href="#382-二分图最大匹配-匈牙利算法" class="headerlink" title="382 二分图最大匹配 匈牙利算法"></a><a href="https://www.cnblogs.com/dx123/p/16418297.html">382 二分图最大匹配 匈牙利算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Luogu P3386 【模板】二分图最大匹配</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,a,b,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> vis[N],match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v; <span class="comment">//妹子</span></span><br><span class="line">    <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[v]=<span class="number">1</span>; <span class="comment">//先标记这个妹子</span></span><br><span class="line">    <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">      match[v]=u; <span class="comment">//配成对</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b, <span class="built_in">add</span>(a,b);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="383-二分图最大匹配-Dinic算法"><a href="#383-二分图最大匹配-Dinic算法" class="headerlink" title="383 二分图最大匹配 Dinic算法"></a><a href="https://www.cnblogs.com/dx123/p/16419587.html">383 二分图最大匹配 Dinic算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 2000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k,S,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,c,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>; <span class="comment">//从2,3开始配对</span></span><br><span class="line"><span class="type">int</span> d[N],cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123; <span class="comment">//对点分层，找增广路</span></span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt;q; </span><br><span class="line">  q.<span class="built_in">push</span>(S); d[S]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">      <span class="type">int</span> v=e[i].v;</span><br><span class="line">      <span class="keyword">if</span>(d[v]==<span class="number">0</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">        d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(v==T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> mf)</span></span>&#123; <span class="comment">//多路增广</span></span><br><span class="line">  <span class="keyword">if</span>(u==T) <span class="keyword">return</span> mf;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].ne)&#123;</span><br><span class="line">    cur[u]=i; <span class="comment">//当前弧优化</span></span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(d[v]==d[u]+<span class="number">1</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">      <span class="type">int</span> f=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(mf,e[i].c));</span><br><span class="line">      e[i].c-=f; </span><br><span class="line">      e[i^<span class="number">1</span>].c+=f; <span class="comment">//更新残留网</span></span><br><span class="line">      sum+=f; <span class="comment">//累加u的流出流量</span></span><br><span class="line">      mf-=f;  <span class="comment">//减少u的剩余流量</span></span><br><span class="line">      <span class="keyword">if</span>(mf==<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//余量优化</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(sum==<span class="number">0</span>) d[u]=<span class="number">0</span>; <span class="comment">//残枝优化</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123; <span class="comment">//累加可行流</span></span><br><span class="line">  <span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, h, <span class="keyword">sizeof</span> h);</span><br><span class="line">    flow+=<span class="built_in">dfs</span>(S,<span class="number">1e9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">  <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">add</span>(a,b+n,<span class="number">1</span>);<span class="built_in">add</span>(b+n,a,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  S=<span class="number">0</span>;T=n+m+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">add</span>(S,i,<span class="number">1</span>),<span class="built_in">add</span>(i,S,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+n,T,<span class="number">1</span>),<span class="built_in">add</span>(T,i+n,<span class="number">0</span>); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">dinic</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="384-二分图最大权完美匹配-KM算法"><a href="#384-二分图最大权完美匹配-KM算法" class="headerlink" title="384 二分图最大权完美匹配 KM算法"></a><a href="https://www.cnblogs.com/dx123/p/16436807.html">384 二分图最大权完美匹配 KM算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e12</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> match[N];<span class="comment">//右点匹配了哪个左点</span></span><br><span class="line"><span class="type">int</span> va[N],vb[N];<span class="comment">//标记是否在交替路中</span></span><br><span class="line">LL la[N],lb[N];<span class="comment">//左顶标,右顶标</span></span><br><span class="line">LL w[N][N],d[N];<span class="comment">//维护更新的delta值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    va[x]=<span class="number">1</span>; <span class="comment">//x在交替路中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=n;y++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!vb[y])&#123;</span><br><span class="line">          <span class="keyword">if</span>(la[x]+lb[y]-w[x][y]==<span class="number">0</span>)&#123;<span class="comment">//相等子图</span></span><br><span class="line">              vb[y]=<span class="number">1</span>; <span class="comment">//y在交替路中</span></span><br><span class="line">              <span class="keyword">if</span>(!match[y]||<span class="built_in">dfs</span>(match[y]))&#123;</span><br><span class="line">                match[y]=x; <span class="comment">//配对</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//不是相等子图则记录最小的d[y]</span></span><br><span class="line">            d[y]=<span class="built_in">min</span>(d[y],la[x]+lb[y]-w[x][y]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">KM</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//左顶标取i的出边的最大边权</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) la[i]=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">          la[i]=<span class="built_in">max</span>(la[i],w[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lb[i]=<span class="number">0</span>;      </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;<span class="comment">//直到左点i找到匹配</span></span><br><span class="line">            <span class="built_in">fill</span>(va+<span class="number">1</span>,va+n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">fill</span>(vb+<span class="number">1</span>,vb+n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">fill</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>,INF);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i))<span class="keyword">break</span>;</span><br><span class="line">          LL delta=INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">              <span class="keyword">if</span>(!vb[j])delta=<span class="built_in">min</span>(delta,d[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//修改顶标</span></span><br><span class="line">              <span class="keyword">if</span>(va[j])la[j]-=delta;</span><br><span class="line">              <span class="keyword">if</span>(vb[j])lb[j]+=delta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)res+=w[match[i]][i];    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">          w[i][j]=-INF; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        w[x][y]=z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">KM</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,match[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="391-基环树-P2607-ZJOI2008-骑士"><a href="#391-基环树-P2607-ZJOI2008-骑士" class="headerlink" title="391 基环树 P2607 ZJOI2008] 骑士"></a>391 基环树 P2607 <a href="https://www.cnblogs.com/dx123/p/16464427.html">ZJOI2008] 骑士</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题意:每个骑士有一个不可以同时上场的骑士，和一个战斗力。求最大战斗力</span></span><br><span class="line"><span class="comment">//转化: n个点n条边，每个点有权值，有边相连的两个点只能选其一，求可选方案的最大的点权之和。</span></span><br><span class="line"><span class="comment">// Luogu P2607 [ZJOI2008] 骑士</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[N];</span><br><span class="line"><span class="type">int</span> h[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> r1,r2,vis[N];</span><br><span class="line">LL f[N][<span class="number">2</span>],sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//找两个根</span></span><br><span class="line">  vis[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==rt)&#123;r1=u,r2=v;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">find</span>(v,rt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//树上DP</span></span><br><span class="line">  f[u][<span class="number">0</span>]=<span class="number">0</span>; f[u][<span class="number">1</span>]=w[u];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==rt)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v,rt);</span><br><span class="line">    f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">    f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>,u;v&lt;=n;v++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[v],&amp;u);</span><br><span class="line">    <span class="built_in">add</span>(u,v);<span class="comment">//单向边</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">      r1=r2=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">find</span>(i,i);</span><br><span class="line">      <span class="keyword">if</span>(r1)&#123;</span><br><span class="line">        LL res1=<span class="built_in">dfs</span>(r1,r1);</span><br><span class="line">        LL res2=<span class="built_in">dfs</span>(r2,r2);</span><br><span class="line">        sum+=<span class="built_in">max</span>(res1,res2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P2607 [ZJOI2008] 骑士</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> h[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> fa[N]; <span class="comment">//并查集的根数组</span></span><br><span class="line">LL f[N][<span class="number">2</span>],sum;</span><br><span class="line">vector&lt;PII&gt; roots;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;<span class="comment">//树上DP</span></span><br><span class="line">  f[u][<span class="number">0</span>]=<span class="number">0</span>; f[u][<span class="number">1</span>]=w[u];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">    f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;x);</span><br><span class="line">    <span class="type">int</span> pa=<span class="built_in">find</span>(i),pb=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(pa!=pb)&#123;</span><br><span class="line">      fa[pa]=pb;<span class="comment">//合并</span></span><br><span class="line">      <span class="built_in">add</span>(i,x),<span class="built_in">add</span>(x,i);<span class="comment">//加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      roots.<span class="built_in">push_back</span>(&#123;x,i&#125;);<span class="comment">//存根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> t:roots)&#123;</span><br><span class="line">    <span class="type">int</span> a=t.first,b=t.second;</span><br><span class="line">    sum+=<span class="built_in">max</span>(<span class="built_in">dfs</span>(a,<span class="number">-1</span>),<span class="built_in">dfs</span>(b,<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="392-基环树-P1399-NOI2013-快餐店"><a href="#392-基环树-P1399-NOI2013-快餐店" class="headerlink" title="392 基环树 P1399 NOI2013] 快餐店"></a>392 基环树 P1399 <a href="https://www.cnblogs.com/dx123/p/16464432.html">NOI2013] 快餐店</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P1399 [NOI2013] 快餐店</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w,ne;&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> vis[N],fa[N],w[N];</span><br><span class="line"><span class="type">int</span> inc[N],cv[N],cw[N],cn;</span><br><span class="line"><span class="type">double</span> d[N],A[N],B[N],C[N],D[N];</span><br><span class="line"><span class="type">double</span> ans1,ans2=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++idx]=&#123;b,c,h[a]&#125;;h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa[u])&#123;</span><br><span class="line">            fa[v]=u; w[v]=e[i].w;      </span><br><span class="line">            <span class="keyword">if</span>(!vis[v])&#123;<span class="comment">//v尚未访问</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(v))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//v已访问</span></span><br><span class="line">                <span class="type">int</span> p=u;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    inc[p]=<span class="number">1</span>;cv[++cn]=p;</span><br><span class="line">                    cw[cn]=w[p];p=fa[p];</span><br><span class="line">                    <span class="keyword">if</span>(p==u)<span class="keyword">break</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v, w=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(!inc[v]&amp;&amp;v!=fa)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            ans1=<span class="built_in">max</span>(ans1,d[u]+d[v]+w);</span><br><span class="line">            d[u]=<span class="built_in">max</span>(d[u],d[v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    <span class="built_in">add</span>(x,y,z);<span class="built_in">add</span>(y,x,z);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">find</span>(<span class="number">1</span>);<span class="comment">//深搜找环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn;++i)</span><br><span class="line">      <span class="built_in">dfs</span>(cv[i],<span class="number">0</span>);<span class="comment">//深搜求直径ans1</span></span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn;++i)&#123;<span class="comment">//求前缀</span></span><br><span class="line">        sum+=cw[i<span class="number">-1</span>];</span><br><span class="line">        A[i]=<span class="built_in">max</span>(A[i<span class="number">-1</span>],sum+d[cv[i]]);</span><br><span class="line">        B[i]=<span class="built_in">max</span>(B[i<span class="number">-1</span>],mx+d[cv[i]]+sum);</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,d[cv[i]]-sum);</span><br><span class="line">    &#125;</span><br><span class="line">    sum=mx=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> cn_1=cw[cn];cw[cn]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cn;i&gt;=<span class="number">1</span>;--i)&#123;<span class="comment">//求后缀</span></span><br><span class="line">        sum+=cw[i];</span><br><span class="line">        C[i]=<span class="built_in">max</span>(C[i+<span class="number">1</span>],sum+d[cv[i]]);</span><br><span class="line">        D[i]=<span class="built_in">max</span>(D[i+<span class="number">1</span>],mx+d[cv[i]]+sum);</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,d[cv[i]]-sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;cn;++i)&#123;<span class="comment">//拼凑答案</span></span><br><span class="line">        res=<span class="built_in">max</span>(<span class="built_in">max</span>(B[i],D[i+<span class="number">1</span>]),</span><br><span class="line">                A[i]+C[i+<span class="number">1</span>]+cn_1);</span><br><span class="line">        ans2=<span class="built_in">min</span>(ans2,res);</span><br><span class="line">    &#125;</span><br><span class="line">　　 ans2=<span class="built_in">min</span>(ans2,B[cn]);<span class="comment">//断最后一条边</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,<span class="built_in">max</span>(ans1,ans2)/<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="393-基环树-P5022-NOIP2018-提高组-旅行"><a href="#393-基环树-P5022-NOIP2018-提高组-旅行" class="headerlink" title="393 基环树 P5022 NOIP2018 提高组] 旅行"></a>393 基环树 P5022 <a href="https://www.cnblogs.com/dx123/p/16468119.html">NOIP2018 提高组] 旅行</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P5022 [NOIP2018 提高组] 旅行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; edge[N];</span><br><span class="line"><span class="type">int</span> du,dv,vis[N];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(N,N)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt,better;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!better)&#123;</span><br><span class="line">    <span class="comment">//若序号变大则回退，变小则走完</span></span><br><span class="line">    <span class="keyword">if</span>(u&gt;path[cnt])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;path[cnt])better=<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[u]=<span class="literal">true</span>;</span><br><span class="line">  path[cnt++]=u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[u][i];</span><br><span class="line">    <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(v==du&amp;&amp;u==dv)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(v==dv&amp;&amp;u==du)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs</span>(v))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    edge[i]=&#123;a,b&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">sort</span>(e[i].<span class="built_in">begin</span>(),e[i].<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(n==m+<span class="number">1</span>) <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//枚举断边</span></span><br><span class="line">      du=edge[i].first;</span><br><span class="line">      dv=edge[i].second;</span><br><span class="line">      <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">      cnt=better=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="394-圆方树-P5236【模板】静态仙人掌"><a href="#394-圆方树-P5236【模板】静态仙人掌" class="headerlink" title="394 圆方树 P5236【模板】静态仙人掌"></a><a href="https://www.cnblogs.com/dx123/p/16480198.html">394 圆方树 P5236【模板】静态仙人掌</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20000</span>,M=N*<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h1[N],h2[N],idx=<span class="number">1</span>;<span class="comment">//建图</span></span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tim;<span class="comment">//tarjan</span></span><br><span class="line"><span class="type">int</span> s[N],sc[N],fa[N],fw[N],fe[N],cn;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">14</span>],dep[N],d[N];<span class="comment">//lca</span></span><br><span class="line"><span class="type">int</span> A,B;<span class="comment">//存lca的两个儿子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[],<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> sum=w;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=v;k!=u;k=fa[k])&#123;</span><br><span class="line">    s[k]=sum; <span class="comment">//u...k的环长</span></span><br><span class="line">    sum+=fw[k]; <span class="comment">//前缀和</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// s[u]=sc[u]=sum;</span></span><br><span class="line">  <span class="built_in">add</span>(h2,u,++cn,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=v;k!=u;k=fa[k])&#123;</span><br><span class="line">    sc[k]=sum; <span class="comment">//总环长</span></span><br><span class="line">    <span class="built_in">add</span>(h2,cn,k,<span class="built_in">min</span>(s[k],sum-s[k]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ine)</span></span>&#123;</span><br><span class="line">  dfn[u]=low[u]=++tim;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h1[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])&#123; <span class="comment">//若没有访问</span></span><br><span class="line">      <span class="comment">//fw:存边权，fe:存入边</span></span><br><span class="line">      fa[v]=u,fw[v]=w,fe[v]=i;</span><br><span class="line">      <span class="built_in">tarjan</span>(v,i);</span><br><span class="line">      low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">      <span class="keyword">if</span>(dfn[u]&lt;low[v]) <span class="comment">//非环边</span></span><br><span class="line">        <span class="built_in">add</span>(h2,u,v,w);<span class="comment">//直接加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i!=(ine^<span class="number">1</span>)) <span class="comment">//构成环</span></span><br><span class="line">      low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h1[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]&lt;dfn[v]&amp;&amp;fe[v]!=i)</span><br><span class="line">      <span class="built_in">build_tree</span>(u,v,w); <span class="comment">//建树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;</span><br><span class="line">  dep[u]=dep[father]+<span class="number">1</span>;</span><br><span class="line">  f[u][<span class="number">0</span>]=father;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">13</span>;k++)</span><br><span class="line">    f[u][k]=f[f[u][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h2[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">    d[v]=d[u]+w;</span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">13</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    <span class="keyword">if</span>(dep[f[u][k]]&gt;=dep[v])</span><br><span class="line">      u=f[u][k];</span><br><span class="line">  <span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">13</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    <span class="keyword">if</span>(f[u][k]!=f[v][k])&#123;</span><br><span class="line">      u=f[u][k];</span><br><span class="line">      v=f[v][k];</span><br><span class="line">    &#125;</span><br><span class="line">  A=u,B=v;<span class="comment">//存lca的两个儿子</span></span><br><span class="line">  <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">  cn=n;</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">add</span>(h1,a,b,c),<span class="built_in">add</span>(h1,b,a,c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//找环建树</span></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//lca打表</span></span><br><span class="line">  <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">lca</span>(u,v);<span class="comment">//找lca</span></span><br><span class="line">    <span class="keyword">if</span>(p&lt;=n) <span class="comment">//若是圆点</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d[u]+d[v]-d[p]*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//若是方点</span></span><br><span class="line">      <span class="type">int</span> len=<span class="built_in">abs</span>(s[A]-s[B]);</span><br><span class="line">      <span class="type">int</span> dAB=<span class="built_in">min</span>(len,sc[A]-len);</span><br><span class="line">      <span class="type">int</span> dis=dAB+d[u]-d[A]+d[v]-d[B];</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>linux错误总结</title>
    <url>/2023/10/14/linux%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Linux下安装Oracle11g，安装界面乱码问题解决方法：</p>
<p>解决安装时中文是”囗囗囗囗囗囗囗囗”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LANG=en-US</span><br></pre></td></tr></table></figure>

<h6 id="防火墙："><a href="#防火墙：" class="headerlink" title="防火墙："></a>防火墙：</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>:查看防火状态</span><br><span class="line"></span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line">service  iptables status</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:暂时关闭防火墙</span><br><span class="line"></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">service  iptables stop</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:永久关闭防火墙</span><br><span class="line"></span><br><span class="line">systemctl disable firewalld</span><br><span class="line"></span><br><span class="line">chkconfig iptables off</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>:重启防火墙</span><br><span class="line"></span><br><span class="line">systemctl enable firewalld</span><br><span class="line"></span><br><span class="line">service iptables restart  </span><br><span class="line"></span><br><span class="line"><span class="number">5</span>:永久关闭后重启</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂时还没有试过</span></span><br><span class="line"></span><br><span class="line">chkconfig iptables on　</span><br></pre></td></tr></table></figure>

<h2 id="Linux永久关闭防火墙-firewalld和sellinux设置"><a href="#Linux永久关闭防火墙-firewalld和sellinux设置" class="headerlink" title="Linux永久关闭防火墙 firewalld和sellinux设置"></a>Linux永久关闭防火墙 firewalld和sellinux设置</h2><p>必须设置 最好设置永久性若是暂时关闭 下次开启还要设置 所以建议永久性关闭<br>关闭 firewalld：<br>systemctl disable firewalld #永久关闭,即设置开机的时候不自动启动<br>关闭 selinux：<br>修改配置文件（永久关闭selinux可以使用vi命令打开&#x2F;etc&#x2F;sysconfig&#x2F;selinux 文件将SELINUX&#x3D;disable）</p>
]]></content>
  </entry>
  <entry>
    <title>宏峰</title>
    <url>/2023/10/25/%E5%AE%8F%E5%B3%B0/</url>
    <content><![CDATA[<h2 id="yum与rpm命令的使用以及参数含义"><a href="#yum与rpm命令的使用以及参数含义" class="headerlink" title="yum与rpm命令的使用以及参数含义"></a>yum与rpm命令的使用以及参数含义</h2><p><img src="file:///C:\Users\Dt\AppData\Roaming\Tencent\QQTempSys%W@GJ$ACOF(TYDYECOKVDYB.png" alt="img"><a href="https://blog.csdn.net/qq_62690755/article/details/134040987?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_62690755/article/details/134040987?spm=1001.2014.3001.5502</a></p>
<h2 id="chown-、chmod命令每一个参数的含义。"><a href="#chown-、chmod命令每一个参数的含义。" class="headerlink" title="chown 、chmod命令每一个参数的含义。"></a>chown 、chmod命令每一个参数的含义。</h2><p><img src="file:///C:\Users\Dt\AppData\Roaming\Tencent\QQTempSys%W@GJ$ACOF(TYDYECOKVDYB.png" alt="img"><a href="https://blog.csdn.net/qq_62690755/article/details/134041622?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_62690755/article/details/134041622?spm=1001.2014.3001.5502</a></p>
<h2 id="fdisk-partd硬盘分区命令-用法？"><a href="#fdisk-partd硬盘分区命令-用法？" class="headerlink" title="fdisk partd硬盘分区命令 用法？"></a>fdisk partd硬盘分区命令 用法？</h2><p><img src="file:///C:\Users\Dt\AppData\Roaming\Tencent\QQTempSys%W@GJ$ACOF(TYDYECOKVDYB.png" alt="img"><a href="https://blog.csdn.net/qq_62690755/article/details/134041622?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_62690755/article/details/134041622?spm=1001.2014.3001.5502</a></p>
]]></content>
  </entry>
  <entry>
    <title>Redhat</title>
    <url>/2023/10/25/redhat/</url>
    <content><![CDATA[<h2 id="创建redhat虚拟机"><a href="#创建redhat虚拟机" class="headerlink" title="创建redhat虚拟机"></a>创建redhat虚拟机</h2><h2 id="更换yum源"><a href="#更换yum源" class="headerlink" title="更换yum源"></a>更换yum源</h2><p><a href="https://blog.csdn.net/x781437692/article/details/112768356?spm=1001.2014.3001.5506%E3%80%81">Redhat更换yum源_redhat9换源_Softnothings的博客-CSDN博客</a></p>
<h2 id="安装-oracle"><a href="#安装-oracle" class="headerlink" title="安装 oracle"></a>安装 oracle</h2><p><a href="https://blog.csdn.net/qq_37382077/article/details/108461330">redhat7安装Oracle11g数据库全过程_redhat安装oracle11g-CSDN博客</a></p>
<h2 id="安装-hammerdb"><a href="#安装-hammerdb" class="headerlink" title="安装 hammerdb"></a>安装 hammerdb</h2><h2 id="安装swingbench"><a href="#安装swingbench" class="headerlink" title="安装swingbench"></a>安装swingbench</h2>]]></content>
  </entry>
  <entry>
    <title>优秀博客推荐</title>
    <url>/2023/10/12/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p><a href="https://www.jianshu.com/p/a2d298e26dcd">Hexo 最常用的几个命令 - 简书 (jianshu.com)</a></p>
<h3 id="plsql"><a href="#plsql" class="headerlink" title="plsql"></a>plsql</h3><p><a href="https://blog.csdn.net/weixin_42107750/article/details/101207802">【Linux】Linux下解锁Oracle的Scott用户-CSDN博客</a></p>
<h2 id="Oracle-临时表空间操作总结-TEMP"><a href="#Oracle-临时表空间操作总结-TEMP" class="headerlink" title="Oracle-临时表空间操作总结 TEMP_"></a>Oracle-临时表空间操作总结 TEMP_</h2><p><a href="https://blog.51cto.com/baoyw/6650484">Oracle-临时表空间操作总结 TEMP_小宝大人的技术博客_51CTO博客</a></p>
<h2 id="Centos-7-X根分区磁盘扩容（非LVM）"><a href="#Centos-7-X根分区磁盘扩容（非LVM）" class="headerlink" title="Centos 7.X根分区磁盘扩容（非LVM）"></a>Centos 7.X根分区磁盘扩容（非LVM）</h2><p><a href="https://cloud.tencent.com/developer/article/1839925">Centos 7.X根分区磁盘扩容（非LVM）-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h2 id="Linux-虚拟机中不重启的情况下加新硬盘及扩展根分区容量"><a href="#Linux-虚拟机中不重启的情况下加新硬盘及扩展根分区容量" class="headerlink" title="Linux 虚拟机中不重启的情况下加新硬盘及扩展根分区容量"></a>Linux 虚拟机中不重启的情况下加新硬盘及扩展根分区容量</h2><p><a href="https://www.cnblogs.com/xiongzaiqiren/p/12627841.html">Linux 虚拟机中不重启的情况下加新硬盘及扩展根分区容量 </a></p>
]]></content>
  </entry>
  <entry>
    <title>yum源本地搭建及创建盘挂载加扩容</title>
    <url>/2023/10/25/yum%E6%BA%90%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="redhat系统配置本地yum源"><a href="#redhat系统配置本地yum源" class="headerlink" title="redhat系统配置本地yum源"></a>redhat系统配置本地yum源</h1><p>前置名字可以换成自己的，在这里是ls</p>
<p>在&#x2F;home&#x2F;oracle下进行的命令</p>
<p>1.确保安装<code>createrepo</code>和<code>yum-utils</code>软件包。如果尚未安装，您可以使用以下命令安装它们：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install createrepo yum-utils</span><br></pre></td></tr></table></figure>

<p>2.创建一个目录来存放您的本地Yum源文件。例如，您可以使用以下命令创建一个名为<code>ls-yum</code>的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir ls-yum</span><br></pre></td></tr></table></figure>

<p>3.将您要提供的RPM软件包复制到<code>ls-yum</code>目录中。</p>
<p>4.运行以下命令生成本地Yum仓库的元数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo createrepo ls-yum</span><br></pre></td></tr></table></figure>

<p>5.创建一个Yum源配置文件，以告知系统如何访问本地Yum源。您可以使用任何文本编辑器创建一个新的 <code>.repo</code> 文件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/yum.repos.d/ls-yum.repo</span><br></pre></td></tr></table></figure>

<p>6.在该文件中，添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ls-yum]</span><br><span class="line">name=Local Yum Repository</span><br><span class="line">baseurl=file:///home/oracle/ls-yum</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure>

<p>确保将<code>home/oracle/ls-yum</code>替换为您实际的本地Yum源目录路径。</p>
<p>1.保存并关闭文件。</p>
<p>2.现在，您可以使用Yum命令来安装、更新或删除软件包。例如，要列出可用的软件包，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yun install vim</span><br></pre></td></tr></table></figure>

<p>试试使用本地源进行软件包管理吧！</p>
<h2 id="在自己的虚拟机上创建一个-backup-虚拟机新添加一块5G的盘-创建lv挂载-backup目录，并再次扩容到10G"><a href="#在自己的虚拟机上创建一个-backup-虚拟机新添加一块5G的盘-创建lv挂载-backup目录，并再次扩容到10G" class="headerlink" title="在自己的虚拟机上创建一个&#x2F;backup 虚拟机新添加一块5G的盘,创建lv挂载&#x2F;backup目录，并再次扩容到10G"></a>在自己的虚拟机上创建一个&#x2F;backup 虚拟机新添加一块5G的盘,创建lv挂载&#x2F;backup目录，并再次扩容到10G</h2><p>前置名字可以换成自己的，在这里是ls</p>
<p>1.首先，确认你的虚拟机已经添加了一块5GB的新盘。可以使用命令 <code>lsblk</code> 或者 <code>fdisk -l</code> 来查看已有的磁盘列表。</p>
<p>2.使用命令 <code>sudo fdisk /dev/sdb</code> 打开新添加的磁盘进行分区。按照提示，创建一个新的主分区（Primary Partition）并将其设置为 Linux 文件系统类型（例如使用选项 <code>n</code> 和 <code>p</code>）。保存并退出。</p>
<p>3.使用命令 <code>sudo pvcreate /dev/sdb1</code> 来创建物理卷。</p>
<p>4.使用命令 <code>sudo vgcreate ls-vg /dev/sdb1</code> 来创建卷组。</p>
<p>5.使用命令 <code>sudo lvcreate -L 5G -n ls-lv ls-vg</code> 来创建5GB大小的逻辑卷。</p>
<p>6.使用命令 <code>sudo mkfs.ext4 /dev/ls-vg/ls-lv</code> 格式化逻辑卷。</p>
<p>7.创建挂载点 <code>/ls</code> 目录，使用命令 <code>sudo mkdir /ls</code>。</p>
<p>8.使用命令 <code>sudo mount /dev/ls-vg/ls-lv /ls</code> 将逻辑卷挂载到 <code>/ls</code> 目录。</p>
<p>9.在 <code>/etc/fstab</code> 文件中添加以下行，以使系统在启动时自动挂载逻辑卷：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dev/ls-vg/ls-lv  /ls  ext4  defaults  0  0</span><br></pre></td></tr></table></figure>

<p>10.确保挂载成功后，使用命令 <code>df -h</code> 检查挂载情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ！！！这里因为创建磁盘时只床建了一个导致内存不够，加盘后反而不能开机，在网上搜索后发现是新添加的磁盘空间没有分配，系统识别不出来，导致不能开机。</span><br><span class="line">//所以空间没分配完尽量不要重启</span><br><span class="line">解决办法：直接添加新硬盘，添加后扫描分区：</span><br><span class="line">ls  /sys/class/scsi_host/</span><br><span class="line">for i in $(ls /sys/class/scsi_host/); do echo &quot;- - -&quot; &gt; /sys/class/scsi_host/$i/scan; done</span><br><span class="line">sudo pvcreate /dev/sdc</span><br><span class="line">sudo vgextend ls-vg /dev/sdc</span><br></pre></td></tr></table></figure>

<p>1.要将逻辑卷扩展到10GB，使用以下命令：</p>
<ul>
<li>首先，确认逻辑卷和文件系统的当前大小，使用命令 <code>sudo df -h /ls</code>。</li>
<li>然后，使用命令 <code>sudo lvextend -L +5G /dev/ls-vg/ls-lv</code> 将逻辑卷扩展为10GB。</li>
<li>最后，使用命令 <code>sudo resize2fs /dev/ls-vg/ls-lv</code> 来扩展文件系统以使用新的逻辑卷大小。</li>
</ul>
<ol>
<li>使用命令 <code>sudo df -h /ls</code> 再次检查挂载点的大小，确认扩容成功。</li>
</ol>
<h4 id="ok-你已经完成搭载及扩容啦"><a href="#ok-你已经完成搭载及扩容啦" class="headerlink" title="ok 你已经完成搭载及扩容啦!!"></a>ok 你已经完成搭载及扩容啦!!</h4>]]></content>
  </entry>
  <entry>
    <title>zhang</title>
    <url>/2023/10/26/zhang/</url>
    <content><![CDATA[<p><img src="C:\hexo\source\pic\OIP.jpg" alt="img"></p>
<p><img src="C:\hexo\source\pic\R.jpg" alt="img"></p>
]]></content>
  </entry>
</search>
