<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/25/obca%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<p>OBCA测试题</p>
<p>*1、OceanBase使用什么协议完成高可用和强一致性？</p>
<p>A、单副本+Paxos协议</p>
<p>B、多副本+高可用同步协议</p>
<p>C、单副本+高可用同步协议</p>
<p>%%*2、OceanBase是以（）为单位组建Paxos协议组。</p>
<p>A、租户</p>
<p>B、数据库</p>
<p>C、表</p>
<p>%%*3、当应用向数据库写数据时，默认会访问主副本，此主副本会同步（）到从副本，保证数据的高可用性。</p>
<p>%%B、系统日志</p>
<p>C、Undo-log日志</p>
<p>D、心跳消息</p>
<p>*4、OceanBase内核采用的选举协议是？</p>
<p>%%B、Raft </p>
<p>C、Zookeeper </p>
<p>D、ZAB</p>
<p>*5、使用JDBC连接Oracle租户时，需要使用哪种JDBC驱动？</p>
<p>A、MySQL标准的JDBC驱动</p>
<p>B、Oracle标准的JDBC驱动</p>
<p>%%</p>
<p>D、不需要驱动</p>
<p>*6、管理员通过哪条命令创建资源池？</p>
<p>A、create resource unit%%</p>
<p>C、create teanant </p>
<p>D、create database</p>
<p>7、OceanBase不支持什么操作系统？</p>
<p>A、CentOS </p>
<p>%%</p>
<p>C、中标麒麟</p>
<p>D、银河麒麟</p>
<p>8、租户创建完成后，可以使用黑屏客户端连接数据库，除了指定数据库的IP、端口号、用户名、密码等信息外，OceanBase一般用户名使用什么形式？</p>
<p>%%</p>
<p>B、租户名@用户名，例如sys@root </p>
<p>C、用户名@数据库名，例如root@oceanbase</p>
<p>D、数据库名@用户名，例如oceanbase@root</p>
<p>9、Linux操作系统一般采用哪个用户来部署OceanBase？</p>
<p>A、ROOT </p>
<p>B、OBUSER </p>
<p>C、OBSERVER  </p>
<p>%%10、ConfigServer（config url）服务保存了集群的关键信息，是一个web api的服务，供OB Server及OB Proxy访问，一般是由哪个组件提供的？</p>
<p>A、OceanBase Develop Center（ODC）</p>
<p>%%</p>
<p>C、OceanBase Migration Service（OMS）</p>
<p>D、OceanBase Configure Manager（OCM）</p>
<p>11、部署OceanBase集群时，各个OBServer的RPC允许的时钟偏差最大是多少？</p>
<p>A、1毫秒</p>
<p>%%C、10毫秒</p>
<p>D、200毫秒</p>
<p>12、Alter system命令可以修改集群参数和租户参数，如该命令指定Zone或者OB Server，最多可以同时指定几个Zone或者OB Server？</p>
<p>%% </p>
<p>B、2个</p>
<p>C、3个</p>
<p>D、4个</p>
<p>13、“major_freeze_duty_time”设置为“02：00”意味着什么？</p>
<p>A、每日凌晨2点，系统自动发起一次转储操作</p>
<p>%%</p>
<p>C、每日凌晨2点，系统自动发起一次内存冻结操作</p>
<p>D、每日凌晨2点，系统自动发起一次备份恢复操作</p>
<p>14、通过哪个命令可以查询参数的属性？</p>
<p>%%</p>
<p>B、alter system set <name>&#x3D;<value>；</p>
<p>C、show variables like”%<pattern>%；</p>
<p>D、set@@global.<name>&#x3D;<value>；</p>
<p>15、OceanBase是一个什么类型的数据库？</p>
<p>A、集中式数据库</p>
<p>B、NoSQL数据库</p>
<p>%%D、图数据库</p>
<p>*16、以下哪个描述不是OceanBase架构特点？</p>
<p>A、多副本</p>
<p>B、全对等节点</p>
<p>C、准内存数据库</p>
<p>%%</p>
<p>*17、OceanBase产品的数据库内核是什么？</p>
<p>A、MySQL </p>
<p>B、PostgreSQL</p>
<p>C、Hbase  </p>
<p>%%*18、OceanBase的存储结构是怎样的？</p>
<p>%%B、硬盘型数据库</p>
<p>C、缓存型数据库</p>
<p>D、内存型数据库</p>
<p>19、OceanBase是靠哪种基础架构实现写入高性能的？</p>
<p>A、COLA </p>
<p>%%</p>
<p>C、Key-Value </p>
<p>D、BTREE</p>
<p>20、OceanBase服务器要求使用的磁盘类型是什么？</p>
<p>A、SAS机械盘 </p>
<p>%%C、SAS机械盘+SSD固态盘混合</p>
<p>D、磁带</p>
<p>21、OceanBase合增量数据与基线数据，生成新的基线，这一过程称之为什么？</p>
<p>A、转储</p>
<p>%%C、冻结</p>
<p>D、压缩</p>
<p>*22、为了达到更好的压缩效果，OceanBase一般会进行进行几次压缩。</p>
<p>A、1次</p>
<p>%%</p>
<p>C、3次</p>
<p>D、4次</p>
<p>*23、关于OceanBase事务引擎一致性特点，描述正确的是？</p>
<p>%%B、不保证主键唯一等一致性约束</p>
<p>C、强制要求所有列唯一性约束</p>
<p>D、强制要求非主键唯一性约束</p>
<p>*24、OceanBase使用哪种技术解决了读写互斥的问题？</p>
<p>%%B、Paxos协议</p>
<p>C、全局快照</p>
<p>D、互斥锁</p>
<p>*25、OceanBase使用哪种技术保证了跨机事务的原子性？</p>
<p>A、一阶段提交</p>
<p>%%</p>
<p>C、三阶段提交</p>
<p> D、MVCC</p>
<p>*26、OceanBase使用两阶段提交协议保证事务的原子性，在两阶段提交协议中，谁是协调者呢？</p>
<p>A、OB Proxy </p>
<p>%%C、RootService总控服务</p>
<p>D、OCP云管理平台</p>
<p>*27、通过配置Primay Zone，可以打破负载均衡，将主副本汇聚到一个Zone内。OceanBase不支持哪种级别？</p>
<p>A、租户级别。创建租户时，可以设置Primary Zone。</p>
<p>B、数据库级别。创建数据库时，可以设置Primary Zone.</p>
<p>%%D、表级别。创建表时，可以设置Primary Zone。</p>
<p>*28、建立table group的主要目的是？</p>
<p>A、便于业务分组管理各种表</p>
<p>B、SQL优化器能够识别</p>
<p>%%</p>
<p>D、更好的实现负载均衡</p>
<p>*29、当集群发生故障时（服务器故障或者网络故障），OceanBase故障切换的粒度是什么？</p>
<p>A、集群</p>
<p>B、租户</p>
<p>C、数据库</p>
<p>%%*30、假设OceanBase集群有3个Zone，其中2个Zone部署在一个城市的两个机房中，另外一个Zone部署在另外一个城市的一个机房中。如果同城的一个机房宕机，下面说法是正确的是？</p>
<p>A、强一致同步延迟不变</p>
<p>B、会丢失秒级数据</p>
<p>%%D、上层业务方会受到影响</p>
<p>*31、对于存量Oracle业务迁移到OceanBase上，需要数据实时同步功能，建议使用哪个工具？</p>
<p>A、OCP </p>
<p>B、DataX </p>
<p>%%</p>
<p>D.ODC</p>
<p>*32、关于OceanBase资源隔离，以下说法正确的是？</p>
<p>A、OceanBase采用服务器隔离</p>
<p>B、OceanBase采用数据库隔离</p>
<p>C、OceanBase采用schema隔离</p>
<p>%%*33、OceanBase是一个集群，以下哪个组件管理整个集群资源，同时支持全局DDL、集群数据合并等功能。</p>
<p>A、OB Proxy </p>
<p>%%C、OCP管理平台</p>
<p>D、ODC开发者中心</p>
<p>*34、OceanBase集群可以同时支持MySQL和Oracle的租户，哪个黑屏工具可以连接到Oracle租户？</p>
<p>%%B、标准MySQL客户端</p>
<p>C、OCP管理平台</p>
<p>D、ODC开发者中心</p>
<p>*35、如果一个OceanBase集群有5个Zone，每个Zone有10台OB Server。那么一个分区最多有几份全功能型副本呢？</p>
<p>A、10</p>
<p>B、3</p>
<p>C、6</p>
<p>%%*36、关于RootService总控服务，以下描述正确的是？</p>
<p>%%B、一般每个Zone部署一个，必须使用一台独立的服务器运行RootService服务，不能与OB Server合设</p>
<p>C、整个集群部署一个RootService总控服务就可以，不需要考虑高可用性</p>
<p>D、每台OB Server都需要部署RootService总控服务，以提供更高的可用性</p>
<p>*37、对于三副本结构的OceanBase集群，一共有3个Zone，每个Zone部署到一个独立的机房中。其中关于Root Service的描述，正确的是？</p>
<p>%%</p>
<p>B、每个机房内一主两备</p>
<p>C、每个observer上都有RootService </p>
<p>D、Root Service不是必须的</p>
<p>*38、如果一个集群有3个Zone，每个Zone有5台OB Server。一个租户对应的资源池的Unit Num&#x3D;4，最终该集群中最多有多少个observer分配此租户的资源单元？</p>
<p>A、3</p>
<p>B、5</p>
<p>%%</p>
<p>D、15</p>
<p>*39、OceanBase集群创建完成后，系统会形成一个大的资源池，管理员可以划分成小的资源池给各个租户使用，各个租户的资源互相隔离，其中内存是（）隔离，CPU是（）隔离。</p>
<p>%%</p>
<p>B、逻辑、物理</p>
<p>C、物理、离散</p>
<p>D、离散、物理</p>
<p>*40、以下关于OceanBase扩容和缩容描述正确的是？</p>
<p>A、需要管理员暂停业务</p>
<p>B、需要业务做一定的修改</p>
<p>%%D、不能使用公有云资源</p>
<p>*41、以下哪个组件提供图形化的管理界面，支持集群管理、租户管理、监控告警等功能？</p>
<p>A、ODC开发者中心</p>
<p>%%</p>
<p>C%%OB Proxy </p>
<p>D、OB Server</p>
<p>*42、关于OceanBase的全能型副本（Replica），以下说法正确的是？【多选题】</p>
<p>%%D、没有记录事务的日志，但可以参与投票</p>
<p>E、没有记录事务的日志，也不参与投票</p>
<p>*43、OceanBase支持哪些分区方式的分区表？【多选题】</p>
<p>%%D、Datetime分区</p>
<p>*44、分区数据一般有多份副本，OceanBase有哪些副本类型？【多选题】</p>
<p>%%D、只写型：包含完整的日志，Mem Table和SSTable等数据。对应用只提供写服务，不提供读服务。</p>
<p>*45、OceanBase常用的SQL语法兼容性，主要兼容哪两种数据库？【多选题】</p>
<p>%%C、DB2</p>
<p>D、SQL Server</p>
<p>*46、初始化OceanBase集群（bootstrap）失败的常见原因是什么？【多选题】</p>
<p>%%D、OCP未安装导致集群bootstrap失败</p>
<p>*47、OceanBase的参数有哪两个级别？【多选题】</p>
<p>%%B、Zone级</p>
<p>C、OB Server级</p>
<p>%%*48、关于OceanBase的系统参数的生效范围，以下说法正确的是？【多选题】</p>
<p>%%B、可以在某个Region生效</p>
<p>%%*49、关于OceanBase的修改系统参数命令ALTER SYSTEM SET XX&#x3D;”YY’，以下说法正确的是？【多选题】</p>
<p>%%B、可以修改该Parameter在某个Region上的值</p>
<p>%% E、如果不带任何条件，则会返回错误</p>
<p>*50、OceanBase的核心特性有哪些？【多选题】</p>
<p>%%E、高成本，使用小型机、高端存储等专有硬件；</p>
<p>*51、以下关于OceanBase通过TPC-C认证的描述是正确的？【多选题】</p>
<p>%%D、OceanBase只进行了一次TPC-C认证</p>
<p>*52、OceanBase在阿里和蚂蚁集团内部有哪些应用？【多选题】</p>
<p>%%C、网商银行</p>
<p>D、印度Paytm%%*53、OceanBase备份恢复功能支持备份恢复哪些数据？【多选题】</p>
<p>%%*54、OceanBase的“准内存数据库”+LSMTree的架构，可以带来哪些好处？【多选题】</p>
<p>%%*55、OceanBase备份恢复业务支持哪些存储介质？【多选题】</p>
<p>%%B、IP-SAN</p>
<p>C、FC-SAN</p>
<p>%%*56、OceanBase支持哪些事务隔离级别？【多选题】</p>
<p>A、脏读（Read-Uncommited）</p>
<p>%%</p>
<p>*57、关于OceanBase事务引擎的MVCC（多版本并发控制），以下说法正确的是？【多选题】</p>
<p>%%D、写会阻塞读操作</p>
<p>*58、传统的集中式关系型数据库面临哪些挑战？【多选题】</p>
<p>%%B、生态欠缺：文档、培训、应用等都不足；</p>
<p>%%D、性能差：任何时候，传统集中式数据库的性能都比分布式数据库较差；</p>
<p>*59、以下对OB Proxy的描述是正确的是？【多选题】</p>
<p>%%B、OB Proxy必须部署到一台独立的服务器上，以保证其性能要求；</p>
<p>C、OB Proxy参与数据库引擎的计算任务以及事务处理；</p>
<p>%%*60、关于OceanBase的负载均衡，以下说法正确的是？【多选题】</p>
<p>A、OceanBase自动完成负载均衡，无法关闭</p>
<p>%%D、负载均衡的调度单元是租户</p>
<p>E、负载均衡的调度单元是数据库（database））</p>
<p>%%*61、当主副本所在服务器硬件故障或网络故障后，业务无法正常访问主副本的数据，OceanBase如何保证高可用性？【多选题】</p>
<p>%%</p>
<p>B、需要管理员手工找到剩余的从副本，并手工将其由从副本转变为主副本</p>
<p>%%D、主副本联系不到所有的从副本，其自身依然还是主副本，造成两个主副本同时存在的“脑裂现象</p>
<p>*62、关于OceanBase的ZONE，以下说法正确的是？【多选题】</p>
<p>%%D、不同Zone一定要部署在不同机房</p>
<p>*63、关于OceanBase的分区Partition，以下说法正确的是？【多选题】</p>
<p>%%C、OceanBase只支持一级分区，不支持二级分区</p>
<p>%%E、OceanBase支持表的自动分区分裂</p>
<p>*64、随着业务不断发展，原有租户的资源无法满足业务需要，有哪些扩容的方式？【多选题】</p>
<p>%%B、无法对租户进行扩容，需要创建一个新的租户满足业务需要</p>
<p>%%*65、为保证高可用能力，一个集群应有多个Zone组成，关于Zone的个数，以下哪个描述是正确的？【多选题】</p>
<p>%%C、Zone的个数一般是偶数个，比如2个或者4个</p>
<p>D、Zone个数一般应大于等于5个，以便构成多数派</p>
<p>*66、OceanBase提供哪些数据库相关产品？【多选题】</p>
<p>%%*67、对于OceanBase的租户权限管理，以下说法正确的是？【多选题】</p>
<p>A、系统租户下的管理员用户可以访问其他普通租户的用户数据</p>
<p>%%D、系统租户下的管理员用户可以给其他普通租户的用户进行授权，使得普通租户的用户拥有系统管理员的权限</p>
<p>*68、系统管理员可以根据业务需要创建不同的租户，租户具有哪些特性？【多选题】</p>
<p>%%*69、RootService总控服务提供资源分配及调度功能，主要包括哪些功能？【多选题】</p>
<p>%%D、SQL引擎</p>
<p>*70、OceanBase支持哪些客户端及运维管理工具？【多选题】</p>
<p>%%*71、OceanBase可以实现动态的扩容和缩容。扩容包括哪些步骤？【多选题】</p>
<p>%%D、管理员手工启动“rebalance”过程，将部分数据从旧服务器的Unit在线复制到新服务器的Unit上.</p>
<p>*72、关于租户的扩容方式，以下说法正确的是？【多选题】</p>
<p>A、租户无法进行扩容，如果资源无法满足需求，需要重新建立更大资源池的租户</p>
<p>%%D、OceanBase是分布式集群具有横向扩展的能力，租户扩容仅仅需要添加节点即可，无需扩容租户的资源单元</p>
<p>*73、OMS实时同步工具是异构数据库迁移到OceanBase数据库的利器，OMS支持哪些功能？</p>
<p>【多选题】</p>
<p>%%D、提供集群管理功能，包括集群创建、集群扩容、集群监控等功能。</p>
<p>%%*74、关于OceanBase的应用日志级别，以下说法正确的是？【多选题】</p>
<p>%%B、INFO提示，用于记录系统运行的当前状态，该信息为错误信息</p>
<p>%%E、WARN警告，用于记录严重错误，需要立即处理</p>
<p>*75、关于OCP上OBProxy管理功能，下面说法正确的是？【多选题】</p>
<p>%%D、可以转移OBProxy</p>
<p>E、可以调整OBProxy的配置</p>
<p>*76、关于OCP告警功能，下面说法正确的是？【多选题】</p>
<p>A、不支持用户修改告警闽值</p>
<p>%%E、OCP告警依赖专有云底座</p>
<p>%%*77、OceanBase 云平台（OceanBase Cloud Platform，OCP）是数据库管理平台，图形化的界面更易于DBA管理OceanBase，OCP支持哪些功能？【多选题】</p>
<p>%%E、开发管理：提供了数据库日常开发操作、WebSQL、SQL诊断、会话管理和数据导入导出等功能</p>
<p>%%*78、OceanBase 开发者中心（Oceanbase Developer Center，ODC）是为OceanBase 数据库量身打造的企业级数据库开发平台，主要支持哪些功能？【多选题】</p>
<p>%%*79、OceanBase的Paxos协议，不同于传统的主备库或者双活方案，可以彻底规避在容灾场景下的脑裂问题（也就是同时有两个主数据库的场景）。</p>
<p>%%O错</p>
<p>*80、每台OB Server是相对独立的，都有自己独立的SQL引擎，如果应用需要的数据不在当前OB Server上，该OB Server将协调其他OB Server的数据，统一反馈给应用，这个过程对应用是透明的。</p>
<p>%%O错</p>
<p>*81、主副本通过同步Redo-Log日志的方式实现可靠性，主副本需要收到所有从副本落盘成功的消息后才能响应应用。</p>
<p>O对</p>
<p>%%</p>
<p>*82、假如一个分区有3个副本，其中1个是主副本，剩余2个是从副本，一般情况下，业务读写操作均访问该主副本。</p>
<p>〇%%O错</p>
<p>*83、管理员需要手工指定一个分区的哪个副本是主副本，哪个是从副本。</p>
<p>O对</p>
<p>%%*84、分区的副本只包含硬盘上的静态数据（SS Table），不包括Mem Table数据和日志数据。</p>
<p>〇对</p>
<p>%%*85、主副本只能打散到所有Zone内，实现访问流量的负载均衡，不能将主副本聚焦到一个Zone内。</p>
<p>O对</p>
<p>%%*86、OceanBase可以支持在一个数据库中同时支持MySQL租户和Oracle租户。</p>
<p>%%O错</p>
<p>*87、OceanBase通过Explain命令查看优化器针对给定SQL生成的逻辑执行计划，Explain所展示的计划是在执行命令时优化器根据当前的用户输入和数据统计信息所生成的逻辑执行计划,而并不是在计划缓存中真正被使用的物理执行计划。</p>
<p>%%O错</p>
<p>*88、租户逻辑上类似传统数据库的实例，创建完成后，每个租户都将有自己的专属进程。</p>
<p>○对</p>
<p>%%*89、如果要部署一个“5-5-5”的集群，也就是集群有3个Zone，每个Zone有5台服务器，一共15台服务器。创建集群时，只需要指定RootService所在的3台机器，不需要在创建集群时就78、指定所有15台机器。集群创建成功后，再将剩余的12台服务器添加进集群。</p>
<p>%%O错</p>
<p>*90、OceanBase只支持X86架构的CPU，不支持其他CPU（如鲲鹏、海光、飞腾等）。</p>
<p>O对</p>
<p>%%*91、memory_limit_percentage设置成90，意味着memtable内存写入到90%会触发合并操作。</p>
<p>O对</p>
<p>%%</p>
<p>*92、会话变量只对当前会话生效，不影响该租户下的其他会话。</p>
<p>%%O错</p>
<p>*93、Global级（租户级）变量修改后，对当前已经打开的session也依然生效。</p>
<p>O对</p>
<p>%%*94、普通租户只能设置自己租户的参数，系统租户可以查看和设置所有租户的参数（包括系统租户和普通租户）。</p>
<p>%%O错</p>
<p>*95、普通租户无法更改自身的系统变量，需要系统租户（sys）来更改普通租户的系统变量。</p>
<p>O对</p>
<p>%%*96、OceanBase数据库是在阿里和蚂蚁内部孵化了10年后才逐步推广到外部市场的。</p>
<p>%%O错</p>
<p>*97、OceanBase数据库是基于开源数据库的再发行产品。</p>
<p>O对</p>
<p>%%*98、TPC-C就是一个跑分测试，官方没有什么规则限制，只要能跑高分就行。</p>
<p>O对</p>
<p>%%</p>
<p>*99、OceanBase已发布到阿里云公有云及专有云中。</p>
<p>%%O错</p>
<p>*100、合并必须依赖OceanBase自动完成，无法手工启动合并。</p>
<p>〇对</p>
<p>%%*101、OceanBase的数据在磁盘中按主键有序排列。</p>
<p>%%O错</p>
<p>*102、分库分表的架构虽然解决了集中式数据库的扩展性问题，但也带来了新的问题（不支持复杂SQL，较难保证分布式事务的ACID等）。</p>
<p>%%O错</p>
<p>*103、一般情况下，每台OB Server都有主副本和从副本，实现整体的负载均衡，避免出现OB Server忙闲不均的现象。</p>
<p>%%O错</p>
<p>*104、应用通过OB Proxy连接到OceanBase集群，比直连主副本所在的OB Server性能更好？</p>
<p>〇对</p>
<p>%%</p>
<p>*105、对于一个三副本的集群（有三个Zone）。企业在一个城市有两个机房，将两个Zone部署到1个机房中，将另一个Zone部署到另一个机房中，可以提供机房级的容灾。</p>
<p>〇对</p>
<p>%%*106、OceanBase除了支持同城三机房及三地五中心五副本高可用方案外，也支持传统的同城两机房方案和两地三中心方案，以便更好的利旧企业已有的基础设施。</p>
<p>%%O错</p>
<p>*107、OceanBase在少数副本不可用的情况下，可以实现RPO&#x3D;0，RTO&lt;30秒。</p>
<p>%%O错</p>
<p>*108、每个数据库服务的实例（租户）不感知其他实例（租户）的存在，租户拥有一组计算和存储资源，提供一套完整独立的数据库服务。</p>
<p>%%O错</p>
<p>*109、一个租户在同一个Server上可以有一个或多个资源单元UNIT。</p>
<p>O对</p>
<p>%%</p>
<p>*110、创建资源单元仅仅指定CPU，MEMORY参数即可，无需指定lOPS，DISK_SIZE，SESSION_NUM参数。</p>
<p>O对</p>
<p>%%*111、同一个资源单元定义unit config（比如2C8G，或者4C16G等），可以被多个资源池使用。</p>
<p>%%O错</p>
<p>*112、RootService总控服务需要部署到每一台0B Server中。</p>
<p>O对</p>
<p>%%*113、Zone可以对应不同的城市，或者一个城市的不同机房，或者一个机房的不同机架，以实现不同级别的容灾。</p>
<p>%%O错</p>
<p>*114、Zone是个逻辑概念，是给集群内的一批机器打上同一个tag，属于同一个tag的服务器归属一个Zone。</p>
<p>%%O错</p>
<p>*115、租户的资源池一旦创建完成，就不可以改变。如果需要扩容，需要删除旧资源池，创建一个更大规模的资源池。</p>
<p>O对</p>
<p>%%116、创建租户时，需要指定租户类型为Oracle租户或者MySQL租户，以满足不同开发者的需求。</p>
<p>%%O错</p>
<p>*117、扩容服务器加入集群后，集群会基于负载均衡的策略，自动的将部分主副本和从副本迁移到扩容服务器中，以实现整体的负载均衡。</p>
<p>%%O错</p>
<p>118、修改资源池可以实现租户的另一种扩容&#x2F;缩容的方式。比如在每个Zone中增加&#x2F;减少节点数量，可以通过修改资源池的unit_num来实现。</p>
<p>%%O错</p>
<p>*119、在OCP中，可以选择某台observer进行“重启”，这个操作后台是通过系统租户登录，对该台机器的ip地址，执行stop server操作，将这台机器上的读写流量切走。然后重新启动observer进程，最后通过start server恢复服务</p>
<p>%%O错</p>
<p>*120、OCP是管理单元，只支持单机部署，不支持多节点高可靠部署。</p>
<p>O对</p>
<p>%%*121、通过OCP删除OBServer后，系统将会删除该OBServer的所有数据，且无法恢复，请谨慎操作。</p>
<p>%%O错</p>
<p>第一章模拟题答案</p>
<p>1.【判断题】分库分表的架构虽然解决了集中式数据库的扩展性问题，但也带来了新的问题（不支持</p>
<p>复杂SQL，较难保证分布式事务的 ACID等）。（T）</p>
<p>2.【多选题】传统的集中式关系型数据库面临哪些挑战？（AC）</p>
<p>A：成本高：运行在高端服务器、小型机、高端存储等专有硬件上；</p>
<p>B：生态欠缺：文档、培训、应用等都不足；</p>
<p>C：扩展性差：无法摆脱单机的架构，只能纵向扩展，无法横向扩展；</p>
<p>D：性能差：任何时候，传统集中式数据库的性能都比分布式数据库较差；</p>
<p>第二章模拟题</p>
<p>1.【判断题】TPC-C就是一个跑分测试，没有什么规则限制，只要能跑高分就行。（F）</p>
<p>2.【判断题】OceanBase数据库是在阿里和蚂蚁内部孵化了10年后才逐步推广到外部市场的。（T）</p>
<p>3.【判断题】OceanBase数据库是基于开源数据库的再发行产品。（F）</p>
<p>4.【单选题】OceanBase是一个什么类型的数据库（C）</p>
<p>A：集中式数据库；</p>
<p>B：NoSQL数据库；</p>
<p>C：分布式关系型数据库；</p>
<p>5.【多选题】OceanBase的核心特性有哪些？（ABCD）</p>
<p>A：高扩展，可以使用普通的PC服务器进行横向扩展；</p>
<p>B：高性能，峰值峰值6,100万次&#x2F;秒，单表最大3,200亿行；</p>
<p>C：高可用，通过Paxos协议保证强一致性，RPO&#x3D;0，RTO&lt;30秒；</p>
<p>D：高兼容，支持MySQL及Oracle两种模式，降低业务迁移改造成本；</p>
<p>E：高成本，使用小型机、高端存储等专有硬件；</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第三章模拟题</p>
<p>1.【判断题】OceanBase已发布到阿里云公有云及专有云中。（T）</p>
<p>2.【判断题】OceanBase只支持X86架构的CPU，不支持其他CPU（如鲲鹏、海光、飞腾等）。（F）</p>
<p>3.【判断题】Zone是个逻辑概念，是给集群内的一批机器打上同一个tag，属于同一个tag的服务器归属一个Zone。（T）</p>
<p>4.【判断题】Zone可以对应不同的城市，或者一个城市的不同机房，或者一个机房的不同机架。（T）</p>
<p>5.【判断题】租户的资源池一旦创建完成，就不可改变。（F）</p>
<p>6.【单选题】OceanBase是一个集群，一下哪个组件管理整个集群，支持全局DDL、集群数据合并等功能。（B）</p>
<p>A: OB Proxy B：RootService总控服务 C：OCP管理平台 D：ODC开发者中心</p>
<p>7.【单选题】OceanBase集群可以同时支持MySQL和Oracle的租户，哪个黑屏工具可以连接到Oracle租户（A）</p>
<p>A：OceanBase客户端； B：标准MySQL客户端</p>
<p>8.【单选题】OceanBase不支持什么操作系统（B）</p>
<p>A：CentOS； B：Windows C：中标麒麟 D：银河麒麟</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第三章模拟题（2）</p>
<p>9.【单选题】如果一个OceanBase集群有3个Zone，每个Zone有5台OB Serer。那么一个分区最多有几份全能型副本呢？</p>
<p>（B）</p>
<p>A：10 B：3 C：6 D：5</p>
<p>10.【单选题】如果一个集群有3个Zone，每个Zone有5台 OB Server。一个租户对应的资源池的Unit Num&#x3D;3，最终该租户</p>
<p>有多少个资源单元呢？（B）</p>
<p>A： 15 B：9 C：45 D：30</p>
<p>11.【多选题】OceanBase主要有哪些产品组成？（ABCD）</p>
<p>A：OBServer：提供SQL引擎及存储引擎，同时兼容MySQL和Oracle模式；使用Paxos协议确保高可用性；</p>
<p>B：OCP云管理平台：给管理员提供的管理工具，提供集群管理、Zone管理、租户管理等功能；</p>
<p>C：OMS数据迁移工具：提供基线数据和增量数据的同步功能，可以从数据仓库订阅数据链路、从异构数据库迁移数据；</p>
<p>D：ODC开发者中心：提供数据库日常开发、SQL诊断、会话管理及数据导入导出能功能。</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第四章模拟题（1）</p>
<p>1.【判断题】分区的副本只包含硬盘上的静态数据（SS Table），不包括MemTable数据和日志数据。（F）</p>
<p>2.【判断题】主副本只能打散到所有Zone内，不能聚焦到一个Zone内。（F）</p>
<p>3.【判断题】每台OB Server是相对独立的，都有自己独立的SQL引擎，如果应用需要的数据不在当前OB Server上，该</p>
<p>OB Server将协调其他OB Server的数据，统一反馈给应用，这个过程对应用是透明的。（T）</p>
<p>4.【判断题】主副本通过同步Redo-Log日志的方式实现可靠性，主副本需要收到所有从副本落盘成功的消息后才能响应</p>
<p>应用。（F）</p>
<p>5.【判断题】企业在一个城市有2个机房，将2个Zone部署到1个机房中，将另一个Zone部署到另一个机房中，可以提供</p>
<p>机房级的容灾。（F）</p>
<p>6.【单选题】OceanBase是以（）为单位组建Paxos协议组。（D）</p>
<p>A: 租户 B：数据库 C：表 D：分区</p>
<p>7.【单选题】以下关于OceanBase扩容和缩容描述正确的是。（C）</p>
<p>A：需要管理员停止业务 B：需要业务做一定的修改 C：支持动态扩容和缩容，对业务无感知 D：不能使用公有</p>
<p>云资源</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第四章模拟题（2）</p>
<p>8.【单选题】OceanBase使用两阶段提交协议保证事务的原子性，在两阶段提交协议中，谁是协调者呢？（B）</p>
<p>A：OB Proxy B：OB Server C：RootService总控服务 D：OCP云管理平台</p>
<p>9.【多选题】OceanBase的Oracle租户支持哪些事务隔离级别（BC）</p>
<p>A：脏读 B：Read-Committed C：Serializable D：Repeatable-Read</p>
<p>10.【单选题】OceanBase使用哪种技术解决了读写互斥的问题。（A）</p>
<p>A：MVCC B：Paxos协议 C：全局快照 D：互斥锁</p>
<p>11.【多选题】以下对OB Proxy的描述是正确的（AD）</p>
<p>A：OB Proxy位于应用和OB Server之间，将应用的请求路由到合适的OB Server；</p>
<p>B：OB Proxy必须部署到一台独立的服务器上，以保证其性能要求；</p>
<p>C：OB Proxy参与数据库引擎的计算任务以及事务处理；</p>
<p>D：OB Proxy是一个“无状态”的服务进程，不做数据持久化；</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第五章模拟题</p>
<p>1.【判断题】 OceanBase可以支持在一个集群中同时支持MySQL租户和Oracle租户。（T）</p>
<p>2.【判断题】使用Explain命令查看SQL执行计划时，SQL也会真正执行。（F）</p>
<p>3.【判断题】合并必须依赖OceanBase自动完成，无法手工启动合并。（F）</p>
<p>4.【判断题】OceanBase的数据在磁盘中按主键有序排列。（T）</p>
<p>5.【单选题】使用 JDBC连接Oracle租户时，需要使用哪种JDBC驱动。（C）</p>
<p>A: MySQL标准的JDBC驱动 B：Oracle标准的JDBC驱动 C：OceanBase自己开发的JDBC驱动</p>
<p>6.【单选题】为了达到更好的压缩效果，OceanBase一般会进行进行几次压缩。（B）</p>
<p>A：1次 B：2次 C：3次 D：4次</p>
<p>7.【多选题】OceanBase备份恢复业务支持哪些存储介质（AD）</p>
<p>A：NFS B：IP-SAN C：FC-SAN D：阿里云OSS</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第六章模拟题</p>
<p>1.【判断题】会话变量只对当前会话生效，不影响该租户下的其他会话 。（T）</p>
<p>\2. 【单选题】通过哪个命令可以查询参数的属性。（A）</p>
<p>A：show parameters like ‘%<pattern>%’; B：alter system set <name> &#x3D; <value>;</p>
<p>C：show variables like ‘%<pattern>%’; D：set @@global.<name> &#x3D; <value>;</p>
<p>3.【多选题】参数有哪两个级别？（AD）</p>
<p>A：集群级 B：Zone级 C：OB Server级 D：租户级</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第七章模拟题</p>
<p>1.【单选题】以下哪个组件提供图形化的管理界面，支持集群管理、租户管理、监控告警等功能？（B）</p>
<p>A：ODC开发者中心 B：OCP云管理平台 C：OB Proxy D：OB Server</p>
]]></content>
  </entry>
  <entry>
    <title>pythoncincout.md</title>
    <url>/2023/09/24/python%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>确保您已经安装了<code>pandas</code>和<code>openpyxl</code>库（如果您的Python版本是3.8以下），然后按照下面的步骤进行操作：</p>
<ol>
<li>创建并输入样本数据到TXT文件（sample.txt）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制代码<span class="comment"># 打开文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># 写入数据</span></span><br><span class="line">    file.write(<span class="string">&quot;Hello, World!\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;This is a sample text file.\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;It contains multiple lines of text.&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>创建并输入样本数据到CSV文件（sample.csv）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Gender&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;John&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;Male&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;Alice&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;Female&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;Male&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件并写入数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerows(data)</span><br></pre></td></tr></table></figure>

<ol>
<li>创建并输入样本数据到Excel文件（sample.xlsx）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">28</span>],</span><br><span class="line">    <span class="string">&#x27;Gender&#x27;</span>: [<span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;Female&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将DataFrame写入Excel文件</span></span><br><span class="line">df.to_excel(<span class="string">&#x27;sample.xlsx&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>使用Python读取这三种文件：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取TXT文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    txt_data = file.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">csv_data = pd.read_csv(<span class="string">&#x27;sample.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取Excel文件</span></span><br><span class="line">excel_data = pd.read_excel(<span class="string">&#x27;sample.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;TXT 文件内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(txt_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nCSV 文件内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(csv_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nExcel 文件内容：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(excel_data)</span><br></pre></td></tr></table></figure>

<p>这样，您就可以创建并输入样本数据到TXT、CSV和Excel文件，并使用Python读取这三种文件了。请注意，这些示例代码假设您当前的工作目录中已经有了相应的文件。如果不是，请确保将文件路径调整为正确的位置。</p>
]]></content>
  </entry>
  <entry>
    <title>obca</title>
    <url>/2023/09/25/obca/</url>
    <content><![CDATA[<p>OBCA测试题</p>
<p>*1、OceanBase使用什么协议完成高可用和强一致性？</p>
<p>A、单副本+Paxos协议</p>
<p>B、多副本+高可用同步协议</p>
<p>C、单副本+高可用同步协议</p>
<p>D、多副本+Paxos协议</p>
<p>*2、OceanBase是以（）为单位组建Paxos协议组。</p>
<p>A、租户</p>
<p>B、数据库</p>
<p>C、表</p>
<p>D、分区</p>
<p>*3、当应用向数据库写数据时，默认会访问主副本，此主副本会同步（）到从副本，保证数据的高可用性。</p>
<p>A、Redo-Log日志</p>
<p>B、系统日志</p>
<p>C、Undo-log日志</p>
<p>D、心跳消息</p>
<p>*4、OceanBase内核采用的选举协议是？</p>
<p>A、Paxos </p>
<p>B、Raft </p>
<p>C、Zookeeper </p>
<p>D、ZAB</p>
<p>*5、使用JDBC连接Oracle租户时，需要使用哪种JDBC驱动？</p>
<p>A、MySQL标准的JDBC驱动</p>
<p>B、Oracle标准的JDBC驱动</p>
<p>C、OceanBase自己开发的JDBC驱动</p>
<p>D、不需要驱动</p>
<p>*6、管理员通过哪条命令创建资源池？</p>
<p>A、create resource unit</p>
<p>B、create resource pool </p>
<p>C、create teanant </p>
<p>D、create database</p>
<p>7、OceanBase不支持什么操作系统？</p>
<p>A、CentOS </p>
<p>B、Windows </p>
<p>C、中标麒麟</p>
<p>D、银河麒麟</p>
<p>8、租户创建完成后，可以使用黑屏客户端连接数据库，除了指定数据库的IP、端口号、用户名、密码等信息外，OceanBase一般用户名使用什么形式？</p>
<p>A、用户名@租户名，例如root@sys</p>
<p>B、租户名@用户名，例如sys@root </p>
<p>C、用户名@数据库名，例如root@oceanbase</p>
<p>D、数据库名@用户名，例如oceanbase@root</p>
<p>9、Linux操作系统一般采用哪个用户来部署OceanBase？</p>
<p>A、ROOT </p>
<p>B、OBUSER </p>
<p>C、OBSERVER  </p>
<p>D、ADMIN</p>
<p>10、ConfigServer（config url）服务保存了集群的关键信息，是一个web api的服务，供OB Server及OB Proxy访问，一般是由哪个组件提供的？</p>
<p>A、OceanBase Develop Center（ODC）</p>
<p>B、OceanBase Cloud Platform（OCP）</p>
<p>C、OceanBase Migration Service（OMS）</p>
<p>D、OceanBase Configure Manager（OCM）</p>
<p>11、部署OceanBase集群时，各个OBServer的RPC允许的时钟偏差最大是多少？</p>
<p>A、1毫秒</p>
<p>B、100毫秒</p>
<p>C、10毫秒</p>
<p>D、200毫秒</p>
<p>12、Alter system命令可以修改集群参数和租户参数，如该命令指定Zone或者OB Server，最多可以同时指定几个Zone或者OB Server？</p>
<p>A、1个 </p>
<p>B、2个</p>
<p>C、3个</p>
<p>D、4个</p>
<p>13、“major_freeze_duty_time”设置为“02：00”意味着什么？</p>
<p>A、每日凌晨2点，系统自动发起一次转储操作</p>
<p>B、每日凌晨2点，系统自动发起一次合并操作</p>
<p>C、每日凌晨2点，系统自动发起一次内存冻结操作</p>
<p>D、每日凌晨2点，系统自动发起一次备份恢复操作</p>
<p>14、通过哪个命令可以查询参数的属性？</p>
<p>A、show parameters like ‘%<patern>%’；</p>
<p>B、alter system set <name>&#x3D;<value>；</p>
<p>C、show variables like”%<pattern>%；</p>
<p>D、set@@global.<name>&#x3D;<value>；</p>
<p>15、OceanBase是一个什么类型的数据库？</p>
<p>A、集中式数据库</p>
<p>B、NoSQL数据库</p>
<p>C、分布式关系型数据库  (HTAP) </p>
<p>D、图数据库</p>
<p>*16、以下哪个描述不是OceanBase架构特点？</p>
<p>A、多副本</p>
<p>B、全对等节点</p>
<p>C、准内存数据库</p>
<p>D、中心管控</p>
<p>*17、OceanBase产品的数据库内核是什么？</p>
<p>A、MySQL </p>
<p>B、PostgreSQL</p>
<p>C、Hbase  </p>
<p>D、完全自主研发</p>
<p>*18、OceanBase的存储结构是怎样的？</p>
<p>A、准内存型数据库</p>
<p>B、硬盘型数据库</p>
<p>C、缓存型数据库</p>
<p>D、内存型数据库</p>
<p>19、OceanBase是靠哪种基础架构实现写入高性能的？</p>
<p>A、COLA </p>
<p>B、LSM-TREE </p>
<p>C、Key-Value </p>
<p>D、BTREE</p>
<p>20、OceanBase服务器要求使用的磁盘类型是什么？</p>
<p>A、SAS机械盘 </p>
<p>B、SSD固态盘</p>
<p>C、SAS机械盘+SSD固态盘混合</p>
<p>D、磁带</p>
<p>21、OceanBase合增量数据与基线数据，生成新的基线，这一过程称之为什么？</p>
<p>A、转储</p>
<p>B、合并</p>
<p>C、冻结</p>
<p>D、压缩</p>
<p>*22、为了达到更好的压缩效果，OceanBase一般会进行进行几次压缩。</p>
<p>A、1次</p>
<p>B、2次</p>
<p>C、3次</p>
<p>D、4次</p>
<p>*23、关于OceanBase事务引擎一致性特点，描述正确的是？</p>
<p>A、保证主键唯一等一致性约束 IOT</p>
<p>B、不保证主键唯一等一致性约束</p>
<p>C、强制要求所有列唯一性约束</p>
<p>D、强制要求非主键唯一性约束</p>
<p>*24、OceanBase使用哪种技术解决了读写互斥的问题？</p>
<p>A、MVCC </p>
<p>B、Paxos协议</p>
<p>C、全局快照</p>
<p>D、互斥锁</p>
<p>*25、OceanBase使用哪种技术保证了跨机事务的原子性？</p>
<p>A、一阶段提交</p>
<p>B、两阶段提交</p>
<p>C、三阶段提交</p>
<p> D、MVCC</p>
<p>*26、OceanBase使用两阶段提交协议保证事务的原子性，在两阶段提交协议中，谁是协调者呢？</p>
<p>A、OB Proxy </p>
<p>B、OB Server </p>
<p>C、RootService总控服务</p>
<p>D、OCP云管理平台</p>
<p>*27、通过配置Primay Zone，可以打破负载均衡，将主副本汇聚到一个Zone内。OceanBase不支持哪种级别？</p>
<p>A、租户级别。创建租户时，可以设置Primary Zone。</p>
<p>B、数据库级别。创建数据库时，可以设置Primary Zone.</p>
<p>C、分区级别。创建分区时，可以设置Primary Zone。</p>
<p>D、表级别。创建表时，可以设置Primary Zone。</p>
<p>*28、建立table group的主要目的是？</p>
<p>A、便于业务分组管理各种表</p>
<p>B、SQL优化器能够识别</p>
<p>C、减少跨机分布式事务</p>
<p>D、更好的实现负载均衡</p>
<p>*29、当集群发生故障时（服务器故障或者网络故障），OceanBase故障切换的粒度是什么？</p>
<p>A、集群</p>
<p>B、租户</p>
<p>C、数据库</p>
<p>D、表或者分区表的子分区</p>
<p>*30、假设OceanBase集群有3个Zone，其中2个Zone部署在一个城市的两个机房中，另外一个Zone部署在另外一个城市的一个机房中。如果同城的一个机房宕机，下面说法是正确的是？</p>
<p>A、强一致同步延迟不变</p>
<p>B、会丢失秒级数据</p>
<p>C、会增加异地同步延迟</p>
<p>D、上层业务方会受到影响</p>
<p>*31、对于存量Oracle业务迁移到OceanBase上，需要数据实时同步功能，建议使用哪个工具？</p>
<p>A、OCP </p>
<p>B、DataX </p>
<p>C、OMS </p>
<p>D.ODC</p>
<p>*32、关于OceanBase资源隔离，以下说法正确的是？</p>
<p>A、OceanBase采用服务器隔离</p>
<p>B、OceanBase采用数据库隔离</p>
<p>C、OceanBase采用schema隔离</p>
<p>D、OceanBase采用租户隔离</p>
<p>*33、OceanBase是一个集群，以下哪个组件管理整个集群资源，同时支持全局DDL、集群数据合并等功能。</p>
<p>A、OB Proxy </p>
<p>B、RootService总控服务</p>
<p>C、OCP管理平台</p>
<p>D、ODC开发者中心</p>
<p>*34、OceanBase集群可以同时支持MySQL和Oracle的租户，哪个黑屏工具可以连接到Oracle租户？</p>
<p>A、OceanBase客户端</p>
<p>B、标准MySQL客户端</p>
<p>C、OCP管理平台</p>
<p>D、ODC开发者中心</p>
<p>*35、如果一个OceanBase集群有5个Zone，每个Zone有10台OB Server。那么一个分区最多有几份全功能型副本呢？</p>
<p>A、10</p>
<p>B、3</p>
<p>C、6</p>
<p>D、5</p>
<p>*36、关于RootService总控服务，以下描述正确的是？</p>
<p>A、一般每个Zone部署一个，与Zone内一台OB Server合设，共用一台服务器 </p>
<p>B、一般每个Zone部署一个，必须使用一台独立的服务器运行RootService服务，不能与OB Server合设</p>
<p>C、整个集群部署一个RootService总控服务就可以，不需要考虑高可用性</p>
<p>D、每台OB Server都需要部署RootService总控服务，以提供更高的可用性</p>
<p>*37、对于三副本结构的OceanBase集群，一共有3个Zone，每个Zone部署到一个独立的机房中。其中关于Root Service的描述，正确的是？</p>
<p>A、整个集群内一主两备</p>
<p>B、每个机房内一主两备</p>
<p>C、每个observer上都有RootService </p>
<p>D、Root Service不是必须的</p>
<p>*38、如果一个集群有3个Zone，每个Zone有5台OB Server。一个租户对应的资源池的Unit Num&#x3D;4，最终该集群中最多有多少个observer分配此租户的资源单元？</p>
<p>A、3</p>
<p>B、5</p>
<p>C、12</p>
<p>D、15</p>
<p>*39、OceanBase集群创建完成后，系统会形成一个大的资源池，管理员可以划分成小的资源池给各个租户使用，各个租户的资源互相隔离，其中内存是（）隔离，CPU是（）隔离。</p>
<p>A、物理、逻辑</p>
<p>B、逻辑、物理</p>
<p>C、物理、离散</p>
<p>D、离散、物理</p>
<p>*40、以下关于OceanBase扩容和缩容描述正确的是？</p>
<p>A、需要管理员暂停业务</p>
<p>B、需要业务做一定的修改</p>
<p>C、支持动态扩容和缩容，对上层业务透明</p>
<p>D、不能使用公有云资源</p>
<p>*41、以下哪个组件提供图形化的管理界面，支持集群管理、租户管理、监控告警等功能？</p>
<p>A、ODC开发者中心</p>
<p>B、OCP云管理平台</p>
<p>C、OB Proxy </p>
<p>D、OB Server</p>
<p>*42、关于OceanBase的全能型副本（Replica），以下说法正确的是？【多选题】</p>
<p>A、全能型副本有Mem Table</p>
<p>B、全能型副本有SSTable</p>
<p>C、可以较快恢复为leader对外提供服务</p>
<p>D、没有记录事务的日志，但可以参与投票</p>
<p>E、没有记录事务的日志，也不参与投票</p>
<p>*43、OceanBase支持哪些分区方式的分区表？【多选题】</p>
<p>A、Hash分区</p>
<p>B、Lis分区（按列表）</p>
<p>C、Range分区（按范围）</p>
<p>D、Datetime分区</p>
<p>*44、分区数据一般有多份副本，OceanBase有哪些副本类型？【多选题】</p>
<p>A、全能型：拥有事务日志，MemTable和SSTable等全部完整的数据和功能。它可以随时快速切换为leader对外提供服务。</p>
<p>B、日志型：只包含日志的副本，没有MemTable和SSTable。它参与日志投票并对外提供日志服务，可以参与其他副本的恢复，但自己不能变为主提供数据库服务。</p>
<p>C、只读型：包含完整的日志，Mem Table和SSTable等数据。它不作为paxos成员参与日志的投票，而是作为一个观察者实时追赶paxos成员的日志，并在本地回放。</p>
<p>D、只写型：包含完整的日志，Mem Table和SSTable等数据。对应用只提供写服务，不提供读服务。</p>
<p>*45、OceanBase常用的SQL语法兼容性，主要兼容哪两种数据库？【多选题】</p>
<p>A、MySQL</p>
<p>B、Oracle</p>
<p>C、DB2</p>
<p>D、SQL Server</p>
<p>*46、初始化OceanBase集群（bootstrap）失败的常见原因是什么？【多选题】</p>
<p>A、机器间时钟误差过大（超过100毫秒），可以利用clockdif等命令检查机器之间的时钟差</p>
<p>B、启动OB Server进程时，参数信息指定的有错误，比如Zone名称有误</p>
<p>C、服务器硬件自身的故障，比如存储故障</p>
<p>D、OCP未安装导致集群bootstrap失败</p>
<p>*47、OceanBase的参数有哪两个级别？【多选题】</p>
<p>A、集群级</p>
<p>B、Zone级</p>
<p>C、OB Server级</p>
<p>D、租户级</p>
<p>*48、关于OceanBase的系统参数的生效范围，以下说法正确的是？【多选题】</p>
<p>A、可以在集群范围生效</p>
<p>B、可以在某个Region生效</p>
<p>C、可以在某个Zone生效</p>
<p>D、可以在某台OBServer生效</p>
<p>*49、关于OceanBase的修改系统参数命令ALTER SYSTEM SET XX&#x3D;”YY’，以下说法正确的是？【多选题】</p>
<p>A、可以修改该Parameter在某台具体的OBServer 上的值</p>
<p>B、可以修改该Parameter在某个Region上的值</p>
<p>C、可以修改该Parameter在某个Zone上的值</p>
<p>D、如果不带任何条件，则修改所有OBServer的值</p>
<p> E、如果不带任何条件，则会返回错误</p>
<p>*50、OceanBase的核心特性有哪些？【多选题】</p>
<p>A、高扩展，可以使用普通的PC服务器进行横向扩展</p>
<p>B、高性能，峰值峰值6，100万次&#x2F;秒，单表最大3.200亿行；</p>
<p>C、高可用，通过Paxos协议保证强一致性，RPO&#x3D;0，RTO&lt;30秒；</p>
<p>D、高兼容，支持MySQL及Oracle两种模式，降低业务迁移改造成本；</p>
<p>E、高成本，使用小型机、高端存储等专有硬件；</p>
<p>*51、以下关于OceanBase通过TPC-C认证的描述是正确的？【多选题】</p>
<p>A、OceanBase是第一个通过认证的国产数据库</p>
<p>B、OceanBase是全球第一个通过认证的分布式数据库</p>
<p>C、OceanBase通过TPC-C认证使用的是阿里云公有云环境</p>
<p>D、OceanBase只进行了一次TPC-C认证</p>
<p>*52、OceanBase在阿里和蚂蚁集团内部有哪些应用？【多选题】</p>
<p>A、支付宝</p>
<p>B、淘宝收藏夹</p>
<p>C、网商银行</p>
<p>D、印度Paytm</p>
<p>*53、OceanBase备份恢复功能支持备份恢复哪些数据？【多选题】</p>
<p>A、用户权限</p>
<p>B、表定义</p>
<p>C、系统变量</p>
<p>D、用户信息</p>
<p>E、视图信息</p>
<p>*54、OceanBase的“准内存数据库”+LSMTree的架构，可以带来哪些好处？【多选题】</p>
<p>A、准内存处理，数据修改主要是内存操作，无频繁 check point操作，提高写性能；</p>
<p>B、内存的脏数据批量合并之后，顺序写入SSD硬盘，避免随机写，提高写性能并延长SSD寿命；</p>
<p>C、磁盘数据按主键有序排列，磁盘碎片少，并提供快速检索能力。使用普通读密集型SSD硬盘；</p>
<p>D、为避免内存中数据丢失，redo-log以WAL机制实时落盘，保证数据持久性；</p>
<p>*55、OceanBase备份恢复业务支持哪些存储介质？【多选题】</p>
<p>A、NFS</p>
<p>B、IP-SAN</p>
<p>C、FC-SAN</p>
<p>D、阿里云OSS</p>
<p>*56、OceanBase支持哪些事务隔离级别？【多选题】</p>
<p>A、脏读（Read-Uncommited）</p>
<p>B、Read-Committed</p>
<p>C、Serializable</p>
<p>D、Repeatable-Read</p>
<p>*57、关于OceanBase事务引擎的MVCC（多版本并发控制），以下说法正确的是？【多选题】</p>
<p>A、所有修改的行加互斥锁，实现写-写互斥</p>
<p>B、读操作读取特定快照版本的已提交数据</p>
<p>C、读写互不阻塞</p>
<p>D、写会阻塞读操作</p>
<p>*58、传统的集中式关系型数据库面临哪些挑战？【多选题】</p>
<p>A、成本高：其稳定性和高性能依赖高端硬件，甚至专用硬件）</p>
<p>B、生态欠缺：文档、培训、应用等都不足；</p>
<p>C、扩展性差：无法摆脱共享架构，扩展能力受限</p>
<p>D、性能差：任何时候，传统集中式数据库的性能都比分布式数据库较差；</p>
<p>*59、以下对OB Proxy的描述是正确的是？【多选题】</p>
<p>A、OBProxy位于应用和OB Server之间，将应用的请求路由到合适的OB Server；</p>
<p>B、OB Proxy必须部署到一台独立的服务器上，以保证其性能要求；</p>
<p>C、OB Proxy参与数据库引擎的计算任务以及事务处理；</p>
<p>D、OBProxy是一个“无状态”的服务进程，不做数据持久化；</p>
<p>*60、关于OceanBase的负载均衡，以下说法正确的是？【多选题】</p>
<p>A、OceanBase自动完成负载均衡，无法关闭</p>
<p>B、负载均衡的调度单元是资源单元（Unit））</p>
<p>C、负载均衡的调度单元是分区（Partition））</p>
<p>D、负载均衡的调度单元是租户</p>
<p>E、负载均衡的调度单元是数据库（database））</p>
<p>F、系统根据一定的策略，通过动态调整UNIT的位置和UNIT内副本的位置，使得一个Zone内所有Server的资源使用率达到均衡的过程</p>
<p>*61、当主副本所在服务器硬件故障或网络故障后，业务无法正常访问主副本的数据，OceanBase如何保证高可用性？【多选题】</p>
<p>A、剩余从副本依然构成多数派，自动选出新的主副本来承接业务，切换过程对业务不可见</p>
<p>B、需要管理员手工找到剩余的从副本，并手工将其由从副本转变为主副本</p>
<p>C、主副本联系不到所有的从副本，其变成了少数派，将自动卸任主副本</p>
<p>D、主副本联系不到所有的从副本，其自身依然还是主副本，造成两个主副本同时存在的“脑裂现象</p>
<p>*62、关于OceanBase的ZONE，以下说法正确的是？【多选题】</p>
<p>A、Available Zone的含义是可用区，通常指一个机房</p>
<p>B、一个Zone包括若干物理服务器</p>
<p>C、一个OceanBase集群，由若干个Zone组成</p>
<p>D、不同Zone一定要部署在不同机房</p>
<p>*63、关于OceanBase的分区Partition，以下说法正确的是？【多选题】</p>
<p>A、数据表根据分区规则，拆分成多个分区，每个分区包括表中的若干行记录</p>
<p>B、每个分区，还可以用不同的分区维度再进行分区，叫做二级分区</p>
<p>C、OceanBase只支持一级分区，不支持二级分区</p>
<p>D、OceanBase的Partition Group是数据迁移的最小单元，也是高可用切换的最小单元</p>
<p>E、OceanBase支持表的自动分区分裂</p>
<p>*64、随着业务不断发展，原有租户的资源无法满足业务需要，有哪些扩容的方式？【多选题】</p>
<p>A、调整资源池里的资源单元（resource unit）的规格，比如之前规格是2C8G，可以调整为4C16G）</p>
<p>B、无法对租户进行扩容，需要创建一个新的租户满足业务需要</p>
<p>C、调整资源池中，资源单元（resource unit）的数量，如原数量是1，可以增加为2</p>
<p>*65、为保证高可用能力，一个集群应有多个Zone组成，关于Zone的个数，以下哪个描述是正确的？【多选题】</p>
<p>A、Zone个数一般应大于等于3个，以便构成多数派</p>
<p>B、Zone个数一般是奇数个，比如3个或者5个</p>
<p>C、Zone的个数一般是偶数个，比如2个或者4个</p>
<p>D、Zone个数一般应大于等于5个，以便构成多数派</p>
<p>*66、OceanBase提供哪些数据库相关产品？【多选题】</p>
<p>A、数据库内核：提供SQL引擎及存储引擎，同时兼容MySQL和Oracle模式；使用Paxos协议确保高可用性。</p>
<p>B、OCP云管理平台：为运维人员提供的集中管理工具，提供集群管理、租户管理、监控告警等功能</p>
<p>□C、OMS数据迁移工具：提供异构数据库迁移服务，提供全量、增量数据迁移能力和数据订阅功能</p>
<p>D、ODC开发者平台：为OceanBase数据库开发者日常开发、SQL诊断、会话管理及数据导入导出等功能</p>
<p>*67、对于OceanBase的租户权限管理，以下说法正确的是？【多选题】</p>
<p>A、系统租户下的管理员用户可以访问其他普通租户的用户数据</p>
<p>B、任何租户（不论是系统租户还是普通租户）下的用户不能跨租户访问其他普通租户下的用户数据</p>
<p>C、只有系统租户下的管理员用户才有集群管理权限，执行系统管理操作，如创建&#x2F;删除普通租户、设置系统配置参数、开启每日合并操作</p>
<p>D、系统租户下的管理员用户可以给其他普通租户的用户进行授权，使得普通租户的用户拥有系统管理员的权限</p>
<p>*68、系统管理员可以根据业务需要创建不同的租户，租户具有哪些特性？【多选题】</p>
<p>A、可以创建自己的用户</p>
<p>B、可以创建数据库、表等所有对象</p>
<p>C、有独立的information_schema等系统数据库</p>
<p>D、有自己独立的系统变量</p>
<p>*69、RootService总控服务提供资源分配及调度功能，主要包括哪些功能？【多选题】</p>
<p>A、分区及副本管理</p>
<p>B、动态负载均衡</p>
<p>C、扩容和缩容</p>
<p>D、SQL引擎</p>
<p>*70、OceanBase支持哪些客户端及运维管理工具？【多选题】</p>
<p>A、黑屏工具OceanBase客户端</p>
<p>B、黑屏工具标准MySQL客户端</p>
<p>C、白屏工具-OCP管理平台</p>
<p>D、白屏工具-ODC开发者中心</p>
<p>*71、OceanBase可以实现动态的扩容和缩容。扩容包括哪些步骤？【多选题】</p>
<p>A、在扩容服务器上，正确启动observer进程</p>
<p>B、执行alter system add server，命令，将启动的observer添加到集群</p>
<p>C、执行alter resource pool<pool name>unit_num&#x3D;<bigger number>，命令，扩充资源池中的unit个数</p>
<p>D、管理员手工启动“rebalance”过程，将部分数据从旧服务器的Unit在线复制到新服务器的Unit上.</p>
<p>*72、关于租户的扩容方式，以下说法正确的是？【多选题】</p>
<p>A、租户无法进行扩容，如果资源无法满足需求，需要重新建立更大资源池的租户</p>
<p>B、租户扩容，可先通过添加服务节点，完成集群扩容，再通过增加资源单元的个数完成租户扩容</p>
<p>C、如果集群和节点资源足够，可以直接修改租户资源池相关的资源单元规格大小，进行扩容</p>
<p>D、OceanBase是分布式集群具有横向扩展的能力，租户扩容仅仅需要添加节点即可，无需扩容租户的资源单元</p>
<p>*73、OMS实时同步工具是异构数据库迁移到OceanBase数据库的利器，OMS支持哪些功能？</p>
<p>【多选题】</p>
<p>A、支持多种类型数据源：支持包括Oracle、MySQL、DB2、OceanBase等数据库到OceanBase的全量迁移和增量实时数据同步。</p>
<p>B、兼容性评估和改造：异构数据迁移 OceanBase的对象兼容性评估和改写建议，极大降低业务迁移的门槛和业务改造的难度。</p>
<p>C、一站式交互：数据迁移全生命周期管理，数据迁移的创建、配置和监控都在管控界面上连贯操作完成，交互简便。</p>
<p>D、提供集群管理功能，包括集群创建、集群扩容、集群监控等功能。</p>
<p>E、多重数据校验：提供多种方式校验的保护，更加全面、省时、高效地保证数据质量；同时展示差异数据，提供快速订正途径。</p>
<p>*74、关于OceanBase的应用日志级别，以下说法正确的是？【多选题】</p>
<p>A、INFO提示，用于记录系统运行的当前状态，该信息为正常信息</p>
<p>B、INFO提示，用于记录系统运行的当前状态，该信息为错误信息</p>
<p>C、ERROR严重错误，用于记录系统的故障信息，且必须进行故障排除，否则系统不可用</p>
<p>D、WARN警告，用于记录可能会出现的潜在错误</p>
<p>E、WARN警告，用于记录严重错误，需要立即处理</p>
<p>*75、关于OCP上OBProxy管理功能，下面说法正确的是？【多选题】</p>
<p>A、可以安装OBProxy</p>
<p>B、可以重启OBProxy</p>
<p>C、可以下线OBProxy</p>
<p>D、可以转移OBProxy</p>
<p>E、可以调整OBProxy的配置</p>
<p>*76、关于OCP告警功能，下面说法正确的是？【多选题】</p>
<p>A、不支持用户修改告警闽值</p>
<p>B、可以调整告警阀值</p>
<p>C、可以查看告警列表</p>
<p>D、可以自定义告警发送对象</p>
<p>E、OCP告警依赖专有云底座</p>
<p>F、可以调整告警开关，确定哪些项需要监控</p>
<p>*77、OceanBase 云平台（OceanBase Cloud Platform，OCP）是数据库管理平台，图形化的界面更易于DBA管理OceanBase，OCP支持哪些功能？【多选题】</p>
<p>A、集群管理：提供全生命周期管理，包括安装、运维、性能监控、配置、升级和删除等功能。</p>
<p>B、主机管理：提供添加主机、删除主机、主机关键信息显示等功能。</p>
<p>C、租户管理：租户的创建、租户结构拓扑图、性能监控、会话管理和参数管理等。</p>
<p>D、告警管理：支持集群、租户、主机等不同维度的告警。系统基于告警规则生成告警。</p>
<p>E、开发管理：提供了数据库日常开发操作、WebSQL、SQL诊断、会话管理和数据导入导出等功能</p>
<p>F、备份恢复管理：支持对OceanBase集群和租户级别进行全量备份、增量备份、Redo-Log备份、完全恢复、不完全恢复等功能。</p>
<p>*78、OceanBase 开发者中心（Oceanbase Developer Center，ODC）是为OceanBase 数据库量身打造的企业级数据库开发平台，主要支持哪些功能？【多选题】</p>
<p>A、提供引导式创建和可视化修改各类数据库对象的服务</p>
<p>B、实时管控数据库会话访问，支持查看和终止会话，且提供SQL执行计划分析和SQL调优指导服务</p>
<p>C、支持多种文件格式的导入和导出</p>
<p>D、支持会话变量和系统全局变量的可视化修改，降低用户记忆变量的难度</p>
<p>E、通过WebSQL技术为开发人员提供SQL语法高亮、格式化、智能提示等贴心特性，支持PL对象及匿名块的编译、运行、调试</p>
<p>*79、OceanBase的Paxos协议，不同于传统的主备库或者双活方案，可以彻底规避在容灾场景下的脑裂问题（也就是同时有两个主数据库的场景）。</p>
<p>O对</p>
<p>O错</p>
<p>*80、每台OB Server是相对独立的，都有自己独立的SQL引擎，如果应用需要的数据不在当前OB Server上，该OB Server将协调其他OB Server的数据，统一反馈给应用，这个过程对应用是透明的。</p>
<p>O对</p>
<p>O错</p>
<p>*81、主副本通过同步Redo-Log日志的方式实现可靠性，主副本需要收到所有从副本落盘成功的消息后才能响应应用。</p>
<p>O对</p>
<p>O错</p>
<p>*82、假如一个分区有3个副本，其中1个是主副本，剩余2个是从副本，一般情况下，业务读写操作均访问该主副本。</p>
<p>〇对</p>
<p>O错</p>
<p>*83、管理员需要手工指定一个分区的哪个副本是主副本，哪个是从副本。</p>
<p>O对</p>
<p>O错</p>
<p>*84、分区的副本只包含硬盘上的静态数据（SS Table），不包括Mem Table数据和日志数据。</p>
<p>〇对</p>
<p>O错</p>
<p>*85、主副本只能打散到所有Zone内，实现访问流量的负载均衡，不能将主副本聚焦到一个Zone内。</p>
<p>O对</p>
<p>O错</p>
<p>*86、OceanBase可以支持在一个数据库中同时支持MySQL租户和Oracle租户。</p>
<p>O对</p>
<p>O错</p>
<p>*87、OceanBase通过Explain命令查看优化器针对给定SQL生成的逻辑执行计划，Explain所展示的计划是在执行命令时优化器根据当前的用户输入和数据统计信息所生成的逻辑执行计划,而并不是在计划缓存中真正被使用的物理执行计划。</p>
<p>O对</p>
<p>O错</p>
<p>*88、租户逻辑上类似传统数据库的实例，创建完成后，每个租户都将有自己的专属进程。</p>
<p>○对</p>
<p>O错</p>
<p>*89、如果要部署一个“5-5-5”的集群，也就是集群有3个Zone，每个Zone有5台服务器，一共15台服务器。创建集群时，只需要指定RootService所在的3台机器，不需要在创建集群时就78、指定所有15台机器。集群创建成功后，再将剩余的12台服务器添加进集群。</p>
<p>○对</p>
<p>O错</p>
<p>*90、OceanBase只支持X86架构的CPU，不支持其他CPU（如鲲鹏、海光、飞腾等）。</p>
<p>O对</p>
<p>O错</p>
<p>*91、memory_limit_percentage设置成90，意味着memtable内存写入到90%会触发合并操作。</p>
<p>O对</p>
<p>O错</p>
<p>*92、会话变量只对当前会话生效，不影响该租户下的其他会话。</p>
<p>O对</p>
<p>O错</p>
<p>*93、Global级（租户级）变量修改后，对当前已经打开的session也依然生效。</p>
<p>O对</p>
<p>O错</p>
<p>*94、普通租户只能设置自己租户的参数，系统租户可以查看和设置所有租户的参数（包括系统租户和普通租户）。</p>
<p>O对</p>
<p>O错</p>
<p>*95、普通租户无法更改自身的系统变量，需要系统租户（sys）来更改普通租户的系统变量。</p>
<p>O对</p>
<p>O错</p>
<p>*96、OceanBase数据库是在阿里和蚂蚁内部孵化了10年后才逐步推广到外部市场的。</p>
<p>○对</p>
<p>O错</p>
<p>*97、OceanBase数据库是基于开源数据库的再发行产品。</p>
<p>O对</p>
<p>O错</p>
<p>*98、TPC-C就是一个跑分测试，官方没有什么规则限制，只要能跑高分就行。</p>
<p>O对</p>
<p>O错</p>
<p>*99、OceanBase已发布到阿里云公有云及专有云中。</p>
<p>O对</p>
<p>O错</p>
<p>*100、合并必须依赖OceanBase自动完成，无法手工启动合并。</p>
<p>〇对</p>
<p>O错</p>
<p>*101、OceanBase的数据在磁盘中按主键有序排列。</p>
<p>O对</p>
<p>O错</p>
<p>*102、分库分表的架构虽然解决了集中式数据库的扩展性问题，但也带来了新的问题（不支持复杂SQL，较难保证分布式事务的ACID等）。</p>
<p>O对</p>
<p>O错</p>
<p>*103、一般情况下，每台OB Server都有主副本和从副本，实现整体的负载均衡，避免出现OB Server忙闲不均的现象。</p>
<p>〇对</p>
<p>O错</p>
<p>*104、应用通过OB Proxy连接到OceanBase集群，比直连主副本所在的OB Server性能更好？</p>
<p>〇对</p>
<p>O错</p>
<p>*105、对于一个三副本的集群（有三个Zone）。企业在一个城市有两个机房，将两个Zone部署到1个机房中，将另一个Zone部署到另一个机房中，可以提供机房级的容灾。</p>
<p>〇对</p>
<p>O错</p>
<p>*106、OceanBase除了支持同城三机房及三地五中心五副本高可用方案外，也支持传统的同城两机房方案和两地三中心方案，以便更好的利旧企业已有的基础设施。</p>
<p>〇对</p>
<p>O错</p>
<p>*107、OceanBase在少数副本不可用的情况下，可以实现RPO&#x3D;0，RTO&lt;30秒。</p>
<p>O对</p>
<p>O错</p>
<p>*108、每个数据库服务的实例（租户）不感知其他实例（租户）的存在，租户拥有一组计算和存储资源，提供一套完整独立的数据库服务。</p>
<p>O对</p>
<p>O错</p>
<p>*109、一个租户在同一个Server上可以有一个或多个资源单元UNIT。</p>
<p>O对</p>
<p>O错</p>
<p>*110、创建资源单元仅仅指定CPU，MEMORY参数即可，无需指定lOPS，DISK_SIZE，SESSION_NUM参数。</p>
<p>O对</p>
<p>O错</p>
<p>*111、同一个资源单元定义unit config（比如2C8G，或者4C16G等），可以被多个资源池使用。</p>
<p>O对</p>
<p>O错</p>
<p>*112、RootService总控服务需要部署到每一台0B Server中。</p>
<p>O对</p>
<p>O错</p>
<p>*113、Zone可以对应不同的城市，或者一个城市的不同机房，或者一个机房的不同机架，以实现不同级别的容灾。</p>
<p>O对</p>
<p>O错</p>
<p>*114、Zone是个逻辑概念，是给集群内的一批机器打上同一个tag，属于同一个tag的服务器归属一个Zone。</p>
<p>O对</p>
<p>O错</p>
<p>*115、租户的资源池一旦创建完成，就不可以改变。如果需要扩容，需要删除旧资源池，创建一个更大规模的资源池。</p>
<p>O对</p>
<p>O错</p>
<p>116、创建租户时，需要指定租户类型为Oracle租户或者MySQL租户，以满足不同开发者的需求。</p>
<p>O对</p>
<p>O错</p>
<p>*117、扩容服务器加入集群后，集群会基于负载均衡的策略，自动的将部分主副本和从副本迁移到扩容服务器中，以实现整体的负载均衡。</p>
<p>〇对</p>
<p>O错</p>
<p>118、修改资源池可以实现租户的另一种扩容&#x2F;缩容的方式。比如在每个Zone中增加&#x2F;减少节点数量，可以通过修改资源池的unit_num来实现。</p>
<p>○对</p>
<p>O错</p>
<p>*119、在OCP中，可以选择某台observer进行“重启”，这个操作后台是通过系统租户登录，对该台机器的ip地址，执行stop server操作，将这台机器上的读写流量切走。然后重新启动observer进程，最后通过start server恢复服务</p>
<p>O对</p>
<p>O错</p>
<p>*120、OCP是管理单元，只支持单机部署，不支持多节点高可靠部署。</p>
<p>O对</p>
<p>O错</p>
<p>*121、通过OCP删除OBServer后，系统将会删除该OBServer的所有数据，且无法恢复，请谨慎操作。</p>
<p>O对</p>
<p>O错</p>
<p>第一章模拟题答案</p>
<p>1.【判断题】分库分表的架构虽然解决了集中式数据库的扩展性问题，但也带来了新的问题（不支持</p>
<p>复杂SQL，较难保证分布式事务的 ACID等）。（T）</p>
<p>2.【多选题】传统的集中式关系型数据库面临哪些挑战？（AC）</p>
<p>A：成本高：运行在高端服务器、小型机、高端存储等专有硬件上；</p>
<p>B：生态欠缺：文档、培训、应用等都不足；</p>
<p>C：扩展性差：无法摆脱单机的架构，只能纵向扩展，无法横向扩展；</p>
<p>D：性能差：任何时候，传统集中式数据库的性能都比分布式数据库较差；</p>
<p>第二章模拟题</p>
<p>1.【判断题】TPC-C就是一个跑分测试，没有什么规则限制，只要能跑高分就行。（F）</p>
<p>2.【判断题】OceanBase数据库是在阿里和蚂蚁内部孵化了10年后才逐步推广到外部市场的。（T）</p>
<p>3.【判断题】OceanBase数据库是基于开源数据库的再发行产品。（F）</p>
<p>4.【单选题】OceanBase是一个什么类型的数据库（C）</p>
<p>A：集中式数据库；</p>
<p>B：NoSQL数据库；</p>
<p>C：分布式关系型数据库；</p>
<p>5.【多选题】OceanBase的核心特性有哪些？（ABCD）</p>
<p>A：高扩展，可以使用普通的PC服务器进行横向扩展；</p>
<p>B：高性能，峰值峰值6,100万次&#x2F;秒，单表最大3,200亿行；</p>
<p>C：高可用，通过Paxos协议保证强一致性，RPO&#x3D;0，RTO&lt;30秒；</p>
<p>D：高兼容，支持MySQL及Oracle两种模式，降低业务迁移改造成本；</p>
<p>E：高成本，使用小型机、高端存储等专有硬件；</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第三章模拟题</p>
<p>1.【判断题】OceanBase已发布到阿里云公有云及专有云中。（T）</p>
<p>2.【判断题】OceanBase只支持X86架构的CPU，不支持其他CPU（如鲲鹏、海光、飞腾等）。（F）</p>
<p>3.【判断题】Zone是个逻辑概念，是给集群内的一批机器打上同一个tag，属于同一个tag的服务器归属一个Zone。（T）</p>
<p>4.【判断题】Zone可以对应不同的城市，或者一个城市的不同机房，或者一个机房的不同机架。（T）</p>
<p>5.【判断题】租户的资源池一旦创建完成，就不可改变。（F）</p>
<p>6.【单选题】OceanBase是一个集群，一下哪个组件管理整个集群，支持全局DDL、集群数据合并等功能。（B）</p>
<p>A: OB Proxy B：RootService总控服务 C：OCP管理平台 D：ODC开发者中心</p>
<p>7.【单选题】OceanBase集群可以同时支持MySQL和Oracle的租户，哪个黑屏工具可以连接到Oracle租户（A）</p>
<p>A：OceanBase客户端； B：标准MySQL客户端</p>
<p>8.【单选题】OceanBase不支持什么操作系统（B）</p>
<p>A：CentOS； B：Windows C：中标麒麟 D：银河麒麟</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第三章模拟题（2）</p>
<p>9.【单选题】如果一个OceanBase集群有3个Zone，每个Zone有5台OB Serer。那么一个分区最多有几份全能型副本呢？</p>
<p>（B）</p>
<p>A：10 B：3 C：6 D：5</p>
<p>10.【单选题】如果一个集群有3个Zone，每个Zone有5台 OB Server。一个租户对应的资源池的Unit Num&#x3D;3，最终该租户</p>
<p>有多少个资源单元呢？（B）</p>
<p>A： 15 B：9 C：45 D：30</p>
<p>11.【多选题】OceanBase主要有哪些产品组成？（ABCD）</p>
<p>A：OBServer：提供SQL引擎及存储引擎，同时兼容MySQL和Oracle模式；使用Paxos协议确保高可用性；</p>
<p>B：OCP云管理平台：给管理员提供的管理工具，提供集群管理、Zone管理、租户管理等功能；</p>
<p>C：OMS数据迁移工具：提供基线数据和增量数据的同步功能，可以从数据仓库订阅数据链路、从异构数据库迁移数据；</p>
<p>D：ODC开发者中心：提供数据库日常开发、SQL诊断、会话管理及数据导入导出能功能。</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第四章模拟题（1）</p>
<p>1.【判断题】分区的副本只包含硬盘上的静态数据（SS Table），不包括MemTable数据和日志数据。（F）</p>
<p>2.【判断题】主副本只能打散到所有Zone内，不能聚焦到一个Zone内。（F）</p>
<p>3.【判断题】每台OB Server是相对独立的，都有自己独立的SQL引擎，如果应用需要的数据不在当前OB Server上，该</p>
<p>OB Server将协调其他OB Server的数据，统一反馈给应用，这个过程对应用是透明的。（T）</p>
<p>4.【判断题】主副本通过同步Redo-Log日志的方式实现可靠性，主副本需要收到所有从副本落盘成功的消息后才能响应</p>
<p>应用。（F）</p>
<p>5.【判断题】企业在一个城市有2个机房，将2个Zone部署到1个机房中，将另一个Zone部署到另一个机房中，可以提供</p>
<p>机房级的容灾。（F）</p>
<p>6.【单选题】OceanBase是以（）为单位组建Paxos协议组。（D）</p>
<p>A: 租户 B：数据库 C：表 D：分区</p>
<p>7.【单选题】以下关于OceanBase扩容和缩容描述正确的是。（C）</p>
<p>A：需要管理员停止业务 B：需要业务做一定的修改 C：支持动态扩容和缩容，对业务无感知 D：不能使用公有</p>
<p>云资源</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第四章模拟题（2）</p>
<p>8.【单选题】OceanBase使用两阶段提交协议保证事务的原子性，在两阶段提交协议中，谁是协调者呢？（B）</p>
<p>A：OB Proxy B：OB Server C：RootService总控服务 D：OCP云管理平台</p>
<p>9.【多选题】OceanBase的Oracle租户支持哪些事务隔离级别（BC）</p>
<p>A：脏读 B：Read-Committed C：Serializable D：Repeatable-Read</p>
<p>10.【单选题】OceanBase使用哪种技术解决了读写互斥的问题。（A）</p>
<p>A：MVCC B：Paxos协议 C：全局快照 D：互斥锁</p>
<p>11.【多选题】以下对OB Proxy的描述是正确的（AD）</p>
<p>A：OB Proxy位于应用和OB Server之间，将应用的请求路由到合适的OB Server；</p>
<p>B：OB Proxy必须部署到一台独立的服务器上，以保证其性能要求；</p>
<p>C：OB Proxy参与数据库引擎的计算任务以及事务处理；</p>
<p>D：OB Proxy是一个“无状态”的服务进程，不做数据持久化；</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第五章模拟题</p>
<p>1.【判断题】 OceanBase可以支持在一个集群中同时支持MySQL租户和Oracle租户。（T）</p>
<p>2.【判断题】使用Explain命令查看SQL执行计划时，SQL也会真正执行。（F）</p>
<p>3.【判断题】合并必须依赖OceanBase自动完成，无法手工启动合并。（F）</p>
<p>4.【判断题】OceanBase的数据在磁盘中按主键有序排列。（T）</p>
<p>5.【单选题】使用 JDBC连接Oracle租户时，需要使用哪种JDBC驱动。（C）</p>
<p>A: MySQL标准的JDBC驱动 B：Oracle标准的JDBC驱动 C：OceanBase自己开发的JDBC驱动</p>
<p>6.【单选题】为了达到更好的压缩效果，OceanBase一般会进行进行几次压缩。（B）</p>
<p>A：1次 B：2次 C：3次 D：4次</p>
<p>7.【多选题】OceanBase备份恢复业务支持哪些存储介质（AD）</p>
<p>A：NFS B：IP-SAN C：FC-SAN D：阿里云OSS</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第六章模拟题</p>
<p>1.【判断题】会话变量只对当前会话生效，不影响该租户下的其他会话 。（T）</p>
<p>\2. 【单选题】通过哪个命令可以查询参数的属性。（A）</p>
<p>A：show parameters like ‘%<pattern>%’; B：alter system set <name> &#x3D; <value>;</p>
<p>C：show variables like ‘%<pattern>%’; D：set @@global.<name> &#x3D; <value>;</p>
<p>3.【多选题】参数有哪两个级别？（AD）</p>
<p>A：集群级 B：Zone级 C：OB Server级 D：租户级</p>
<p>版权所有©北京奥星贝斯科技有限公司</p>
<p>第七章模拟题</p>
<p>1.【单选题】以下哪个组件提供图形化的管理界面，支持集群管理、租户管理、监控告警等功能？（B）</p>
<p>A：ODC开发者中心 B：OCP云管理平台 C：OB Proxy D：OB Server</p>
]]></content>
  </entry>
  <entry>
    <title>英语</title>
    <url>/2023/09/22/%E8%8B%B1%E8%AF%AD/</url>
    <content><![CDATA[<p><img src="C:\Users\Dt\Desktop\ypy模板\图片\HTE8SJBA_UQD(WGE3([N~CG.png"></p>
]]></content>
  </entry>
  <entry>
    <title>算法模板</title>
    <url>/2023/02/14/ypy%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center">运算符</th>
<th align="center">结合律</th>
<th align="center">助记</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>::</code></td>
<td align="center">从左至右</td>
<td align="center">作用域</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>a++</code>、<code>a--</code>、 <code>type()</code>、<code>type&#123;&#125;</code>、 <code>a()</code>、<code>a[]</code>、 <code>.</code>、<code>-&gt;</code></td>
<td align="center">从左至右</td>
<td align="center">后缀自增减、 函数风格转型、 函数调用、下标、 成员访问</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>!</code>、<code>~</code>、 <code>++a</code>、<code>--a</code>、<code>+a</code>、<code>-a</code>、 <code>(type)</code>、<code>sizeof</code>、<code>&amp;a</code>、 <code>*a</code>、 <code>new</code>、 <code>new[]</code>、<code>delete</code>、 <code>delete[]</code></td>
<td align="center"><strong>从右至左</strong></td>
<td align="center">逻辑非、按位非、 前缀自增减、正负、 C 风格转型、取大小、取址、 指针访问、 动态内存分配</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>.*</code>、<code>-&gt;*</code></td>
<td align="center">从左至右</td>
<td align="center">指向成员指针</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>a*b</code>、<code>a/b</code>、<code>a%b</code></td>
<td align="center">从左至右</td>
<td align="center">乘除、取模</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><code>a+b</code>、<code>a-b</code></td>
<td align="center">从左至右</td>
<td align="center">加减</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td>
<td align="center">从左至右</td>
<td align="center">按位左右移</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td>
<td align="center">从左至右</td>
<td align="center">大小比较</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>==</code>、<code>!=</code></td>
<td align="center">从左至右</td>
<td align="center">等价比较</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><code>a&amp;b</code></td>
<td align="center">从左至右</td>
<td align="center">按位与</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><code>^</code></td>
<td align="center">从左至右</td>
<td align="center">按位异或</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">&#96;</td>
<td align="center">&#96;</td>
<td align="center">从左至右</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">从左至右</td>
<td align="center">逻辑与</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">&#96;</td>
<td align="center"></td>
<td align="center">&#96;</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><code>a?b:c</code>、 <code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&amp;=</code>、<code>^=</code>、&#96;</td>
<td align="center">&#x3D;<code>、</code>&lt;&lt;&#x3D;<code>、</code>&gt;&gt;&#x3D;&#96;</td>
<td align="center"><strong>从右至左</strong></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><code>,</code></td>
<td align="center">从左至右</td>
<td align="center">逗号</td>
</tr>
</tbody></table>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>以二分答案的check函数为例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; check = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=cnt&amp;&amp;a[i]&gt;=x-cnt<span class="number">-1</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="读入优化"><a href="#读入优化" class="headerlink" title="读入优化"></a>读入优化</h2><p>如果输入输出规模超过1e6就不建议使用cin&#x2F;cout</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭同步流</span></span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="int128"><a href="#int128" class="headerlink" title="__int128"></a>__int128</h2><p><code>__int128</code> 就是占用128字节的整数存储类型。由于是二进制，范围就是$-2^{127}$ ~ $2^{127} - 1$ </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">81</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">不能关流!!!!!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">__int128 a=read();</span></span><br><span class="line"><span class="comment">__int128 b=read();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">print(a+b);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> __int128 <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __int128 x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">9</span>)</span><br><span class="line">        <span class="built_in">print</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">__int128 game[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">__int128 f[MAXN][MAXN];</span><br><span class="line"><span class="function">__int128 <span class="title">solve</span><span class="params">(__int128 a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">0</span>;len&lt;=m;++len)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len&lt;=m;++i)</span><br><span class="line">            f[i][i+len]=<span class="built_in">max</span>(<span class="number">2</span>*f[i+<span class="number">1</span>][i+len]+<span class="number">2</span>*a[i],<span class="number">2</span>*f[i][i+len<span class="number">-1</span>]+<span class="number">2</span>*a[i+len]);</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int128 ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            game[i][j] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans+=<span class="built_in">solve</span>(game[i]);</span><br><span class="line">    <span class="built_in">print</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p><a href="https://blog.csdn.net/lanchunhui/article/details/49644373">(10条消息) C++基础——简单而强大的bitset_五道口纳什的博客-CSDN博客</a></p>
<p>里面存的是一个01串，可以用来当做标记数组</p>
<p>&lt;&lt;,&gt;&gt;运算符在这里是把<strong>值的位置</strong>往左或往右移动几位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">bitset&lt;maxn&gt; dp[<span class="number">102</span>];<span class="comment">//dp[i][j]-&gt;第i轮，值为j的数是否存在</span></span><br><span class="line"><span class="type">int</span> n, l ,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    dp[<span class="number">0</span>].<span class="built_in">set</span>(<span class="number">0</span>);             <span class="comment">//第0位要置1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = l; j &lt;= r; j++)</span><br><span class="line">            dp[i] |= dp[i<span class="number">-1</span>]&lt;&lt;(j * j);</span><br><span class="line">        		  <span class="comment">/* dp[i-1]&lt;&lt;(j * j) -&gt; 上一轮的所有数加上这一轮的数*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n].<span class="built_in">count</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双端队列（STL）"><a href="#双端队列（STL）" class="headerlink" title="双端队列（STL）"></a>双端队列（STL）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    deque&lt;<span class="type">int</span> &gt; dq;</span><br><span class="line">    dq.<span class="built_in">push_front</span>(a); <span class="comment">//添加元素到头</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(a); <span class="comment">//添加元素到尾</span></span><br><span class="line">    </span><br><span class="line">    a = dq.<span class="built_in">front</span>(); <span class="comment">//取出头元素</span></span><br><span class="line">    a = dq.<span class="built_in">back</span>(); <span class="comment">//取出尾元素</span></span><br><span class="line"></span><br><span class="line">    dq.<span class="built_in">pop_front</span>(); <span class="comment">//删除头元素</span></span><br><span class="line">    dq.<span class="built_in">pop_back</span>(); <span class="comment">//删除尾元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速计算a*b % mod的结果（主要目的是换乘法为加法，防止爆数据），或者快速计算a^b % mod 的结果，时间复杂度大大降低。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">q_pow</span><span class="params">(ll a, ll b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)	ans = (ans*a)%mod;</span><br><span class="line">		b /= <span class="number">2</span>;</span><br><span class="line">		a = (a*a)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列(priority_queue)"></a>优先队列(priority_queue)</h2><p>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p>
<p>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</p>
<p>一般是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型</span></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span> <span class="comment">//运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="type">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp2</span> <span class="comment">//重写仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l,r,len;</span><br><span class="line">	<span class="built_in">tmp1</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)&#123;l = a;r = b;len = c;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(len==a.len) <span class="keyword">return</span> l &gt; a.l;</span><br><span class="line">		<span class="keyword">return</span> len &lt; a.len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>insert(x) 可将 x 插入 set 容器中</p>
<p>find(value) 返回 set 中对应值为 value 的迭代器</p>
<p>erase(value) ，value 为所需要删除元素的值。</p>
<p>每次操作都是logn</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>c++中map与unordered_map的区别</p>
<ul>
<li><strong>运行效率方面</strong>：unordered_map最高，而map效率较低但 提供了稳定效率和有序的序列。</li>
<li><strong>占用内存方面</strong>：map内存占用略低，unordered_map内存占用略高,而且是线性成比例的。</li>
</ul>
<h2 id="sqrt精度调整"><a href="#sqrt精度调整" class="headerlink" title="sqrt精度调整"></a>sqrt精度调整</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll x=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">while</span> (x*x&gt;n) x--;</span><br><span class="line"><span class="keyword">while</span> ((x+<span class="number">1</span>)*(x+<span class="number">1</span>)&lt;=n) x++;</span><br></pre></td></tr></table></figure>

<h2 id="预处理小规模组合数"><a href="#预处理小规模组合数" class="headerlink" title="预处理小规模组合数"></a>预处理小规模组合数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">60</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> C[i][j] = (C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>]) % mod;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">2</span>&lt;&lt;<span class="number">14</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">	<span class="type">int</span> temp = n;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">14</span>;j++) <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>) temp -= b[j], cnt++;</span><br><span class="line">	res = <span class="built_in">min</span>(res, cnt + __builtin_popcountll(temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>__builtin_popcountll()函数可求一个数的二进制表示有多少个1</p>
<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><h2 id="简单模板"><a href="#简单模板" class="headerlink" title="简单模板"></a>简单模板</h2><p> <a href="https://vjudge.csgrandeur.cn/problem/HDU-2222/origin">HDU - 2222 </a></p>
<p>给定 <code>n</code> 个长度不超过 50 的由小写英文字母组成的单词准备查询，以及一篇长为 <code>m</code> 的文章，问：文中出现了多少种待查询的单词。多组数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ms(a,b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> * <span class="number">55</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>],fail[N];<span class="comment">//tire树 和 失匹指针</span></span><br><span class="line"><span class="type">int</span> idx,cnt[N];</span><br><span class="line"><span class="type">char</span> s[M];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span> <span class="comment">//tire插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>,l = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u = s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!tr[p][u]) tr[p][u] = ++idx;</span><br><span class="line">		p = tr[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getfail</span><span class="params">()</span> <span class="comment">//获取fail</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//BFS遍历每一层</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="comment">//遍历第一层，初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!tr[p][i]) tr[p][i] = tr[fail[p]][i]; <span class="comment">//如果当前节点i不存在</span></span><br><span class="line">			                                         <span class="comment">//则让这个【节点】指向它的父亲节点的fail指针                                                      //所指向的节点i</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">//否则就让当前【节点i的fail】指向它的父亲节点的fail指针所指向的节点i</span></span><br><span class="line">			&#123;</span><br><span class="line">				fail[tr[p][i]] = tr[fail[p]][i];</span><br><span class="line">				q.<span class="built_in">push</span>(tr[p][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>,ans = <span class="number">0</span>,l = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u = s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		p = tr[p][u];</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> j = p;</span><br><span class="line">		<span class="keyword">while</span>(j) <span class="comment">//一直向上找</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans += cnt[j];</span><br><span class="line">			cnt[j] = <span class="number">0</span>;</span><br><span class="line">			j = fail[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ms</span>(tr,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">ms</span>(fail,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">ms</span>(cnt,<span class="number">0</span>);</span><br><span class="line">	idx = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">		<span class="built_in">insert</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">getfail</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h2><p>1、如果两个元素已经在一个集合中，不需要合并操作（尤其是有边权的时候，会导致边权翻倍）</p>
<h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h2><p><a href="https://www.acwing.com/problem/content/description/838/">836. 合并集合 - AcWing题库</a></p>
<p>一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p>
<p>现在要进行 mm 个操作，操作共有两种：</p>
<ol>
<li><code>M a b</code>，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li>
<li><code>Q a b</code>，询问编号为 a 和 b 的两个数是否在同一个集合中；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N],a,b;</span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">//路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p><a href="https://www.acwing.com/problem/content/242/">240. 食物链 - AcWing题库</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,op;</span><br><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p[x]!=x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = <span class="built_in">find</span>(p[x]); <span class="comment">//先压缩路径</span></span><br><span class="line">		d[x] += d[p[x]]; <span class="comment">//再更新权值</span></span><br><span class="line">		p[x] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i] = i;</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(a&gt;n||b&gt;n) res ++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> pa = <span class="built_in">find</span>(a);</span><br><span class="line">			<span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">			<span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(pa==pb&amp;&amp;(d[a]-d[b])%<span class="number">3</span>) res++;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">				&#123;</span><br><span class="line">					p[pa] = pb;</span><br><span class="line">					d[pa] = d[b] - d[a]; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(pa==pb&amp;&amp;(d[a]-d[b]<span class="number">-1</span>)%<span class="number">3</span>) res++;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">				&#123;</span><br><span class="line">					p[pa] = pb;</span><br><span class="line">					d[pa] = d[b]+<span class="number">1</span>-d[a];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><a href="https://www.acwing.com/problem/content/description/241/">239. 奇偶游戏 - AcWing题库</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!mp[x]) mp[x] = ++cnt;</span><br><span class="line">	<span class="keyword">return</span> mp[x]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p[x] != x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = <span class="built_in">find</span>(p[x]);</span><br><span class="line">		d[x] ^= d[p[x]];</span><br><span class="line">		p[x] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s&quot;</span>,&amp;a,&amp;b,op);</span><br><span class="line">		a = <span class="built_in">get</span>(a<span class="number">-1</span>);</span><br><span class="line">		b = <span class="built_in">get</span>(b);</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;o&#x27;</span>) t = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> pa = <span class="built_in">find</span>(a) , pb = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pa==pb)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(d[a]^d[b]!=t)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = i<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p[pa] = pb;</span><br><span class="line">			d[pa] = d[a]^d[b]^t;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h2><p><img src="https://s2.loli.net/2022/06/28/T9N2gpiSZXf54Yk.jpg" alt="2675_e50e111055-4"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>, Base = N / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.<span class="built_in">count</span>(x) == <span class="number">0</span>) &#123;</span><br><span class="line">        S[x] = ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = m;  <span class="comment">//如果无矛盾, 输出问题数量, 初始的时候为m</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        string type;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; type;</span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);  <span class="comment">// s[a-1], s[b]</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;even&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a + Base) == <span class="built_in">find</span>(b)||<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b+Base)) &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a + Base)] = <span class="built_in">find</span>(b + Base);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)||<span class="built_in">find</span>(a+Base)==<span class="built_in">find</span>(b+Base)) &#123;</span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a + Base)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b + Base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>树状数组作用：<br>1.快速求前缀和<code>O(log n)</code><br>2.修改某一个数<code>O(log n)</code></p>
<p>3.求数组逆序对</p>
<p><img src="https://s2.loli.net/2022/06/29/9iEmkKQPYqts4M3.png" alt="树状数组.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lowbit:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line">查询：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) sum+=tr[i];</span><br><span class="line">更改：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=c;</span><br></pre></td></tr></table></figure>

<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>最坏情况下时间复杂度有$O(4×nlogn)$，全局longlong，输入输出都会影响复杂度</p>
<h2 id="懒标记线段树"><a href="#懒标记线段树" class="headerlink" title="懒标记线段树"></a>懒标记线段树</h2><p>可以使用懒标记的操作有：区间加减，区间乘除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N =  <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">	ll l,r,lazy,sum;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line">ll temp_num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[i].sum = tree[i*<span class="number">2</span>].sum + tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[i].lazy)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i*<span class="number">2</span>].lazy += tree[i].lazy;</span><br><span class="line">		tree[i*<span class="number">2</span>+<span class="number">1</span>].lazy += tree[i].lazy;</span><br><span class="line">		tree[i*<span class="number">2</span>].sum += (tree[i*<span class="number">2</span>].r - tree[i*<span class="number">2</span>].l + <span class="number">1</span>) * tree[i].lazy;</span><br><span class="line">		tree[i*<span class="number">2</span>+<span class="number">1</span>].sum += (tree[i*<span class="number">2</span>+<span class="number">1</span>].r - tree[i*<span class="number">2</span>+<span class="number">1</span>].l + <span class="number">1</span>) * tree[i].lazy;</span><br><span class="line">		tree[i].lazy = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l ,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[i].l = l;</span><br><span class="line">	tree[i].r = r;</span><br><span class="line">	tree[i].lazy = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i].sum = temp_num[l];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> mid = tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(i*<span class="number">2</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(i*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r,ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i].sum += (tree[i].r - tree[i].l + <span class="number">1</span>)*num;</span><br><span class="line">		tree[i].lazy += num;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> mid = tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(i);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) <span class="built_in">add</span>(i*<span class="number">2</span>,l,r,num);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">add</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r,num);</span><br><span class="line">	<span class="built_in">pushup</span>(i);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> tree[i].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">pushdown</span>(i);</span><br><span class="line">	<span class="type">int</span> mid = tree[i].l+tree[i].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ll s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) s += <span class="built_in">query</span>(i*<span class="number">2</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) s += <span class="built_in">query</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="势能线段树"><a href="#势能线段树" class="headerlink" title="势能线段树"></a>势能线段树</h2><p>某些修改存在一些奇妙的性质，使得序列每个元素被修改的次数有一个<strong>上限</strong>(如开方)</p>
<p>可以在线段树每个节点上记录一个值，<strong>表示对应区间内是否每个元素都达到修改次数上限</strong></p>
<p>区间修改时暴力递归到叶子节点，如果途中遇到一个节点，这个节点的对应区间内每个元素都达到修改次数上限则在这个节点 return 掉</p>
<p>可以证明复杂度为 $O(nlogn ×修改次数上限)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum,cnt[<span class="number">25</span>];</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[i].sum = (tr[i&lt;&lt;<span class="number">1</span>].sum + tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">        tr[i].cnt[j] = tr[i&lt;&lt;<span class="number">1</span>].cnt[j] + tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[i].l = l,tr[i].r = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        tr[i].sum = (a[l]*a[l])%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">            tr[i].cnt[j] = a[l]&gt;&gt;j&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l==tr[i].r) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tr[i].cnt[j]&amp;&amp;(x&gt;&gt;j&amp;<span class="number">1</span>)) sum|=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">            <span class="keyword">else</span> tr[i].cnt[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tr[i].sum = (ll)sum*sum%mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r) &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">24</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[i].cnt[j]&amp;&amp;(x&gt;&gt;j&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=l) <span class="built_in">modify</span>(i&lt;&lt;<span class="number">1</span>,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) <span class="built_in">modify</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x);</span><br><span class="line">    <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r) <span class="keyword">return</span> tr[i].sum;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=l) s = <span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>,l,r)%mod;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) s = (s+<span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%mod;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="type">int</span> op,l,r,x;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l,r)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="杂选题"><a href="#杂选题" class="headerlink" title="杂选题"></a>杂选题</h2><h3 id="导弹拦截"><a href="#导弹拦截" class="headerlink" title="导弹拦截"></a>导弹拦截</h3><p>[P1020 <a href="https://www.luogu.com.cn/problem/P1020">NOIP1999 普及组] 导弹拦截 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>DP + 贪心 + 二分  <strong>O(nlogn)</strong></p>
<p><strong>Dilworth 定理</strong></p>
<p>将拦截的导弹的高度提出来成为原高度序列的一个子序列，根据题意这个子序列中的元素是单调不增的（即后一项总是不大于前一项），我们称为<strong>单调不升子序列</strong>。本问所求能拦截到的最多的导弹，即求<strong>最长的单调不升子序列</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> n,cnt;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[++n]));</span><br><span class="line">    n--;</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>; <span class="comment">//初始化一个最大值，防止边界溢出</span></span><br><span class="line">    <span class="type">int</span> l,r,len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l = <span class="number">0</span>,r = len;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(b[mid]&gt;=a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = r+<span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[i]); <span class="comment">//记录答案</span></span><br><span class="line">        b[r+<span class="number">1</span>] = a[i]; <span class="comment">//更新当前 长度+1 的序列中最大的最后一位数</span></span><br><span class="line">        len = <span class="built_in">max</span>(len,r+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    t[<span class="number">1</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>,r = res;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t[mid]&gt;=a[i]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t[r]&gt;=a[i]) t[r] = a[i];</span><br><span class="line">        <span class="keyword">else</span> t[++res] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从左到右依次枚举每个导弹。假设现在有若干个导弹拦截系统可以拦截它，那么我们肯定选择这些系统当中位置最低的那一个。如果不存在任何一个导弹拦截系统可以拦截它，那我们只能新加一个系统了</p>
<p>观察第二问的代码，与第一问进行比较，可以发现这段代码<strong>等价于</strong>计算最长上升子序列（严格上升，即后一项大于前一项）。这其实是 <strong>Dilworth 定理</strong>（将一个序列剖成若干个单调不升子序列的最小个数等于该序列最长上升子序列的个数），本处从代码角度证明了该结论。</p>
<h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> w[N][N],v[N][N],f[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,V;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;V);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;v[i][j],&amp;w[i][j]);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=s[i];k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=v[i][k]) f[j] = <span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[V]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line">ll f[N][N];</span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ms</span>(f,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++) &#123; <span class="comment">//枚举区间长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=len;j&lt;=n;i++,j++) &#123; <span class="comment">//枚举区间左右下标</span></span><br><span class="line">            <span class="keyword">if</span>(i==j) &#123; <span class="comment">//初始化区间长度为1的值</span></span><br><span class="line">                f[i][j] = a[i]*b[n];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j],f[i][j<span class="number">-1</span>]+b[n-(j-i)]*a[j]);</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j],f[i+<span class="number">1</span>][j]+b[n-(j-i)]*a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p><a href="https://www.acwing.com/problem/content/287/">285. 没有上司的舞会 - AcWing题库</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6050</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[N];<span class="comment">//储存每个上司的儿子</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][0] 不选i，子树的最大值 </span></span><br><span class="line"><span class="comment">f[i][1] 选i，子树的最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//边界</span></span><br><span class="line">    f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>] = a[u];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:son[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[i][<span class="number">0</span>];</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[i][<span class="number">1</span>],f[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> root = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        root -= u;</span><br><span class="line">        son[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(f[root][<span class="number">1</span>],f[root][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h3><p>换根DP 一般分为三个步骤：</p>
<p>指定任意一个根节点<br>一次dfs遍历，统计出当前子树内的节点对当前节点的贡献</p>
<p>一次dfs遍历，统计出当前节点的父节点对当前节点的贡献，然后合并统计答案</p>
<p>那么我们就要先 dfs 一遍，预处理出当前子树对于根的最大贡献（距离）和 次大贡献（距离）</p>
<p>处理 次大贡献（距离） 的原因是：</p>
<p>如果 当前节点 是其 父节点子树 的 最大路径 上的点，则 父节点子树 的 最大贡献 不能算作对该节点的贡献</p>
<p>因为我们的路径是 简单路径，不能 走回头路</p>
<p>然后我们再 dfs 一遍，求解出每个节点的父节点对他的贡献（即每个节点往上能到的最远路径</p>
<p>两者比较，取一个 max 即可</p>
<p><img src="https://s2.loli.net/2022/08/04/7sEvdAyQIuW5Fbr.png" alt="image-20220726183319977"></p>
<p><a href="https://www.acwing.com/problem/content/1075/">1073. 树的中心 - AcWing题库</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line">vector&lt;PII &gt; son[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> dow[N]; <span class="comment">//记录i结点的最长子节点,即i与dow[i]连接时获得的值最大;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> <span class="comment">//向下找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v = i.first, w = i.second;</span><br><span class="line">		<span class="keyword">if</span>(fa==v) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs1</span>(v,u);</span><br><span class="line">		<span class="type">int</span> dist = f[v][<span class="number">0</span>] + w;</span><br><span class="line">		<span class="keyword">if</span>(dist&gt;f[u][<span class="number">0</span>]) <span class="built_in">swap</span>(f[u][<span class="number">0</span>],f[u][<span class="number">1</span>]), f[u][<span class="number">0</span>] = dist, dow[u] = v;</span><br><span class="line">		<span class="keyword">else</span> f[u][<span class="number">1</span>] = <span class="built_in">max</span>(f[u][<span class="number">1</span>],dist);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> <span class="comment">//向上找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v = i.first, w = i.second;</span><br><span class="line">		<span class="keyword">if</span>(fa==v) <span class="keyword">continue</span>;</span><br><span class="line">		f[v][<span class="number">2</span>] = w;</span><br><span class="line">		<span class="keyword">if</span>(v==dow[u]) f[v][<span class="number">2</span>] += <span class="built_in">max</span>(f[u][<span class="number">2</span>],f[u][<span class="number">1</span>]); </span><br><span class="line">		<span class="keyword">else</span> f[v][<span class="number">2</span>] += <span class="built_in">max</span>(f[u][<span class="number">2</span>],f[u][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">dfs2</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		son[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">		son[b].<span class="built_in">push_back</span>(&#123;a,c&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> res = f[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		res = <span class="built_in">min</span>(res, <span class="built_in">max</span>(f[i][<span class="number">0</span>],f[i][<span class="number">2</span>]));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h3><p><a href="https://ac.nowcoder.com/acm/problem/50510">皇宫看守 (nowcoder.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1510</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[N];</span><br><span class="line"><span class="type">int</span> st[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    f[i][0] 对于i这个子树，i点由 其父 节点看守的最小花费</span></span><br><span class="line"><span class="comment">    f[i][1] 对于i这个子树，i点由 其子 节点看守的最小花费</span></span><br><span class="line"><span class="comment">    f[i][2] 对于i这个子树，i点由 本身 节点看守的最小花费</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>] = inf;</span><br><span class="line">    f[u][<span class="number">2</span>] = w[u];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i,u);</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]);</span><br><span class="line">        f[u][<span class="number">2</span>] += <span class="built_in">min</span>(f[i][<span class="number">0</span>],<span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]));</span><br><span class="line">        sum += <span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : son[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa) <span class="keyword">continue</span>;</span><br><span class="line">        f[u][<span class="number">1</span>] = <span class="built_in">min</span>(f[u][<span class="number">1</span>], sum - <span class="built_in">min</span>(f[i][<span class="number">1</span>],f[i][<span class="number">2</span>]) + f[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        w[a] = b;</span><br><span class="line">        cin&gt;&gt;b;</span><br><span class="line">        <span class="keyword">while</span>(b--) &#123;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            son[a].<span class="built_in">push_back</span>(c);</span><br><span class="line">            son[c].<span class="built_in">push_back</span>(a);</span><br><span class="line">            st[c] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(st[root]) root++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(f[root][<span class="number">1</span>],f[root][<span class="number">2</span>])&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">10</span>) + <span class="number">10</span>;</span><br><span class="line">ll f[<span class="number">12</span>][<span class="number">110</span>][N]; <span class="comment">//f[i][j][k] 第i行放置了j个将军，状态为k的所有方案</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line">vector&lt;<span class="type">int</span> &gt; a,b[N]; <span class="comment">//a放置合法状态,b放置a的合法转移状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//检查x有没有两个相邻的1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(x&amp;x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//获得x中有几个1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) c += (x&gt;&gt;i &amp; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(i)) a.<span class="built_in">push_back</span>(i), cnt[i] = <span class="built_in">count</span>(i); <span class="comment">//储存所有的合法状态</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i : a) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> j : a) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(i|j)&amp;&amp;((i&amp;j)==<span class="number">0</span>)) b[i].<span class="built_in">push_back</span>(j); <span class="comment">//储存所有的合法转移状态,i状态的上下行可以是j</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) <span class="comment">//n行转移，n+1行是为了好统计答案</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++) <span class="comment">//目前使用的国王棋子数量</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> k : a)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> u : b[k]) &#123;</span><br><span class="line">					<span class="type">int</span> c = cnt[k]; <span class="comment">//查看a中有几个已经放置的国王</span></span><br><span class="line">					<span class="keyword">if</span>(j&gt;=c) <span class="comment">//目前一共放j个国王，从b转移到a，要满足国王数不超标</span></span><br><span class="line">                        f[i][j][k] += f[i<span class="number">-1</span>][j-c][u];</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;f[n+<span class="number">1</span>][k][<span class="number">0</span>]&lt;&lt;endl; <span class="comment">//第n+1行什么都不放，相当于只在1~n行放国王，目前一共放了k个国王的总方案数，其实就是答案要求的方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> temp[N], s[<span class="number">2</span> * N];<span class="comment">//temps是原字符串,s是处理后的字符串</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span> * N]; <span class="comment">// p[i]-1 是对于s串，以i个字符为中心的最长回文串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    s[cnt++] = <span class="string">&#x27;@&#x27;</span>; <span class="comment">//左边界字符</span></span><br><span class="line">    s[cnt++] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">//填充字符</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(temp + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[cnt++] = temp[i];</span><br><span class="line">        s[cnt++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[cnt] = <span class="string">&#x27;!&#x27;</span>; <span class="comment">//右边界字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">            p[i] = <span class="built_in">min</span>(mx - i, p[<span class="number">2</span> * id - i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[i - p[i]] == s[i + p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = p[i] + i;</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">初始化：一般不需要</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="数Math"><a href="#数Math" class="headerlink" title="数Math"></a>数Math</h1><h2 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">去掉最后一位  	x &gt;&gt; 1</span></span><br><span class="line"><span class="comment">在最后加一个0 	x &lt;&lt; 1</span></span><br><span class="line"><span class="comment">在最后加一个1		(x &lt;&lt; 1) - 1</span></span><br><span class="line"><span class="comment">把最后一位变成1	x | 1</span></span><br><span class="line"><span class="comment">把最后一位变成0	(x | 1) - 1</span></span><br><span class="line"><span class="comment">最后一位取反		 x ^ 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">把右数第k位变成0	x &amp; (~(1 &lt;&lt; (k-1)))</span></span><br><span class="line"><span class="comment">把右数第k位取反	x ^ ((1 &lt;&lt; (k-1)))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">取末k位		  x &amp; ((1 &lt;&lt; k) - 1)</span></span><br><span class="line"><span class="comment">取右数第k位		 (x &gt;&gt; (k-1)) &amp; 1</span></span><br><span class="line"><span class="comment">把末k位变成1		 x | ((1 &lt;&lt; k) - 1)</span></span><br><span class="line"><span class="comment">末k位取反		  x ^ ((1 &lt;&lt; k) - 1)</span></span><br><span class="line"><span class="comment">把右边连续的1变成0 (x &amp; (x + 1))</span></span><br><span class="line"><span class="comment">把右边第一个0变成1  x | (x + 1) </span></span><br><span class="line"><span class="comment">把右边连续的0变成1	x | (x - 1)</span></span><br><span class="line"><span class="comment">取右边连续的1 	 (x ^ (x + 1)) &gt;&gt; 1</span></span><br><span class="line"><span class="comment">去掉右起第一个1的左边(lowbit)  x &amp; ( -x )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="gcd-lcm"><a href="#gcd-lcm" class="headerlink" title="gcd &amp; lcm"></a>gcd &amp; lcm</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辗转相除，它们的最大公约数等于a除以b的余数c和b之间的最大公约数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">return</span> b&gt;<span class="number">0</span> ? <span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lcm代码如下：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;<span class="comment">//防溢出 ， 很妙啊 ，大家可以记一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更相减损，两个正整数a和b（a&gt;b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数，避免了大整数取模，但是运算次数较多。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a-b,b);</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b-a,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><h3 id="算术基本定理（唯一分解"><a href="#算术基本定理（唯一分解" class="headerlink" title="算术基本定理（唯一分解"></a>算术基本定理（唯一分解</h3><p>就是因式分解的定理，所有的整数都可以唯一分解成若干个质因子乘积的形式：</p>
<p>$N &#x3D; P_1^{a1}\times P_2^{a2}\times … \times P_k^{ak}$ 其中 $P_i$ 是质数，每一个 $a_i \geq 0$</p>
<h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//求出n的所有约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i != n / i) &#123;  <span class="comment">// 避免 i==n/i, 重复放入 （n是完全平方数）</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : res) &#123;</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><h3 id="筛法求素数——线性筛法（欧拉筛法）"><a href="#筛法求素数——线性筛法（欧拉筛法）" class="headerlink" title="筛法求素数——线性筛法（欧拉筛法）"></a>筛法求素数——线性筛法（欧拉筛法）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> st[N];</span><br><span class="line">vector&lt;<span class="type">int</span> &gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxnum = N<span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=maxnum;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]&lt;=maxnum/i;j++) &#123;</span><br><span class="line">            st[i*primes[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p><img src="https://s2.loli.net/2022/11/28/ZfrhuQjXKT4OGdB.jpg" alt="1.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,res;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        res = a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=a/i;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(a%i==<span class="number">0</span>)</span><br><span class="line">                    a/=i;</span><br><span class="line">                res = res / i*(i<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">1</span>) res = res /a*(a<span class="number">-1</span>);</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h2><p><img src="https://s2.loli.net/2022/11/29/5kSTrqy7gLsD1NX.jpg" alt="6B8715BC-6CB8-4C2F-99BC-8762C6959443.jpeg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[primes[j] * i] = phi[i] * primes[j]; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[primes[j] * i] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂求逆元（费马小定理）"><a href="#快速幂求逆元（费马小定理）" class="headerlink" title="快速幂求逆元（费马小定理）"></a>快速幂求逆元（费马小定理）</h2><p>$a &#x2F; b ≡ a * x (mod n)$<br>两边同乘b可得 $a ≡ a * b * x (mod n)$<br>即 $1 ≡ b * x (mod n)$<br>同 $b * x ≡ 1 (mod n)$<br>由费马小定理可知，当n为质数时<br>$b ^ {(n - 1)} ≡ 1 (mod n)$<br>拆一个b出来可得 $b * b ^ {(n - 2)} ≡ 1 (mod n)$<br>故当n为质数时，b的乘法逆元 $x &#x3D; b ^{ (n - 2)}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">q_pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = (res * a)%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a = (a * a)%p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,p;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;p;</span><br><span class="line">    <span class="keyword">if</span>(__gcd(a,p)==<span class="number">1</span>) cout&lt;&lt;<span class="built_in">q_pow</span>(a,p<span class="number">-2</span>,p)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展欧几里得求逆元"><a href="#扩展欧几里得求逆元" class="headerlink" title="扩展欧几里得求逆元"></a>扩展欧几里得求逆元</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> &amp;x, <span class="type">long</span> <span class="type">long</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (x % b + b) % b);<span class="comment">//这里防止出现负数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a , ll b , ll modd)</span></span>&#123;		<span class="comment">//快速幂 </span></span><br><span class="line">	ll ans = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)	ans = ans * a % modd ;</span><br><span class="line">		a = a * a % modd ;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n , ll m)</span></span>&#123;			<span class="comment">//组合数Cnm的值 </span></span><br><span class="line">	ll ans1 = <span class="number">1</span> , ans2 = <span class="number">1</span> , ans3 = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">		ans1 = ans1 * i % mod ;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= m ; i++)</span><br><span class="line">		ans2 = ans2 * i % mod ;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= n - m ; i++)</span><br><span class="line">		ans3 = ans3 * i % mod ;</span><br><span class="line">	<span class="keyword">return</span> ans1 * <span class="built_in">qpow</span>(ans2 , mod - <span class="number">2</span> , mod) % mod * <span class="built_in">qpow</span>(ans3 , mod - <span class="number">2</span> , mod) % mod ;</span><br><span class="line">	<span class="comment">//费马小定理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="临时"><a href="#临时" class="headerlink" title="临时"></a>临时</h1><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><p>给定长度为 N 的整数序列 AA，下标为 1∼N。</p>
<p>现在要执行 MM 次操作，其中第 ii 次操作为给出三个整数 li,ri,ki，求$A[li],A[li+1],…,A[ri](即 A 的下标区间 [li,ri][li,ri]) $中第 ki 小的数是多少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="type">int</span> idx; <span class="comment">//用来搞下标</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r; <span class="comment">// 这里的l,r存的是左右儿子的下标,这里的区间需要自己推一下</span></span><br><span class="line">    <span class="type">int</span> cnt; <span class="comment">// 在这个点包含的区间里面有多少个数字</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span> + N* <span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> root[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回的是一个下标 这个下标从0开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),x) - nums.<span class="built_in">begin</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = ++idx;<span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> p; <span class="comment">// 代表到了叶子节点</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    tr[p].l = <span class="built_in">build</span>(l,mid); <span class="comment">// tr[]数组里面的l,r是自己左右儿子的下标 不是p这个点所代表的范围</span></span><br><span class="line">    tr[p].r = <span class="built_in">build</span>(mid + <span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = ++idx; <span class="comment">// 这是现在的节点</span></span><br><span class="line">    tr[now] = tr[pre]; <span class="comment">//这个节点会继承前一个版本的所有信息</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="comment">// 代表到了叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[now].cnt++; <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 下一个insert的前驱就是这个insert的前驱的左右儿子,因为x在的位置区间,都需要修改</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)<span class="comment">// 代表这个点在左边 ,</span></span><br><span class="line">    tr[now].l = <span class="built_in">insert</span>(tr[pre].l,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在右边</span></span><br><span class="line">    tr[now].r = <span class="built_in">insert</span>(tr[pre].r,mid + <span class="number">1</span>,r,x);</span><br><span class="line"></span><br><span class="line">    tr[now].cnt = tr[tr[now].l].cnt + tr[tr[now].r].cnt; <span class="comment">// 当前这个节点的cnt是左儿子的节点 + 右儿子的节点</span></span><br><span class="line">    <span class="comment">// 相当于pushup操作</span></span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> r;<span class="comment">// 代表到了叶子节点,也就是找到了这个点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = tr[tr[now].l].cnt - tr[tr[pre].l].cnt; <span class="comment">// 代表在询问区间L,R里面有几个数字</span></span><br><span class="line">    <span class="comment">// 前R个版本你在l,r里面有tr[tr[now].l].cnt 数字</span></span><br><span class="line">    <span class="comment">// 前L - 1个版本里面你在l,r里面有tr[tr[pre].l].cnt个数字</span></span><br><span class="line">    <span class="comment">// 那在[L,R]这个版本里面你在l,r里面就是有tr[tr[now].l].cnt - tr[tr[pre].l].cnt个数字</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= k) ans = <span class="built_in">query</span>(tr[pre].l,tr[now].l,l,mid,k); <span class="comment">// 代表你想要找的在区间左边 还是要找第k个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 右区间</span></span><br><span class="line">    ans = <span class="built_in">query</span>(tr[pre].r,tr[now].r,mid + <span class="number">1</span>,r,k - cnt);<span class="comment">//在右边就是找 第k - cnt个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 建立一下线段树的整体框架,因为框架是不变的,变的是里面的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++ ) <span class="comment">//接下来就是每一个版本了</span></span><br><span class="line">    &#123;</span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>],<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>,<span class="built_in">find</span>(a[i])); <span class="comment">// 可持久化数据结构都是联系自己前一个版本的信息</span></span><br><span class="line">        <span class="comment">//find(a[i]) 就是加入数字离散化下的下标 这里当成这个数字在用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; nums[<span class="built_in">query</span>(root[l - <span class="number">1</span>],root[r],<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>,k)] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="tire"><a href="#tire" class="headerlink" title="tire"></a>tire</h2><p>在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？</p>
<blockquote>
<p>字典树的初始化：只需要将0~idx之间的节点初始化即可，时间复杂度为线性</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N=<span class="number">100010</span>,M=<span class="number">31</span>*N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>],idx;</span><br><span class="line"><span class="comment">//M代表一个数字串二进制可以到多长</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;  <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;   <span class="comment">/////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx; <span class="comment">///如果插入中发现没有该子节点,开出这条路</span></span><br><span class="line">        p=son[p][u]; <span class="comment">//指针指向下一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;                               <span class="comment">///从最大位开始找</span></span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u]) <span class="comment">////如果当前层有对应的不相同的数</span></span><br><span class="line">        &#123;   <span class="comment">///p指针就指到不同数的地址</span></span><br><span class="line"></span><br><span class="line">          p=son[p][!u];</span><br><span class="line">          res=res*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">             <span class="comment">///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001</span></span><br><span class="line">        &#125;                                                       <span class="comment">///       010 </span></span><br><span class="line">        <span class="keyword">else</span>                                            <span class="comment">////          ---&gt;011                                                                           //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=son[p][u];</span><br><span class="line">            res=res*<span class="number">2</span>+<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        res=<span class="built_in">max</span>(res,<span class="built_in">search</span>(a[i]));  <span class="comment">///search(a[i])查找的是a[i]值的最大与或值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[N],p[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d%s&quot;</span>,&amp;n,p+<span class="number">1</span>,&amp;m,s+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求ne</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>图论模板</title>
    <url>/2023/03/22/qsq%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="300-拓扑排序"><a href="#300-拓扑排序" class="headerlink" title="300 拓扑排序"></a><a href="https://www.cnblogs.com/dx123/p/16320427.html">300 拓扑排序</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////Kahn 算法  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N], tp;</span><br><span class="line"><span class="type">int</span> din[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span>(din[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> x=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    tp.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : e[x])&#123;</span><br><span class="line">      <span class="keyword">if</span>(--din[y]==<span class="number">0</span>) q.<span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tp.<span class="built_in">size</span>() == n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    din[b]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">toposort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">auto</span> x:tp)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////DFS 算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N], tp;</span><br><span class="line"><span class="type">int</span> c[N]; <span class="comment">//染色数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  c[x] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[y]&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//有环 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!c[y])</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">dfs</span>(y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  c[x] = <span class="number">1</span>;</span><br><span class="line">  tp.<span class="built_in">push_back</span>(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">    <span class="keyword">if</span>(!c[x])</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">dfs</span>(x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">reverse</span>(tp.<span class="built_in">begin</span>(),tp.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">toposort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x:tp)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓扑序"><a href="#拓扑序" class="headerlink" title="拓扑序"></a>拓扑序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=cnt;x;x--)&#123;</span><br><span class="line">   <span class="keyword">if</span>(dp[x]==<span class="number">0</span>) <span class="comment">//若x为路的起点</span></span><br><span class="line">     dp[x]=nw[x];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> y : ne[x])</span><br><span class="line">     dp[y]=<span class="built_in">max</span>(dp[y],dp[x]+nw[y]);</span><br><span class="line"> &#125; <span class="comment">//在拓扑图上逆序dp</span></span><br></pre></td></tr></table></figure>



<h1 id="301-最短路-Dijkstra-算法"><a href="#301-最短路-Dijkstra-算法" class="headerlink" title="301 最短路 Dijkstra 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320431.html">301 最短路 Dijkstra 算法</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define inf 2147483647</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">int n,m,s,a,b,c;</span><br><span class="line">struct edge&#123;int v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">int d[N], vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">  for(int i=0;i&lt;=n;i++) d[i]=inf;</span><br><span class="line">  d[s]=0; q.push(&#123;0,s&#125;);</span><br><span class="line">  while(q.size())&#123;</span><br><span class="line">    auto t=q.top(); q.pop();</span><br><span class="line">    int u=t.second;</span><br><span class="line">    if(vis[u])continue;//再出队跳过</span><br><span class="line">    vis[u]=1;//标记u已出队</span><br><span class="line">    for(auto ed : e[u])&#123;</span><br><span class="line">      int v=ed.v, w=ed.w;</span><br><span class="line">      if(d[v]&gt;d[u]+w)&#123;</span><br><span class="line">        d[v]=d[u]+w;</span><br><span class="line">        q.push(&#123;-d[v],v&#125;);//大根堆</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">  for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    e[a].push_back(&#123;b,c&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  dijkstra(s);</span><br><span class="line">  for(int i=1;i&lt;=n;i++)</span><br><span class="line">    printf(&quot;%d &quot;,d[i]); </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;LL v,c,ne;&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="comment">//e[i].b  出边</span></span><br><span class="line">    <span class="comment">//e[i].c  边权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大根堆重构"><a href="#大根堆重构" class="headerlink" title="大根堆重构"></a>大根堆重构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node&amp; a, <span class="type">const</span> Node&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value &lt; b.value; <span class="comment">//将value的值由大到小排列，形成Node的大根堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="302-最短路-Bellman-Ford-算法-spfa-算法-判负环"><a href="#302-最短路-Bellman-Ford-算法-spfa-算法-判负环" class="headerlink" title="302 最短路 Bellman-Ford 算法 spfa 算法 判负环"></a><a href="https://www.cnblogs.com/dx123/p/16320435.html">302 最短路 Bellman-Ford 算法 spfa 算法 判负环</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Ford 判负环 740ms</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const int N=2010,M=6010;</span><br><span class="line">int n,m;</span><br><span class="line">int to[M],ne[M],w[M],h[N],tot;</span><br><span class="line">int d[N];</span><br><span class="line"></span><br><span class="line">void add(int a,int b,int c)&#123;</span><br><span class="line">  to[++tot]=b;w[tot]=c;</span><br><span class="line">  ne[tot]=h[a];h[a]=tot;</span><br><span class="line">&#125;</span><br><span class="line">bool ford()&#123;</span><br><span class="line">  memset(d,inf,sizeof d); d[1]=0;</span><br><span class="line">  bool flag; //是否松弛</span><br><span class="line">  for(int i=1;i&lt;=n;i++)&#123; //跑n轮</span><br><span class="line">    flag=false;</span><br><span class="line">    for(int u=1;u&lt;=n;u++)&#123; //n个点</span><br><span class="line">      if(d[u]==inf)continue;</span><br><span class="line">      for(int j=h[u];j;j=ne[j])&#123;</span><br><span class="line">        int v=to[j];</span><br><span class="line">        if(d[v]&gt;d[u]+w[j])&#123;</span><br><span class="line">          d[v]=d[u]+w[j];</span><br><span class="line">          flag=true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)break;</span><br><span class="line">  &#125;</span><br><span class="line">  return flag; //第n轮=true,有负环</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  int T;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">  while(T--)&#123;</span><br><span class="line">    tot=0; memset(h,0,sizeof(h));</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">      int u,v,w;</span><br><span class="line">      scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">      add(u,v,w);</span><br><span class="line">      if(w&gt;=0)add(v,u,w);;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(ford()?&quot;YES&quot;:&quot;NO&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="303-最短路-Floyd-算法"><a href="#303-最短路-Floyd-算法" class="headerlink" title="303 最短路 Floyd 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320442.html">303 最短路 Floyd 算法</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=210,M=20010;</span><br><span class="line">int n,m,a,b,c;</span><br><span class="line">int d[N][N];</span><br><span class="line"></span><br><span class="line">void floyd()&#123;</span><br><span class="line">  for(int k=1; k&lt;=n; k++)</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">      for(int j=1; j&lt;=n; j++)</span><br><span class="line">        d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  memset(d,0x3f,sizeof d);</span><br><span class="line">  for(int i=1; i&lt;=n; i++)d[i][i]=0;</span><br><span class="line">  for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    d[a][b]=min(d[a][b],c); //重边</span><br><span class="line">  &#125;</span><br><span class="line">  floyd();</span><br><span class="line">  for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    for(int j=1;j&lt;=n;j++) </span><br><span class="line">      printf(&quot;%d &quot;,d[i][j]);</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="304-最短路-Johnson-算法"><a href="#304-最短路-Johnson-算法" class="headerlink" title="304 最短路 Johnson 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320444.html">304 最短路 Johnson 算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P5905 【模板】Johnson 全源最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 30010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a,b,c;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> vis[N],cnt[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> h[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">63</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    h[<span class="number">0</span>]=<span class="number">0</span>,vis[<span class="number">0</span>]=<span class="number">1</span>;q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed : e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v=ed.v,w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(h[v]&gt;h[u]+w)&#123;</span><br><span class="line">                h[v]=h[u]+w;</span><br><span class="line">        cnt[v]=cnt[u]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[v]&gt;n)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)d[i]=INF;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    d[s]=<span class="number">0</span>; q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">top</span>().second;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed : e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v=ed.v,w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+w)&#123;</span><br><span class="line">                d[v]=d[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(&#123;-d[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c, e[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      e[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;i,<span class="number">0</span>&#125;);<span class="comment">//加虚拟边</span></span><br><span class="line">      </span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ed:e[u])</span><br><span class="line">        ed.w+=h[u]-h[ed.v];<span class="comment">//构造新边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">dijkstra</span>(i);<span class="comment">//i次循环</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j]==INF) ans+=(<span class="type">long</span> <span class="type">long</span>)j*INF;</span><br><span class="line">            <span class="keyword">else</span> ans+=(<span class="type">long</span> <span class="type">long</span>)j*(d[j]+h[j]-h[i]);<span class="comment">//(d[j]+h[j]-h[i])为i到j的边权</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="305-最小环"><a href="#305-最小环" class="headerlink" title="305 最小环"></a><a href="https://www.cnblogs.com/dx123/p/16320450.html">305 最小环</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=110;</span><br><span class="line">int n,m,a,b,c,ans=1e8;</span><br><span class="line">int w[N][N],d[N][N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  for(int i=1;i&lt;=n;i++)</span><br><span class="line">    for(int j=1;j&lt;=n;j++)</span><br><span class="line">      if(i!=j) w[i][j]=1e8;</span><br><span class="line">  for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    w[a][b]=w[b][a]=c;</span><br><span class="line">  &#125;</span><br><span class="line">  memcpy(d,w,sizeof d);</span><br><span class="line">  </span><br><span class="line">  for(int k=1; k&lt;=n; k++)&#123;</span><br><span class="line">    for(int i=1; i&lt;k; i++)</span><br><span class="line">      for(int j=i+1; j&lt;k; j++)</span><br><span class="line">        ans=min(ans,d[i][j]+w[j][k]+w[k][i]);</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">      for(int j=1; j&lt;=n; j++)</span><br><span class="line">        d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  if(ans==1e8) puts(&quot;No solution.&quot;);</span><br><span class="line">  else printf(&quot;%d\n&quot;,ans);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="311-最小生成树-Prim-算法"><a href="#311-最小生成树-Prim-算法" class="headerlink" title="311 最小生成树 Prim 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320452.html">311 最小生成树 Prim 算法</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define inf 1e9</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=5010;</span><br><span class="line">int n,m,a,b,c,ans,cnt;</span><br><span class="line">struct edge&#123;int v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">int d[N], vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">bool prim(int s)&#123;</span><br><span class="line">  for(int i=0;i&lt;=n;i++) d[i]=inf;</span><br><span class="line">  d[s]=0; q.push(&#123;0,s&#125;);</span><br><span class="line">  while(q.size())&#123;</span><br><span class="line">    int u=q.top().second; q.pop();</span><br><span class="line">    if(vis[u])continue;//再出队跳过</span><br><span class="line">    vis[u]=1;//标记u已出队</span><br><span class="line">    ans+=d[u]; cnt++;</span><br><span class="line">    for(auto ed : e[u])&#123;</span><br><span class="line">      int v=ed.v, w=ed.w;</span><br><span class="line">      if(d[v]&gt;w)&#123;</span><br><span class="line">        d[v]=w;</span><br><span class="line">        q.push(&#123;-d[v],v&#125;);//大根堆</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cnt==n;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    e[a].push_back(&#123;b,c&#125;);</span><br><span class="line">    e[b].push_back(&#123;a,c&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  if(!prim(1))puts(&quot;orz&quot;);</span><br><span class="line">  else printf(&quot;%d\n&quot;,ans); </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="321-最近公共祖先-倍增算法"><a href="#321-最近公共祖先-倍增算法" class="headerlink" title="321 最近公共祖先 倍增算法"></a><a href="https://www.cnblogs.com/dx123/p/16320461.html">321 最近公共祖先 倍增算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>; </span><br><span class="line"><span class="type">int</span> n,m,s,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dep[N],fa[N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">  fa[u][<span class="number">0</span>]=f;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">19</span>; i++) </span><br><span class="line">    fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : e[u])</span><br><span class="line">    <span class="keyword">if</span>(v!=f) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u, v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>; ~i; i--)</span><br><span class="line">    <span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v])</span><br><span class="line">      u=fa[u][i];</span><br><span class="line">  <span class="keyword">if</span>(u==v) <span class="keyword">return</span> v;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>; ~i; i--)</span><br><span class="line">    <span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">      u=fa[u][i], v=fa[v][i];</span><br><span class="line">  <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n,&amp;m,&amp;s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lca</span>(a, b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用dfs建立深度，最大子树，节点总值，数组"><a href="#利用dfs建立深度，最大子树，节点总值，数组" class="headerlink" title="利用dfs建立深度，最大子树，节点总值，数组"></a>利用dfs建立深度，最大子树，节点总值，数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mina[x] = a[x];<span class="comment">//最小子树</span></span><br><span class="line">	cnt[x] = <span class="number">1</span>;<span class="comment">//子节点个数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> tx : e[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(tx == fa) <span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		dep[tx] = dep[x] + <span class="number">1</span>;<span class="comment">//深度</span></span><br><span class="line">		f[tx][<span class="number">0</span>] = x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">			f[tx][i] = f[f[tx][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">dfs</span>(tx, x);</span><br><span class="line">		mina[x] = <span class="built_in">min</span>(mina[x], mina[tx]);</span><br><span class="line">		cnt[x] += cnt[tx];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="322-最近公共祖先-Tarjan算法"><a href="#322-最近公共祖先-Tarjan算法" class="headerlink" title="322 最近公共祖先 Tarjan算法"></a><a href="https://www.cnblogs.com/dx123/p/16320465.html">322 最近公共祖先 Tarjan算法</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=500005,M=2*N;</span><br><span class="line">int n,m,s,a,b;</span><br><span class="line">vector&lt;int&gt; e[N];</span><br><span class="line">vector&lt;pair&lt;int,int&gt;&gt;query[N];</span><br><span class="line">int fa[N],vis[N],ans[M]; </span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">  if(x==fa[x]) return x;</span><br><span class="line">  return fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void tarjan(int x)&#123;</span><br><span class="line">  vis[x]=true;//标记x已访问</span><br><span class="line">  for(auto y : e[x])&#123;</span><br><span class="line">    if(!vis[y])&#123;</span><br><span class="line">      tarjan(y);</span><br><span class="line">      fa[y]=x;//回到x时指向x</span><br><span class="line">    &#125;        </span><br><span class="line">  &#125;</span><br><span class="line">  //离开x时找LCA</span><br><span class="line">  for(auto q : query[x])&#123;</span><br><span class="line">    int y=q.first,i=q.second;</span><br><span class="line">    if(vis[y])ans[i]=find(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  scanf(&quot;%d%d%d&quot;, &amp;n,&amp;m,&amp;s);</span><br><span class="line">  for(int i=1; i&lt;n; i++)&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    e[a].push_back(b);</span><br><span class="line">    e[b].push_back(a);</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    query[a].push_back(&#123;b,i&#125;);</span><br><span class="line">    query[b].push_back(&#123;a,i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for(int i=1;i&lt;=N;i++)fa[i]=i;</span><br><span class="line">  tarjan(s);</span><br><span class="line">  for(int i=1; i&lt;=m; i++)</span><br><span class="line">    printf(&quot;%d\n&quot;,ans[i]);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="323-最近公共祖先-树链剖分"><a href="#323-最近公共祖先-树链剖分" class="headerlink" title="323 最近公共祖先 树链剖分"></a><a href="https://www.cnblogs.com/dx123/p/16320467.html">323 最近公共祖先 树链剖分</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P3379 【模板】最近公共祖先（LCA）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N],son[N],dep[N],sz[N];</span><br><span class="line"><span class="type">int</span> top[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123; <span class="comment">//搞fa,dep,son</span></span><br><span class="line">  fa[u]=father,dep[u]=dep[father]+<span class="number">1</span>,sz[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==father) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">    sz[u]+=sz[v];</span><br><span class="line">    <span class="keyword">if</span>(sz[son[u]]&lt;sz[v])son[u]=v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123; <span class="comment">//搞top</span></span><br><span class="line">  top[u]=t; <span class="comment">//记录链头</span></span><br><span class="line">  <span class="comment">// printf(&quot;top[%d]=%d\n&quot;,u,t);</span></span><br><span class="line">  <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;<span class="comment">//无重儿子返回</span></span><br><span class="line">  <span class="built_in">dfs2</span>(son[u],t); <span class="comment">//搜重儿子</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==son[u])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(v,v); <span class="comment">//搜轻儿子</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    u=fa[top[u]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dep[u]&lt;dep[v]?u:v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(s,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(s,s);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lca</span>(a,b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="324-树上修改与查询-树链剖分"><a href="#324-树上修改与查询-树链剖分" class="headerlink" title="324 树上修改与查询 树链剖分"></a><a href="https://www.cnblogs.com/dx123/p/16320469.html">324 树上修改与查询 树链剖分</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Luogu P3384 【模板】轻重链剖分/树链剖分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc u&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,root,p;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N],dep[N],sz[N],son[N];</span><br><span class="line"><span class="type">int</span> top[N],id[N],nw[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;<span class="comment">//搞fa,dep,sz,son</span></span><br><span class="line">  fa[u]=father,dep[u]=dep[father]+<span class="number">1</span>,sz[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==father) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">    sz[u]+=sz[v];</span><br><span class="line">    <span class="keyword">if</span>(sz[son[u]]&lt;sz[v]) son[u]=v; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;<span class="comment">//搞top,id,nw</span></span><br><span class="line">  top[u]=t,id[u]=++cnt,nw[cnt]=w[u];</span><br><span class="line">  <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[u],t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==son[u])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">  <span class="type">int</span> l,r; </span><br><span class="line">  LL add,sum;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>]; <span class="comment">//线段树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  tr[u].sum=tr[lc].sum+tr[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tr[u].add)&#123;</span><br><span class="line">    tr[lc].sum+=tr[u].add*(tr[lc].r-tr[lc].l+<span class="number">1</span>);</span><br><span class="line">    tr[rc].sum+=tr[u].add*(tr[rc].r-tr[rc].l+<span class="number">1</span>);</span><br><span class="line">    tr[lc].add+=tr[u].add;</span><br><span class="line">    tr[rc].add+=tr[u].add;</span><br><span class="line">    tr[u].add=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  tr[u]=&#123;l,r,<span class="number">0</span>,nw[r]&#125;;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(lc,l,mid),<span class="built_in">build</span>(rc,mid+<span class="number">1</span>,r);</span><br><span class="line">  <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r)&#123;</span><br><span class="line">    tr[u].add+=k;</span><br><span class="line">    tr[u].sum+=k*(tr[u].r-tr[u].l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(u);</span><br><span class="line">  <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(lc,l,r,k);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(rc,l,r,k);</span><br><span class="line">  <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_path</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>,id[top[u]],id[u],k);</span><br><span class="line">    u=fa[top[u]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>,id[v],id[u],k);<span class="comment">//最后一段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tree</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>,id[u],id[u]+sz[u]<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r)<span class="keyword">return</span> tr[u].sum;</span><br><span class="line">  <span class="built_in">pushdown</span>(u);</span><br><span class="line">  <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  LL res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">query</span>(lc,l,r);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">query</span>(rc,l,r);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query_path</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  LL res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    res+=<span class="built_in">query</span>(<span class="number">1</span>,id[top[u]],id[u]);</span><br><span class="line">    u=fa[top[u]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">  res+=<span class="built_in">query</span>(<span class="number">1</span>,id[v],id[u]);<span class="comment">//最后一段</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query_tree</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,id[u],id[u]+sz[u]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root,&amp;p);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(root,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(root,root);<span class="comment">//把树拆成链</span></span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n); <span class="comment">//用链建线段树</span></span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> t,u,v,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t,&amp;u);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v,&amp;k);</span><br><span class="line">      <span class="built_in">update_path</span>(u,v,k);<span class="comment">//表示将树从 xx 到 yy 结点最短路径上所有节点的值都加上 zz。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">      <span class="built_in">update_tree</span>(u,k);<span class="comment">//表示求树从 xx 到 yy 结点最短路径上所有节点的值之和。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_path</span>(u,v)%p);<span class="comment">//表示求树从 xx 到 yy 结点最短路径上所有节点的值之和。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_tree</span>(u)%p);<span class="comment">//表示求以 xx 为根节点的子树内所有节点值之和</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="341-强连通分量-Tarjan-算法"><a href="#341-强连通分量-Tarjan-算法" class="headerlink" title="341 强连通分量 Tarjan 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320476.html">341 强连通分量 Tarjan 算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],instk[N],top;</span><br><span class="line"><span class="type">int</span> scc[N],siz[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="comment">//入x时，盖戳、入栈</span></span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  stk[++top]=x,instk[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]);<span class="comment">//回x时更新low</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(instk[y])<span class="comment">//若y已访问且在栈中</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);<span class="comment">//在x时更新low</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//离x时，收集SCC</span></span><br><span class="line">  <span class="keyword">if</span>(dfn[x]==low[x])&#123;<span class="comment">//若x是SCC的根</span></span><br><span class="line">    <span class="type">int</span> y; ++cnt;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      y=stk[top--];</span><br><span class="line">      instk[y]=<span class="number">0</span>;</span><br><span class="line">      scc[y]=cnt;<span class="comment">//SCC编号</span></span><br><span class="line">      ++siz[cnt];<span class="comment">//SCC大小</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b, e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//可能不连通</span></span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">   <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">     <span class="keyword">if</span>(siz[i]&gt;<span class="number">1</span>) ans++;</span><br><span class="line">   cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="342-Tarjan-缩点"><a href="#342-Tarjan-缩点" class="headerlink" title="342 Tarjan 缩点"></a><a href="https://www.cnblogs.com/dx123/p/16320478.html">342 Tarjan 缩点</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],instk[N],top;</span><br><span class="line"><span class="type">int</span> scc[N],cnt;</span><br><span class="line"><span class="type">int</span> din[N],dout[N];<span class="comment">//SCC的入度,出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot; </span><br><span class="line">  stk[++top]=x,instk[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);<span class="comment">////</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(instk[y])<span class="comment">//若y已访问且在栈中</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dfn[x]==low[x])&#123;<span class="comment">//若x是SCC的根</span></span><br><span class="line">    <span class="type">int</span> y;++cnt;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      y=stk[top--];</span><br><span class="line">      instk[y]=<span class="number">0</span>;</span><br><span class="line">      scc[y]=cnt; <span class="comment">//y属于哪个SCC</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, a; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a, a) </span><br><span class="line">      e[i].<span class="built_in">push_back</span>(a);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y : e[x])</span><br><span class="line">      <span class="keyword">if</span>(scc[x]!=scc[y])&#123;</span><br><span class="line">        din[scc[y]]++;</span><br><span class="line">        dout[scc[x]]++;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="type">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!din[i]) a++;</span><br><span class="line">    <span class="keyword">if</span>(!dout[i]) b++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">  <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(a,b));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="343-Tarjan-割点"><a href="#343-Tarjan-割点" class="headerlink" title="343 Tarjan 割点"></a><a href="https://www.cnblogs.com/dx123/p/16320481.html">343 Tarjan 割点</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P3388 【模板】割点</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  <span class="type">int</span> child=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]); </span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">        child++;<span class="comment">//子树个数</span></span><br><span class="line">        <span class="keyword">if</span>(x!=root||child&gt;<span class="number">1</span>)</span><br><span class="line">          cut[x]=<span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//若y已经访问</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b),</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(root=<span class="number">1</span>; root&lt;=n; root++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[root])<span class="built_in">tarjan</span>(root);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(cut[i]) ans++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(cut[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h1 id="344-Tarjan-割边"><a href="#344-Tarjan-割边" class="headerlink" title="344 Tarjan 割边"></a><a href="https://www.cnblogs.com/dx123/p/16320483.html">344 Tarjan 割边</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v;&#125;;</span><br><span class="line">vector&lt;edge&gt;e;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;h[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bridge</span>&#123;</span><br><span class="line">  <span class="type">int</span> x,y;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> bridge &amp;t)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t.x)<span class="keyword">return</span> y&lt;t.y;</span><br><span class="line">    <span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;bri[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e.<span class="built_in">push_back</span>(&#123;a,b&#125;);</span><br><span class="line">  h[a].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> in_edge)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=h[x][i], y=e[j].v;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y,j);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;dfn[x])&#123;</span><br><span class="line">        bri[cnt++]=&#123;x,y&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j!=(in_edge^<span class="number">1</span>))<span class="comment">//不是反边</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(bri,bri+cnt);  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,bri[i].x,bri[i].y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="345-Tarjan-eDCC-缩点"><a href="#345-Tarjan-eDCC-缩点" class="headerlink" title="345 Tarjan eDCC 缩点"></a><a href="https://www.cnblogs.com/dx123/p/16320488.html">345 Tarjan eDCC 缩点</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// POJ 3177 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>;<span class="comment">//2,3开始配对</span></span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">int</span> dcc[N],cnt;</span><br><span class="line"><span class="type">int</span> bri[M],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx].v=b; e[idx].ne=h[a];</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> in_edg)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  stk.<span class="built_in">push</span>(x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> y=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y,i);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;dfn[x])</span><br><span class="line">        bri[i]=bri[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i!=(in_edg^<span class="number">1</span>))<span class="comment">//不是反边</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">int</span> y=stk.<span class="built_in">top</span>();stk.<span class="built_in">pop</span>();</span><br><span class="line">      dcc[y]=cnt;<span class="comment">//记录eDCC</span></span><br><span class="line">      <span class="keyword">if</span>(y==x)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=idx;i++)</span><br><span class="line">    <span class="keyword">if</span>(bri[i])</span><br><span class="line">      d[dcc[e[i].v]]++;<span class="comment">//度数</span></span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    <span class="keyword">if</span>(d[i]==<span class="number">1</span>) sum++;<span class="comment">//叶节点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(sum+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="346-Tarjan-vDCC-缩点"><a href="#346-Tarjan-vDCC-缩点" class="headerlink" title="346 Tarjan vDCC 缩点"></a><a href="https://www.cnblogs.com/dx123/p/16320490.html">346 Tarjan vDCC 缩点</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N],ne[N]; </span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],top;</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N];</span><br><span class="line"><span class="type">int</span> root,cnt,num,id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tot;</span><br><span class="line">  stk[++top]=x;</span><br><span class="line">  <span class="keyword">if</span>(x==root&amp;&amp;!e[x].<span class="built_in">size</span>())&#123;<span class="comment">//孤立点</span></span><br><span class="line">    dcc[++cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> child=<span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y : e[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//若y尚未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);<span class="comment">////</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[y]); </span><br><span class="line">      <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">        child++;</span><br><span class="line">        <span class="keyword">if</span>(x!=root||child&gt;<span class="number">1</span>)</span><br><span class="line">          cut[x]=<span class="literal">true</span>; </span><br><span class="line">        <span class="type">int</span> z; cnt++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vDCC:&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123; <span class="comment">//记录vDCC</span></span><br><span class="line">          z=stk[top--];</span><br><span class="line">          dcc[cnt].<span class="built_in">push_back</span>(z);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,z);</span><br><span class="line">        &#125;<span class="keyword">while</span>(z!=y);</span><br><span class="line">        dcc[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//若y已经访问</span></span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b),</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(root=<span class="number">1</span>;root&lt;=n;root++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[root])</span><br><span class="line">      <span class="built_in">tarjan</span>(root);</span><br><span class="line">      </span><br><span class="line">  <span class="comment">//给每个割点一个新编号（cnt+1开始）</span></span><br><span class="line">  num=cnt;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(cut[i])id[i]=++num;</span><br><span class="line">  <span class="comment">//建新图，从每个vDCC向对应割点连边</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dcc[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">      <span class="type">int</span> x=dcc[i][j];</span><br><span class="line">      <span class="keyword">if</span>(cut[x])&#123;</span><br><span class="line">        ne[i].<span class="built_in">push_back</span>(id[x]),</span><br><span class="line">        ne[id[x]].<span class="built_in">push_back</span>(i);        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="361-网络流-最大流-EK-算法"><a href="#361-网络流-最大流-EK-算法" class="headerlink" title="361 网络流 最大流 EK 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320492.html">361 网络流 最大流 EK 算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P3376 【模板】网络最大流</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;LL v,c,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>;<span class="comment">//从2,3开始配对</span></span><br><span class="line">LL mf[N],pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//找增广路</span></span><br><span class="line">  <span class="built_in">memset</span>(mf,<span class="number">0</span>,<span class="keyword">sizeof</span> mf);</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(S); mf[S]=<span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">      LL v=e[i].v;</span><br><span class="line">      <span class="keyword">if</span>(mf[v]==<span class="number">0</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">        mf[v]=<span class="built_in">min</span>(mf[u],e[i].c);</span><br><span class="line">        pre[v]=i;<span class="comment">//存前驱边</span></span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(v==T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">EK</span><span class="params">()</span></span>&#123;<span class="comment">//累加可行流</span></span><br><span class="line">  LL flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">    <span class="type">int</span> v=T;</span><br><span class="line">    <span class="keyword">while</span>(v!=S)&#123;<span class="comment">//更新残留网</span></span><br><span class="line">      <span class="type">int</span> i=pre[v];</span><br><span class="line">      e[i].c-=mf[T];</span><br><span class="line">      e[i^<span class="number">1</span>].c+=mf[T];</span><br><span class="line">      v=e[i^<span class="number">1</span>].v;</span><br><span class="line">    &#125;</span><br><span class="line">    flow+=mf[T];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">add</span>(a,b,c); </span><br><span class="line">    <span class="built_in">add</span>(b,a,<span class="number">0</span>);<span class="comment">//反向边</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">EK</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="362-网络流-最大流-Dinic-算法"><a href="#362-网络流-最大流-Dinic-算法" class="headerlink" title="362 网络流 最大流 Dinic 算法"></a><a href="https://www.cnblogs.com/dx123/p/16320495.html">362 网络流 最大流 Dinic 算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;LL v,c,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>; <span class="comment">//从2,3开始配对</span></span><br><span class="line"><span class="type">int</span> d[N],cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123; <span class="comment">//对点分层，找增广路</span></span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt;q; </span><br><span class="line">  q.<span class="built_in">push</span>(S); d[S]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">      <span class="type">int</span> v=e[i].v;</span><br><span class="line">      <span class="keyword">if</span>(d[v]==<span class="number">0</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">        d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(v==T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, LL mf)</span></span>&#123; <span class="comment">//多路增广</span></span><br><span class="line">  <span class="keyword">if</span>(u==T) <span class="keyword">return</span> mf;</span><br><span class="line">  LL sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].ne)&#123;</span><br><span class="line">    cur[u]=i; <span class="comment">//当前弧优化</span></span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(d[v]==d[u]+<span class="number">1</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">      LL f=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(mf,e[i].c));</span><br><span class="line">      e[i].c-=f; </span><br><span class="line">      e[i^<span class="number">1</span>].c+=f; <span class="comment">//更新残留网</span></span><br><span class="line">      sum+=f; <span class="comment">//累加u的流出流量</span></span><br><span class="line">      mf-=f;  <span class="comment">//减少u的剩余流量</span></span><br><span class="line">      <span class="keyword">if</span>(mf==<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//余量优化</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(sum==<span class="number">0</span>) d[u]=<span class="number">0</span>; <span class="comment">//残枝优化</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dinic</span><span class="params">()</span></span>&#123; <span class="comment">//累加可行流</span></span><br><span class="line">  LL flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, h, <span class="keyword">sizeof</span> h);</span><br><span class="line">    flow+=<span class="built_in">dfs</span>(S,<span class="number">1e9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">  <span class="keyword">while</span>(m -- )&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">add</span>(a,b,c); <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">dinic</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="381-二分图判定-染色法"><a href="#381-二分图判定-染色法" class="headerlink" title="381 二分图判定 染色法"></a><a href="https://www.cnblogs.com/dx123/p/16418198.html">381 二分图判定 染色法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  color[u]=c;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(!color[v])&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">dfs</span>(v,<span class="number">3</span>-c))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(color[v]==c)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//有奇环</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">add</span>(a,b); </span><br><span class="line">    <span class="built_in">add</span>(b,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!color[i])</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">dfs</span>(i,<span class="number">1</span>))&#123;</span><br><span class="line">        flag=<span class="number">1</span>;<span class="comment">//有奇环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="382-二分图最大匹配-匈牙利算法"><a href="#382-二分图最大匹配-匈牙利算法" class="headerlink" title="382 二分图最大匹配 匈牙利算法"></a><a href="https://www.cnblogs.com/dx123/p/16418297.html">382 二分图最大匹配 匈牙利算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Luogu P3386 【模板】二分图最大匹配</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,a,b,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> vis[N],match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v; <span class="comment">//妹子</span></span><br><span class="line">    <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[v]=<span class="number">1</span>; <span class="comment">//先标记这个妹子</span></span><br><span class="line">    <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">      match[v]=u; <span class="comment">//配成对</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b, <span class="built_in">add</span>(a,b);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="383-二分图最大匹配-Dinic算法"><a href="#383-二分图最大匹配-Dinic算法" class="headerlink" title="383 二分图最大匹配 Dinic算法"></a><a href="https://www.cnblogs.com/dx123/p/16419587.html">383 二分图最大匹配 Dinic算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 2000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k,S,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,c,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],idx=<span class="number">1</span>; <span class="comment">//从2,3开始配对</span></span><br><span class="line"><span class="type">int</span> d[N],cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123; <span class="comment">//对点分层，找增广路</span></span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt;q; </span><br><span class="line">  q.<span class="built_in">push</span>(S); d[S]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">      <span class="type">int</span> v=e[i].v;</span><br><span class="line">      <span class="keyword">if</span>(d[v]==<span class="number">0</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">        d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(v==T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> mf)</span></span>&#123; <span class="comment">//多路增广</span></span><br><span class="line">  <span class="keyword">if</span>(u==T) <span class="keyword">return</span> mf;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].ne)&#123;</span><br><span class="line">    cur[u]=i; <span class="comment">//当前弧优化</span></span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(d[v]==d[u]+<span class="number">1</span> &amp;&amp; e[i].c)&#123;</span><br><span class="line">      <span class="type">int</span> f=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(mf,e[i].c));</span><br><span class="line">      e[i].c-=f; </span><br><span class="line">      e[i^<span class="number">1</span>].c+=f; <span class="comment">//更新残留网</span></span><br><span class="line">      sum+=f; <span class="comment">//累加u的流出流量</span></span><br><span class="line">      mf-=f;  <span class="comment">//减少u的剩余流量</span></span><br><span class="line">      <span class="keyword">if</span>(mf==<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//余量优化</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(sum==<span class="number">0</span>) d[u]=<span class="number">0</span>; <span class="comment">//残枝优化</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123; <span class="comment">//累加可行流</span></span><br><span class="line">  <span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, h, <span class="keyword">sizeof</span> h);</span><br><span class="line">    flow+=<span class="built_in">dfs</span>(S,<span class="number">1e9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">  <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">add</span>(a,b+n,<span class="number">1</span>);<span class="built_in">add</span>(b+n,a,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  S=<span class="number">0</span>;T=n+m+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">add</span>(S,i,<span class="number">1</span>),<span class="built_in">add</span>(i,S,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+n,T,<span class="number">1</span>),<span class="built_in">add</span>(T,i+n,<span class="number">0</span>); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">dinic</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="384-二分图最大权完美匹配-KM算法"><a href="#384-二分图最大权完美匹配-KM算法" class="headerlink" title="384 二分图最大权完美匹配 KM算法"></a><a href="https://www.cnblogs.com/dx123/p/16436807.html">384 二分图最大权完美匹配 KM算法</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e12</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> match[N];<span class="comment">//右点匹配了哪个左点</span></span><br><span class="line"><span class="type">int</span> va[N],vb[N];<span class="comment">//标记是否在交替路中</span></span><br><span class="line">LL la[N],lb[N];<span class="comment">//左顶标,右顶标</span></span><br><span class="line">LL w[N][N],d[N];<span class="comment">//维护更新的delta值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    va[x]=<span class="number">1</span>; <span class="comment">//x在交替路中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=n;y++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!vb[y])&#123;</span><br><span class="line">          <span class="keyword">if</span>(la[x]+lb[y]-w[x][y]==<span class="number">0</span>)&#123;<span class="comment">//相等子图</span></span><br><span class="line">              vb[y]=<span class="number">1</span>; <span class="comment">//y在交替路中</span></span><br><span class="line">              <span class="keyword">if</span>(!match[y]||<span class="built_in">dfs</span>(match[y]))&#123;</span><br><span class="line">                match[y]=x; <span class="comment">//配对</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//不是相等子图则记录最小的d[y]</span></span><br><span class="line">            d[y]=<span class="built_in">min</span>(d[y],la[x]+lb[y]-w[x][y]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">KM</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//左顶标取i的出边的最大边权</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) la[i]=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">          la[i]=<span class="built_in">max</span>(la[i],w[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lb[i]=<span class="number">0</span>;      </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;<span class="comment">//直到左点i找到匹配</span></span><br><span class="line">            <span class="built_in">fill</span>(va+<span class="number">1</span>,va+n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">fill</span>(vb+<span class="number">1</span>,vb+n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">fill</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>,INF);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i))<span class="keyword">break</span>;</span><br><span class="line">          LL delta=INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">              <span class="keyword">if</span>(!vb[j])delta=<span class="built_in">min</span>(delta,d[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//修改顶标</span></span><br><span class="line">              <span class="keyword">if</span>(va[j])la[j]-=delta;</span><br><span class="line">              <span class="keyword">if</span>(vb[j])lb[j]+=delta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)res+=w[match[i]][i];    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">          w[i][j]=-INF; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        w[x][y]=z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">KM</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,match[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="391-基环树-P2607-ZJOI2008-骑士"><a href="#391-基环树-P2607-ZJOI2008-骑士" class="headerlink" title="391 基环树 P2607 ZJOI2008] 骑士"></a>391 基环树 P2607 <a href="https://www.cnblogs.com/dx123/p/16464427.html">ZJOI2008] 骑士</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题意:每个骑士有一个不可以同时上场的骑士，和一个战斗力。求最大战斗力</span></span><br><span class="line"><span class="comment">//转化: n个点n条边，每个点有权值，有边相连的两个点只能选其一，求可选方案的最大的点权之和。</span></span><br><span class="line"><span class="comment">// Luogu P2607 [ZJOI2008] 骑士</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[N];</span><br><span class="line"><span class="type">int</span> h[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> r1,r2,vis[N];</span><br><span class="line">LL f[N][<span class="number">2</span>],sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//找两个根</span></span><br><span class="line">  vis[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==rt)&#123;r1=u,r2=v;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">find</span>(v,rt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> rt)</span></span>&#123;<span class="comment">//树上DP</span></span><br><span class="line">  f[u][<span class="number">0</span>]=<span class="number">0</span>; f[u][<span class="number">1</span>]=w[u];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==rt)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v,rt);</span><br><span class="line">    f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">    f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>,u;v&lt;=n;v++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[v],&amp;u);</span><br><span class="line">    <span class="built_in">add</span>(u,v);<span class="comment">//单向边</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">      r1=r2=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">find</span>(i,i);</span><br><span class="line">      <span class="keyword">if</span>(r1)&#123;</span><br><span class="line">        LL res1=<span class="built_in">dfs</span>(r1,r1);</span><br><span class="line">        LL res2=<span class="built_in">dfs</span>(r2,r2);</span><br><span class="line">        sum+=<span class="built_in">max</span>(res1,res2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P2607 [ZJOI2008] 骑士</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> h[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> fa[N]; <span class="comment">//并查集的根数组</span></span><br><span class="line">LL f[N][<span class="number">2</span>],sum;</span><br><span class="line">vector&lt;PII&gt; roots;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,h[a]&#125;;</span><br><span class="line">  h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;<span class="comment">//树上DP</span></span><br><span class="line">  f[u][<span class="number">0</span>]=<span class="number">0</span>; f[u][<span class="number">1</span>]=w[u];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">    f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;x);</span><br><span class="line">    <span class="type">int</span> pa=<span class="built_in">find</span>(i),pb=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(pa!=pb)&#123;</span><br><span class="line">      fa[pa]=pb;<span class="comment">//合并</span></span><br><span class="line">      <span class="built_in">add</span>(i,x),<span class="built_in">add</span>(x,i);<span class="comment">//加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      roots.<span class="built_in">push_back</span>(&#123;x,i&#125;);<span class="comment">//存根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> t:roots)&#123;</span><br><span class="line">    <span class="type">int</span> a=t.first,b=t.second;</span><br><span class="line">    sum+=<span class="built_in">max</span>(<span class="built_in">dfs</span>(a,<span class="number">-1</span>),<span class="built_in">dfs</span>(b,<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="392-基环树-P1399-NOI2013-快餐店"><a href="#392-基环树-P1399-NOI2013-快餐店" class="headerlink" title="392 基环树 P1399 NOI2013] 快餐店"></a>392 基环树 P1399 <a href="https://www.cnblogs.com/dx123/p/16464432.html">NOI2013] 快餐店</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P1399 [NOI2013] 快餐店</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w,ne;&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> vis[N],fa[N],w[N];</span><br><span class="line"><span class="type">int</span> inc[N],cv[N],cw[N],cn;</span><br><span class="line"><span class="type">double</span> d[N],A[N],B[N],C[N],D[N];</span><br><span class="line"><span class="type">double</span> ans1,ans2=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++idx]=&#123;b,c,h[a]&#125;;h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa[u])&#123;</span><br><span class="line">            fa[v]=u; w[v]=e[i].w;      </span><br><span class="line">            <span class="keyword">if</span>(!vis[v])&#123;<span class="comment">//v尚未访问</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(v))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//v已访问</span></span><br><span class="line">                <span class="type">int</span> p=u;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    inc[p]=<span class="number">1</span>;cv[++cn]=p;</span><br><span class="line">                    cw[cn]=w[p];p=fa[p];</span><br><span class="line">                    <span class="keyword">if</span>(p==u)<span class="keyword">break</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v, w=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(!inc[v]&amp;&amp;v!=fa)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            ans1=<span class="built_in">max</span>(ans1,d[u]+d[v]+w);</span><br><span class="line">            d[u]=<span class="built_in">max</span>(d[u],d[v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    <span class="built_in">add</span>(x,y,z);<span class="built_in">add</span>(y,x,z);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">find</span>(<span class="number">1</span>);<span class="comment">//深搜找环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn;++i)</span><br><span class="line">      <span class="built_in">dfs</span>(cv[i],<span class="number">0</span>);<span class="comment">//深搜求直径ans1</span></span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn;++i)&#123;<span class="comment">//求前缀</span></span><br><span class="line">        sum+=cw[i<span class="number">-1</span>];</span><br><span class="line">        A[i]=<span class="built_in">max</span>(A[i<span class="number">-1</span>],sum+d[cv[i]]);</span><br><span class="line">        B[i]=<span class="built_in">max</span>(B[i<span class="number">-1</span>],mx+d[cv[i]]+sum);</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,d[cv[i]]-sum);</span><br><span class="line">    &#125;</span><br><span class="line">    sum=mx=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> cn_1=cw[cn];cw[cn]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cn;i&gt;=<span class="number">1</span>;--i)&#123;<span class="comment">//求后缀</span></span><br><span class="line">        sum+=cw[i];</span><br><span class="line">        C[i]=<span class="built_in">max</span>(C[i+<span class="number">1</span>],sum+d[cv[i]]);</span><br><span class="line">        D[i]=<span class="built_in">max</span>(D[i+<span class="number">1</span>],mx+d[cv[i]]+sum);</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,d[cv[i]]-sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;cn;++i)&#123;<span class="comment">//拼凑答案</span></span><br><span class="line">        res=<span class="built_in">max</span>(<span class="built_in">max</span>(B[i],D[i+<span class="number">1</span>]),</span><br><span class="line">                A[i]+C[i+<span class="number">1</span>]+cn_1);</span><br><span class="line">        ans2=<span class="built_in">min</span>(ans2,res);</span><br><span class="line">    &#125;</span><br><span class="line">　　 ans2=<span class="built_in">min</span>(ans2,B[cn]);<span class="comment">//断最后一条边</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,<span class="built_in">max</span>(ans1,ans2)/<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="393-基环树-P5022-NOIP2018-提高组-旅行"><a href="#393-基环树-P5022-NOIP2018-提高组-旅行" class="headerlink" title="393 基环树 P5022 NOIP2018 提高组] 旅行"></a>393 基环树 P5022 <a href="https://www.cnblogs.com/dx123/p/16468119.html">NOIP2018 提高组] 旅行</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P5022 [NOIP2018 提高组] 旅行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; edge[N];</span><br><span class="line"><span class="type">int</span> du,dv,vis[N];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(N,N)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt,better;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!better)&#123;</span><br><span class="line">    <span class="comment">//若序号变大则回退，变小则走完</span></span><br><span class="line">    <span class="keyword">if</span>(u&gt;path[cnt])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;path[cnt])better=<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[u]=<span class="literal">true</span>;</span><br><span class="line">  path[cnt++]=u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[u][i];</span><br><span class="line">    <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(v==du&amp;&amp;u==dv)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(v==dv&amp;&amp;u==du)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs</span>(v))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    edge[i]=&#123;a,b&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">sort</span>(e[i].<span class="built_in">begin</span>(),e[i].<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(n==m+<span class="number">1</span>) <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//枚举断边</span></span><br><span class="line">      du=edge[i].first;</span><br><span class="line">      dv=edge[i].second;</span><br><span class="line">      <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">      cnt=better=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="394-圆方树-P5236【模板】静态仙人掌"><a href="#394-圆方树-P5236【模板】静态仙人掌" class="headerlink" title="394 圆方树 P5236【模板】静态仙人掌"></a><a href="https://www.cnblogs.com/dx123/p/16480198.html">394 圆方树 P5236【模板】静态仙人掌</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20000</span>,M=N*<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w,ne;&#125;e[M];</span><br><span class="line"><span class="type">int</span> h1[N],h2[N],idx=<span class="number">1</span>;<span class="comment">//建图</span></span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tim;<span class="comment">//tarjan</span></span><br><span class="line"><span class="type">int</span> s[N],sc[N],fa[N],fw[N],fe[N],cn;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">14</span>],dep[N],d[N];<span class="comment">//lca</span></span><br><span class="line"><span class="type">int</span> A,B;<span class="comment">//存lca的两个儿子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[],<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[++idx]=&#123;b,c,h[a]&#125;;h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> sum=w;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=v;k!=u;k=fa[k])&#123;</span><br><span class="line">    s[k]=sum; <span class="comment">//u...k的环长</span></span><br><span class="line">    sum+=fw[k]; <span class="comment">//前缀和</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// s[u]=sc[u]=sum;</span></span><br><span class="line">  <span class="built_in">add</span>(h2,u,++cn,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=v;k!=u;k=fa[k])&#123;</span><br><span class="line">    sc[k]=sum; <span class="comment">//总环长</span></span><br><span class="line">    <span class="built_in">add</span>(h2,cn,k,<span class="built_in">min</span>(s[k],sum-s[k]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ine)</span></span>&#123;</span><br><span class="line">  dfn[u]=low[u]=++tim;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h1[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])&#123; <span class="comment">//若没有访问</span></span><br><span class="line">      <span class="comment">//fw:存边权，fe:存入边</span></span><br><span class="line">      fa[v]=u,fw[v]=w,fe[v]=i;</span><br><span class="line">      <span class="built_in">tarjan</span>(v,i);</span><br><span class="line">      low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">      <span class="keyword">if</span>(dfn[u]&lt;low[v]) <span class="comment">//非环边</span></span><br><span class="line">        <span class="built_in">add</span>(h2,u,v,w);<span class="comment">//直接加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i!=(ine^<span class="number">1</span>)) <span class="comment">//构成环</span></span><br><span class="line">      low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h1[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]&lt;dfn[v]&amp;&amp;fe[v]!=i)</span><br><span class="line">      <span class="built_in">build_tree</span>(u,v,w); <span class="comment">//建树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;</span><br><span class="line">  dep[u]=dep[father]+<span class="number">1</span>;</span><br><span class="line">  f[u][<span class="number">0</span>]=father;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">13</span>;k++)</span><br><span class="line">    f[u][k]=f[f[u][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h2[u];i;i=e[i].ne)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">    d[v]=d[u]+w;</span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">13</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    <span class="keyword">if</span>(dep[f[u][k]]&gt;=dep[v])</span><br><span class="line">      u=f[u][k];</span><br><span class="line">  <span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">13</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    <span class="keyword">if</span>(f[u][k]!=f[v][k])&#123;</span><br><span class="line">      u=f[u][k];</span><br><span class="line">      v=f[v][k];</span><br><span class="line">    &#125;</span><br><span class="line">  A=u,B=v;<span class="comment">//存lca的两个儿子</span></span><br><span class="line">  <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">  cn=n;</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">add</span>(h1,a,b,c),<span class="built_in">add</span>(h1,b,a,c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//找环建树</span></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//lca打表</span></span><br><span class="line">  <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">lca</span>(u,v);<span class="comment">//找lca</span></span><br><span class="line">    <span class="keyword">if</span>(p&lt;=n) <span class="comment">//若是圆点</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d[u]+d[v]-d[p]*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//若是方点</span></span><br><span class="line">      <span class="type">int</span> len=<span class="built_in">abs</span>(s[A]-s[B]);</span><br><span class="line">      <span class="type">int</span> dAB=<span class="built_in">min</span>(len,sc[A]-len);</span><br><span class="line">      <span class="type">int</span> dis=dAB+d[u]-d[A]+d[v]-d[B];</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
